= Vulkan by example. Lesson 0.
:hp-tags: c++, vulkan

Hi everybody. Today we’ll talk about Vulkan - the modern API for communication with GPU device. There's already some information and tutorials on the web as well as books so why another one. I’ll try to explain - these tutorials out there are great by all means, but personally, for me, they are hard to follow. In this series I’ll try to build a mental picture around the API, I’ll try not to just follow instructions and create some structures because somebody says I need this, but I’ll try to understand why I need this. For that, I’ll use pictures, a lot of them. And if you read https://nikitablack.github.io/2017/03/23/Functional-programming-in-c-by-example.html[one of my previous posts] you know that I’m a fan of functional approach and I’ll use this approach through tutorials. I’ll build every next lesson on top of the previous adding a new stuff, but not modifying it - I found it easier to follow (though sometimes I’ll have to return back and tweak the old code to make it work with the new, but I’ll try to minimize this).

===== Disclaimer
I'm not an expert guru ninja, I'm just learning. And definitely, there will be mistakes in my lessons. I'm kindly asking you to point to them so I can correct it soon. You can do it via comments here, or Reddit, where I'm planning to leave a link, or cpp slack Vulkan channel which I check quite often (and which is very silent, btw).

===== What will be in tutorials
Application accepts input from the user to increase/decrease tesselation level (i.e. how fine the model is) and switch between wireframe/solid rendering. Wireframe will use `VK_CULL_MODE_NONE` cull mode (because I want to see back faces of triangles in this mode) and solid mode will use `VK_CULL_MODE_BACK_BIT` (though there're visible holes in some places, but it's done intentionally). In addition to usual vertex and index buffers I'll use uniform buffers for matrices (model, view, projection), storage buffer for patches transforms and colors and push constants for tesselation level.

===== What will not be in tutorials
I assume you know what tesselation is, why there are two related stages in the pipeline (tesselation control and tesselation evaluation), so I'll not explain it in detail. Same goes for curves surfaces - if you need to refresh your memory I recommend http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article]. Also I assume you already have Vulkan SDK installed and have all required environment variables set.

===== Code organization
I use `CMake` for code building. I run my code on Windows and Linux Mint. On Linux I use `CLion` IDE - it have nice `CMake` integration and `gcc 7`, on Windows - `Visual Studio Community 2017` with `open folder` feature. I use `c++17` a lot.

----
lesson/
├──src/
│   ├──libs/
│   │   ├──eigen/
│   │   │   └──CMakeLists.txt
│   │   ├──glfw-3.2.1/
│   │   │   └──CMakeLists.txt
│   │   └──tl/
│   │       └──CMakeLists.txt
│   └──tesselated_teapot/
│       ├──resources/
│       ├──src/
│       │   ├──app/
│       │   ├──details/
│       │   ├──vk_helpers/
│       │   ├──AppData.h
│       │   ├──Main.cpp
│       │   ├──MainApplication.cpp
│       │   ├──MainApplication.h
│       │   └──TeapotData.h
│       └──CMakeLists.txt
└──CMakeLists.txt
----
This is a typical project structure for each lesson. `resources/` folder holds shader files. All application related files go to `app/` folder, wrappers around Vulkan functions and structs go to `vk_helpers` folder and all other helpers go to `details/`.

I use some libraries in my lessons as well:

- For window creation and management I use http://www.glfw.org/[`glfw`] library - it's simple and crossplatform. It have Vulkan support and simplifies some window related Vulkan parts.
- For math I use http://eigen.tuxfamily.org/index.php[`eigen`] library instead of commonly used `glm` because I'm more familiar with it.
- As you may already know almost each Vulkan function can fail and return some error code. When my function calls such a function it needs to report the result to the main application - in case of success it have to return an object and in case of a failure it have to tell what happened. `std::optional` could be a good candidate for the return object - it can be null or object, but it doesn't say why it is null. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r4.html[`std::expected`] is what I need but it's not a part of the standard. Fortunatelly some smart people wrote an implementation for the current standard. I'm using `tl::expected` implementation from https://blog.tartanllama.xyz/[Simon Brand] (aka TartanLlama), you can read more about it https://blog.tartanllama.xyz/optional-expected/[here]. With it the code looks something like this:

----
using MaybeAppData = tl::expected<AppData, std::string>;
MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
	                          	.and_then(create_instance)
	                          	.and_then(create_surface)
	                          	.and_then(get_physical_device)
	                          	.and_then(create_logical_device)};
----
Here `AppData` is a state holder for the application and it's filled with each new procedure call (or not - if error occured in one of previous calls).

===== The goal
So let's start. What should I do? Of course, render a tesselated teapot! I did it before with https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html[DirectX 12], so I already know from which side to approach. It covers a lot of pipeline stages so I have to touch different parts of the API, which is good. It's almost a complete application, not just a triangle or static mesh. This would be our goal:

video::8RCWeKLlVew[youtube, width=640, height=360]

Amazing, isn't it? Sorry for the blurriness - youtube mercilessly fucked up the quality and I don't know how to achieve true HD picture.

Ok, I know I want to see a rotating teapot and the very first thing I need is a data.

===== The data
One of the first https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot[links] in Google offered me a nice teapot dataset. Thought it looks good it requires some processing - if I use it as it is I get:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/teapot_initial_patches.png["teapot_initial_patches", 400]

The initial data describes only a fraction of the teapot and have to be repeated - the body part have to be rotated 3 times and the handle and the spout have to be mirrored. For duplicated objects I just added additional indices - _almost_ copies of corresponding parts. For example, the rim patch is presented by 16 indices (I'm using 16-point patches) - `102, 103, 104, 105, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15` - and represents the quarter of the teapot rim. As you can see only adding copy of indices will not work - I'll end up rendering the same patch in the same place. That's why I have to introduce another vector with patches transformations. Now the original rim patch will be rendered with identity transform, the next one - with 90 deg rotation, the next next one - with 180 deg rotation, and so on. For mirrored parts it's a little bit harder - if I just make a copy of indices and a use a mirror matrix (which basically a scale matrix) - the winding order will chage. On the following picture I tried to visualize a problem.

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/indices_mirror.png["teapot_initial_patches", 321]

Here the right triangle's face points in the positive `x` direction. It's clockwise indices are `1-2-3`. Now if I want the mirrored triangle to face in the negative `x` direction, I can't use `1'-2'-3'` anymore - I need to change the order to `1'-3'-2'` or change the winding order to counter clockwise. That's why I have to tweak indices a bit if I use use a mirror matrix.

In the end I store all the data in `TeapotData.h` file - 28 patches in total. For visualisation I also added a vector with colors. Later in shader with patch id (and I know this id - the runtime kindly provides it) I will sample transforms and colors and apply the changes for corresponding patch.

===== The beginning
The basic code flow is pretty the basic one: `main` creates an instance of `MainApplication` and calls it's method `MainApplication::run()` which starts an infinite loop until I close the window. Here's a `MainApplication` interface:

----
class MainApplication
{
public:
	MainApplication(uint32_t windowWidth, uint32_t windowHeight, std::string const & appName);
	~MainApplication();
	
	void run();
	
private:
	void render();

private:
	AppData _appData{};
};
----

`AppData`, as I already told, is a state holder - it holds all the objects required by the application. Right now it's pretty empty:

----
struct AppData
{
	std::string appName{};
	
	GLFWwindow* window{nullptr};
};
----

`appName` is an application name - an abitrary string, and `window` I create shortly:

----
MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName)
{
	_appData.appName = appName;
	
	GLFWwindow * const window{create_window(windowWidth, windowHeight, appName)};
	
	if (window == nullptr)
		throw runtime_error{"failed to create window"};
	
	_appData.window = window;
	
	glfwSetWindowUserPointer(window, &_appData);
	glfwSetKeyCallback(window, &onKeyPress);
}
----
First I create a window, then set a callback with http://www.glfw.org/docs/latest/group__input.html#ga7e496507126f35ea72f01b2e6ef6d155[`glfwSetKeyCallback`] which listens for `+`, `-` or `space` to change tesselation level or rendering mode. In this callback I need to access the current state of the application (`AppData`) so I pass an instance to `glfw`. For the window creation I use one of many (in the future) free functions - `create_window`:

----
GLFWwindow* create_window(uint32_t const width, uint32_t const height, string const & title)
{
	if (!glfwInit())
		return nullptr;
	
	if (!glfwVulkanSupported())
		return nullptr;
	
	glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
	glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
	
	GLFWwindow * const window{glfwCreateWindow(width, height, title.data(), nullptr, nullptr)};
	
	return window;
}
----
First I initialize `glfw`, next check if Vulkan is supported, next tell `glfw` to http://www.glfw.org/docs/latest/context_guide.html#context_object[not use a context] and create non-resizable windows and finally create a window. In my lessons I'll use  a fixed window - it simplifies the code a bit.

NOTE: All free the functions in the application are _pure_, i.e. they don't change any state and don't have side effects. They always accept arguments by copy or const reference. I store each function in a separate unit (cpp file) and have all declarations in one place (`App.h` file).