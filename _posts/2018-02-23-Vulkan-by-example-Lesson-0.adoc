= Vulkan by example. Lesson 0.
:hp-tags: c++, vulkan

Hi everybody. Today we’ll talk about Vulkan - the modern API for communication with GPU device. There's already some information and tutorials on the web as well as books so why another one. I’ll try to explain - these tutorials out there are great by all means, but personally, for me, they are hard to follow. In this series I’ll try to build a mental picture around the API, I’ll try not to just follow instructions and create some structures because somebody says I need this, but I’ll try to understand why I need this. For that, I’ll use pictures, a lot of them. And if you read https://nikitablack.github.io/2017/03/23/Functional-programming-in-c-by-example.html[one of my previous posts] you know that I’m a fan of functional approach and I’ll use this approach through tutorials. I’ll build every next lesson on top of the previous adding a new stuff, but not modifying it - I found it easier to follow (though sometimes I’ll have to return back and tweak the old code to make it work with the new, but I’ll try to minimize this).

===== Disclaimer
I'm not an expert guru ninja, I'm just learning. And definitely, there will be mistakes in my lessons. I'm kindly asking you to point to them so I can correct it soon. You can do it via comments here, or Reddit, where I'm planning to leave a link, or cpp slack Vulkan channel which I check quite often (and which is very silent, btw).

===== What will not be in tutorials
I assume you know what tesselation is, why there are two related stages in the pipeline (tesselation control and tesselation evaluation), so I'll not explain it in detail. Same goes for curves surfaces - if you need to refresh you memory I recommend http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article]. Also I assume you already have Vulkan SDK installed and have all required variables in the `PATH`.

===== Code organization
I use `CMake` for code building. I run my code on Windows and Linux Mint. On Linux I use `CLion` IDE - it have nice `CMake` integration and `gcc 7`, on Windows - `Visual Studio Community 2017` with `open folder` feature. I use `c++17` a lot.

----
lesson/
├──src/
│   ├──libs/
│   │   ├──eigen/
│   │   │   └──CMakeLists.txt
│   │   ├──glfw-3.2.1/
│   │   │   └──CMakeLists.txt
│   │   └──tl/
│   │       └──CMakeLists.txt
│   └──tesselated_teapot/
│       ├──resources/
│       ├──src/
│       │   ├──app/
│       │   ├──details/
│       │   ├──vk_helpers/
│       │   ├──AppData.h
│       │   ├──Main.cpp
│       │   ├──MainApplication.cpp
│       │   ├──MainApplication.h
│       │   └──TeapotData.h
│       └──CMakeLists.txt
└──CMakeLists.txt
----
This is a typical project structure for each lesson. `resources/` folder holds shader files. All application related files go to `app/` folder, wrappers around Vulkan functions and structs go to `vk_helpers` folder and all other helpers go to `details/`.

I use some libraries in my lessons as well:

- For window creation and management I use http://www.glfw.org/[`glfw`] library - it's simple and crossplatform. It have Vulkan support and simplifies some window related Vulkan parts.
- For math I use http://eigen.tuxfamily.org/index.php[`eigen`] library instead of commonly used `glm` because I'm more familiar with it.
- As you may already know almost each Vulkan function can fail and return some error code. When my function calls such a function it needs to report the result to the main application - in case of success it have to return an object and in case of a failure it have to tell what happened. `std::optional` could be a good candidate for the return object - it can be null or object, but it doesn't say why it is null. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r4.html[`std::expected`] is what I need but it's not a part of the standard. Fortunatelly some smart people wrote an implementation for the current standard. I'm using `tl::expected` implementation from https://blog.tartanllama.xyz/[Simon Brand] (aka TartanLlama), you can read more about it https://blog.tartanllama.xyz/optional-expected/[here]. With it the code looks something like this:

[source,cpp]
----
using MaybeAppData = tl::expected<AppData, std::string>;
MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
	                          	.and_then(create_instance)
	                          	.and_then(create_surface)
	                          	.and_then(get_physical_device)
	                          	.and_then(create_logical_device)};
----
Here `AppData` is a state holder for the application and it's filled with each new procedure call (or not - if error occured in one of previous calls).

===== The goal
So let's start. What should I do? Of course, render a tesselated teapot! I did it before with https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html[DirectX 12], so I already know from which side to approach. It covers a lot of pipeline stages so I have to touch different parts of the API, which is good. It's almost a complete application, not just a triangle or static mesh. This would be our goal:

video::8RCWeKLlVew[youtube, width=640, height=360]

Amazing, isn't it? Sorry for the blurriness - youtube mercilessly fucked up the quality and I don't know how to achieve true HD picture.

Ok, I know I want to see a rotating teapot and the very first thing I need is a data.

===== The data
