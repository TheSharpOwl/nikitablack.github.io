= Vulkan by example. Lesson 0.
:hp-tags: c++, vulkan

Hi everybody. Today we’ll talk about `Vulkan` - the modern API for communication with a GPU device. There're already some information and tutorials on the web as well as books but still it's not enough. Though all these resources out there are great by all means, personally for me, they are hard to follow. Because `Vulkan` is huge - with tons of concepts and nuances (often we need to initialize a structure to initizlize another structure with it. To initialize the third one ¯\\_(ツ)_/¯ ). In this series I’ll try to build a mental picture around the API, I’ll try not to just follow instructions, but I’ll try to understand why I need every bit of code. I hope somebody will find that useful too.

I’ll build every next lesson on top of the previous adding a new stuf, but not modifying it - I found it easier to follow (though sometimes I’ll have to return back and tweak the old code to make it work with the new, but I’ll try to minimize this). And yes, I’ll use pictures, a lot of them.

===== Disclaimer
I'm not an expert guru ninja, I'm just learning. And definitely, there will be mistakes in my lessons. I'm kindly asking you to point to them so I can correct it soon. You can do it via comments here, or https://www.reddit.com/r/vulkan/[Vulkan Reddit], where I'm planning to leave a link, or https://cpplang.slack.com/[cpp slack Vulkan channel] which I check quite often (and which is deadly silent, btw).

===== What will be in tutorials
A teapot of course. Also application will accept an input from the user to increase/decrease tesselation level (i.e. how fine the model is) and switch between wireframe/solid rendering. Wireframe will use `VK_CULL_MODE_NONE` cull mode (because I want to see back faces of triangles in this mode) and solid mode will use `VK_CULL_MODE_BACK_BIT` (despite there're visible holes in a couple of places). In addition to usual vertex and index buffers I'll use uniform buffers for matrices (model, view, projection), storage buffer for patches transforms and colors and push constants for tesselation level.

===== What will not be in tutorials
I assume you know what tesselation is, why there are two related stages in the pipeline (tesselation control and tesselation evaluation), so I'll not explain it in detail. Same goes for curves surfaces - if you need to refresh your memory I recommend http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article]. I'll not explain math behaind projection and other transformation matrices. Also I assume you already have `Vulkan` SDK installed and have all required environment variables set.

===== Code organization
I use `CMake` for code building. I test my code on `Windows 10` and `Linux Mint`. On `Linux` I use `CLion` (it have nice `CMake` integration) with `gcc 7`, on `Windows` - `Visual Studio Community 2017` with `open folder` feature. Also `c++17` is my choice.

----
lesson/
├──src/
│   ├──libs/
│   │   ├──eigen/
│   │   │   └──CMakeLists.txt
│   │   ├──glfw-3.2.1/
│   │   │   └──CMakeLists.txt
│   │   └──tl/
│   │       └──CMakeLists.txt
│   └──tesselated_teapot/
│       ├──resources/
│       ├──src/
│       │   ├──app/
│       │   ├──details/
│       │   ├──vk_helpers/
│       │   ├──AppData.h
│       │   ├──Main.cpp
│       │   ├──MainApplication.cpp
│       │   ├──MainApplication.h
│       │   └──TeapotData.h
│       └──CMakeLists.txt
└──CMakeLists.txt
----
This is a typical project structure for each lesson. `resources/` folder holds shader `glsl` files. All application related files go to `app/` folder, wrappers around `Vulkan` functions and structs go to `vk_helpers` folder and all other helpers go to `details/`.

I use some libraries as well:

- For window creation and management I use http://www.glfw.org/[`glfw`] library - it's simple and crossplatform. It have `Vulkan` support and simplifies some window related `Vulkan` parts.
- For math I use http://eigen.tuxfamily.org/index.php[`eigen`] library instead of commonly used `glm` because I'm more familiar with it.
- As you may already know almost each `Vulkan` function can fail and return some error code. When my procedure calls such a function it needs to report the result to the main application - in case of success return an object and in case of a failure tell what happened. http://en.cppreference.com/w/cpp/utility/optional[`std::optional`] could be a good candidate for the return object - it can be empty or hold object, but it doesn't say why it is empty. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r4.html[`std::expected`] is what I need but it's not a part of the standard. Fortunatelly some smart people wrote an implementation for the current standard. I'm using `tl::expected` implementation from https://blog.tartanllama.xyz/[Simon Brand] (aka TartanLlama), you can read more about it https://blog.tartanllama.xyz/optional-expected/[here]. With it the code will look something like this:
----
using MaybeAppData = tl::expected<AppData, std::string>;
MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
	                          	.and_then(create_instance)
	                          	.and_then(create_surface)
	                          	.and_then(get_physical_device)
	                          	.and_then(create_logical_device)};
----
Here `AppData` is a state holder for the application and it gets filled with each new procedure call (or not - if an error occured in one of the calls).

If you read https://nikitablack.github.io/2017/03/23/Functional-programming-in-c-by-example.html[one of my previous posts] you know that I’m a big fan of functional style and I’ll use this approach through tutorials. So prepare yourself to lots of free function and separate translation units!

===== The goal
So let's begin. I want to logically follow to our goal. But what's my goal? Of course, render a tesselated teapot! I chose it because it covers a lot of pipeline stages so I have to touch a lot of different parts of the API, which is good. I did it before with https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html[DirectX 12], so I already know from which side to come. This would be my goal:

video::8RCWeKLlVew[youtube, width=640, height=360]

Amazing, isn't it? Sorry for the blurriness - youtube mercilessly messed up with quality and I don't know how to achieve true HD picture.

Ok, now I know that I want to a rotating teapot and the very first logical step is to obtain a data.

===== The data
One of the first https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot[links] in Google offered me a nice teapot dataset. Though it looks good it requires some processing - if I use it as it is I'll get:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/teapot_initial_patches.png["teapot_initial_patches", 400]

The initial data describes only a fraction of the teapot and it's parts have to be duplicated - the body parts have to be rotated 3 times and the handle and the spout have to be mirrored. For these duplicated objects I just added additional indices - _almost_ copies of corresponding parts. For example, the rim patch is presented by 16 indices (I'm using 16-point patches) - `102, 103, 104, 105, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15` - and represents the quarter of the teapot rim. So I added the same indices 3 more times to the indices vector. But as you can gues only adding a copy of indices will not work - I'll end up rendering the same patch in the same place. That's why I have to introduce another vector with patches transformations. Now the original rim patch will be rendered with identity transform, the next one - with 90 deg rotation, the next next one - with 180 deg rotation, and the last one with 270 deg rotation to enclose the surface completely. For mirrored parts it's a little bit harder - if I just make a copy of indices and a use a mirror matrix (which basically a scale matrix) - the winding order will chage. On the following picture I tried to visualize a problem:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/indices_mirror.png["teapot_initial_patches", 321]

Here the right triangle's face points in the positive `x` direction. It's clockwise indices are `1-2-3`. Now if I want the mirrored triangle to face in the negative `x` direction, I can't use `1'-2'-3'` anymore - I need to change the order to `1'-3'-2'` (or change the winding order to counter clockwise - but I don't want that, the entire mesh have to be consistent). That's why I have to tweak indices a bit if I use a mirror matrix.

All the data is stored in `TeapotData.h` file - 28 patches in total. For visualisation I also added a vector with colors - one color for the patch. Later in shader with patch id (and I know this id - the runtime kindly provides it) I will sample transforms and colors and apply the changes to the corresponding patch.

===== The beginning
The basic code flow is pretty straightforward: in `main` I create an instance of `MainApplication` and call it's method `MainApplication::run()` which starts an infinite loop until I close the window. Here's a `MainApplication` interface:

----
class MainApplication
{
public:
	MainApplication(uint32_t windowWidth, uint32_t windowHeight, std::string const & appName);
	~MainApplication();
	
	void run();
	
private:
	void render();

private:
	AppData _appData{};
};
----

`AppData`, as I already told, is a state holder - it holds all the objects required by the application. Right now it's pretty empty:

----
struct AppData
{
	std::string appName{};
	
	GLFWwindow* window{nullptr};
};
----

`appName` is an application name - just an information, and `window` is a ... window pointer:

----
MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName)
{
	_appData.appName = appName;
	
	GLFWwindow * const window{create_window(windowWidth, windowHeight, appName)};
	
	if (window == nullptr)
		throw runtime_error{"failed to create window"};
	
	_appData.window = window;
	
	glfwSetWindowUserPointer(window, &_appData);
	glfwSetKeyCallback(window, &onKeyPress);
}
----
In `MainApplication's` constructor I first create a window, then set a callback with http://www.glfw.org/docs/latest/group__input.html#ga7e496507126f35ea72f01b2e6ef6d155[`glfwSetKeyCallback`] which listens for `+`, `-` or `space` keys to change tesselation level or rendering mode. In this callback I need to access the current state of the application (`AppData`) so I pass an instance to `glfw`. For the window creation I use one of many free functions - `create_window`:

----
GLFWwindow* create_window(uint32_t const width, uint32_t const height, string const & title)
{
	if (!glfwInit())
		return nullptr;
	
	if (!glfwVulkanSupported())
		return nullptr;
	
	glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
	glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
	
	GLFWwindow * const window{glfwCreateWindow(width, height, title.data(), nullptr, nullptr)};
	
	return window;
}
----
First I initialize `glfw`, next check if `Vulkan` is supported, next tell `glfw` to http://www.glfw.org/docs/latest/context_guide.html#context_object[not use a context] and create non-resizable windows and finally create a window. In my lessons I use fixed window - it simplifies the code a bit.

NOTE: All free functions in the application are _pure_, i.e. they don't change any state and don't have side effects. They always accept arguments by copy or const reference. I store each function in a separate unit (cpp file) and have all declarations in one place (`App.h` file).

After initializaition `MainApplication::run()` is called which loops until the window is closed:

----
void MainApplication::run()
{
	while (!glfwWindowShouldClose(_appData.window))
	{
		glfwPollEvents();
		render();
	}
}
----
Here in the loop I tell `glfw` to invoke registered callbacks and do rendering (empty in this lesson).

In the end in the `MainApplication` destructor I make a cleaning:

----
MainApplication::~MainApplication()
{
	glfwTerminate();
}
----
For now only the window needs to be destroyed.

===== Conclusion
Wow, the whole post and no any single `Vulkan` related line of code! Sorry, that was a long indroduction and I didn't even start to tell about a lot of things I wanted but I promise the next lesson will be much more interesting.