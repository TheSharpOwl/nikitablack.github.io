= Vulkan by example - Shaders
:hp-tags: c++, vulkan, glsl

In the https://TODO[previous lesson] I made all preparations necessary to start exploring vulkan. Here is the diagramm of the current state of the application:

[picture]

The diagramm is pretty empty now but it will grow as I progress through tutorials. For now it's enough to know that there's a CPU, which controls the application and orchestrates the GPU; a GPU itself, which do magic and produces nice pictures (not necessarily); a window which should show these pictures.

Now the logic question - what's next? I will start from the heart of every graphics application - by my opinion it is shaders, after all this is exactly what GPU runs. In my program I will use 4 shader stages - Vertex, Tesselation Control, Tesselation Eveluation, Fragment. Next I will step over all of these stages briefly explaining the purpose of each.

===== Vertex shader

This is the first stage in the pipeline and it's pretty simple. Looking back to the teapot data I know which information which needs to be passed - since I'm using patches I need to provide points describing them - `16` points for every patch.

----
#version 450

layout(location = 0) in vec3 inPosition;

out gl_PerVertex
{
    vec4 gl_Position;
};

void main()
{
    gl_Position = vec4(inPosition, 1.0);
}
----

A patch point arrives to the shader at location `0` and simply gets passed to the next stage. Thi stage will be executed for every point (vertex) that is provided. Since I use `28` patches `16` point each it will be called at least `28 * 16 = 448` times (it's not an important information - just for fun).

===== Tessellation control shader

----
#version 450

layout(push_constant) uniform TessLevel
{
	float value;
} tessLevel;

layout(vertices = 16) out;

void main()
{
    if (gl_InvocationID == 0)
    {
        gl_TessLevelInner[0] = tessLevel.value;
        gl_TessLevelInner[1] = tessLevel.value;

        gl_TessLevelOuter[0] = tessLevel.value;
        gl_TessLevelOuter[1] = tessLevel.value;
        gl_TessLevelOuter[2] = tessLevel.value;
        gl_TessLevelOuter[3] = tessLevel.value;
    }

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}
----

This shader simple as well as it doesn't do a lot of work, but it have a couple of interesting moments. The first one is how I update a tesselation level (how many details a tesselator should create). I decided to use the so called `Push Constant` - a feature that allows to pass a constant directly in command buffer. Don't affraid of all these terms right now - I'll explain what all this means when I reach the actual code that uses them. For now it's enough to know that the tesselation level is a float variable (to make a subdivision more smooth) that somehow updates from a CPU. Next I tell the GPU that this stage produces 16 control points for the patch, i.e. doesn't change the amount (yes, this stage can generate new points as well as remove some).

===== Tessellation Evaluation shader

This shader is the actual workhorse of the whole application - all the magic happens here.

----
#version 450

layout (quads, fractional_odd_spacing, cw) in;

struct PatchData
{
	mat4 transform;
	vec4 color;
};

layout(binding = 0, row_major) buffer PatchDataBuffer
{
	PatchData data[];
} patchData;

layout(binding = 1) uniform Proj
{
	layout(row_major) mat4 mat;
} proj;

layout(binding = 2) uniform View
{
	layout(row_major) mat4 mat;
} view;

layout(binding = 3) uniform Model
{
	layout(row_major) mat4 mat;
} model;

layout (location = 0) out vec3 outColor;

vec4 bernsteinBasis(float t)
{
	float invT = 1.0f - t;

	return vec4(invT * invT * invT, // (1-t)^3
	            3.0f * t * invT * invT, // 3t(1-t)^2
	            3.0f * t * t * invT, // 3t2(1-t)
	            t * t * t); // t3
}

vec4 evaluateBezier(vec4 basisU, vec4 basisV)
{
	vec4 value = vec4(0.0, 0.0, 0.0, 0.0);

	value = basisV.x * (gl_in[0].gl_Position * basisU.x + gl_in[1].gl_Position * basisU.y + gl_in[2].gl_Position * basisU.z + gl_in[3].gl_Position * basisU.w);
	value += basisV.y * (gl_in[4].gl_Position * basisU.x + gl_in[5].gl_Position * basisU.y + gl_in[6].gl_Position * basisU.z + gl_in[7].gl_Position * basisU.w);
	value += basisV.z * (gl_in[8].gl_Position * basisU.x + gl_in[9].gl_Position * basisU.y + gl_in[10].gl_Position * basisU.z + gl_in[11].gl_Position * basisU.w);
	value += basisV.w * (gl_in[12].gl_Position * basisU.x + gl_in[13].gl_Position * basisU.y + gl_in[14].gl_Position * basisU.z + gl_in[15].gl_Position * basisU.w);
	value.w = 1.0;

	return value;
}

void main(void)
{
	vec4 basisU = bernsteinBasis(gl_TessCoord.x);
	vec4 basisV = bernsteinBasis(gl_TessCoord.y);

	vec4 localPos = evaluateBezier(basisU, basisV);

	gl_Position = localPos * patchData.data[gl_PrimitiveID].transform * model.mat * view.mat * proj.mat;

	outColor = patchData.data[gl_PrimitiveID].color.xyz;
}
----

First I need to specify tesselation rules: domain (`quad`), spacing (`fractional_odd_spacing`) and winding order (`cw` - clockwise). Next I define the patch information in the form of a buffer. Again, no information right now - just know that each patch should be transformed and colored (see https://TODO[introduction lesson] for more details why) and the information incoming as an array of `PatchData`. Also I need usual transformation matrices. I could provide one MVP-matrix and reduce the number of calculations but I want to show how to manipulate with multiple uniform buffers in `Vulkan`. That's why there are three matrices: model, view and projection.

Next is a scary math - calculation of a 3d point having a `gl_TessCoord` that came from tesselator. Actually the math is not that complicated, a found https://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article] very good at explaining the theory behind curves.And the code itself (functions `bernsteinBasis()` and `evaluateBezier()`) I shamelesly took from http://www.gdcvault.com/play/1012740/direct3d[this gdc presentation].

The outputs of this shader are newly generated vertex and color. Since the entire patch colored with a solid color every vertex from one patch will have the same attribute.

I think it's obvious that this shader will be invoked as many times as the number of generated vertices.

===== Fragment shader

----
#version 450

layout(location = 0) out vec4 outColor;

layout(location = 0) in vec3 fragColor;

void main()
{
    outColor = vec4(fragColor, 1.0);
}
----

Another one _"lazy"_ shader - the data is coming at input location `0` and going to the output storage location also `0`. Latter tells that there's should be some special memory region (`Image` in that case) somewhere.

Hurray! The application is almost done! Joking. Once I read the sentense which describes `Vulkan` in a nutshell: _"Show me your triangle in three months."_ The same applies here - I'm planning to write `7` or `8` parts total. Shaders were the easiest part, all other code serves only to make them run and run *correctly*. By correctness I mean that there should not be undefined behavior, data races, pipeline stalls.

===== Finally some Vulkan

So I have some shaders written as text in some files, but I can't use them directly. In `Vulkan` shaders have to be compiled to so called `SPIR-V` binary format and supplied to the API via https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkShaderModule.html[`VkShaderModule`]. I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateShaderModule.html[`vkCreateShaderModule`] function. Here's the definition of this function:

----
VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
----

Last parameter (`pShaderModule`) is a return value I'm interesting in. Third parameter (`pAllocator`) used for custom allocation and *never* will be used in lessons (always `nullptr`). Second parameter (`pCreateInfo`) is an information which describes a shader and can be created right now. But the first parameter (`device`) is an unknown variable.

https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkDevice.html[`VkDevice`] is a software representation of `GPU`. I think about it like an instance of a real physical `GPU` - it is possible to have multiple instances of it (though I will use only one). I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateDevice.html[`vkCreateDevice`] function:

----
VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
----

`pDevice` - return value, `pAllocator` - `nullptr`, `pCreateInfo` - some information, `physicalDevice` - again unknown.

Continuing the analogy https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDevice.html[`VkPhysicalDevice`] is a class or a blueprint. It represents unique piece of hardware and can be used for obtaining some useful info, like capabilities of the `GPU`. I can't create an instance of it, but can ask the API to give it with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumeratePhysicalDevices.html[`vkEnumeratePhysicalDevices`] call:

----
VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
----

It will never end... Here again I see an unknown variable `instance`. Moreover, this function can return a list of *all* available devices in the system but I'm interested only in one. For the application I need a GPU that supports tesselation and can output images to the operating system's present engine. Yes, it sounds weird but it looks like there are devices that can't render. In order to check device's _"presentability"_ I need some information about render surface. In `Vulkan` this information stored in http://vulkan-spec-chunked.ahcox.com/ch29s02.html[`VkSurfaceKHR`] object and I need to get this object. Fortunately with `GLFW` library this is an easy task:

----
VkResult glfwCreateWindowSurface(
    VkInstance instance,
    GLFWwindow * window,
    const VkAllocationCallbacks * allocator,
    VkSurfaceKHR * surface 
)
----

Again https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstance.html[`VkInstance`] It is an entity that keeps the state of the application and is used almost in every `Vulkan` function. I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html[`vkCreateInstance`] function:

----
VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
----

Previously I wrote that `GLFW` library helps with creation of a surface. But this surface thing is special. `VkSurfaceKHR` - this `KHR` ending means that this object is not a part of a _standard_ vulkan, but object which can be obtained through *extensions*. Indeed, presentation is so OS specific that it's very hard to make it as a part of a standard. Or there could be some vendor specific extensions that adds some new functionality. There are instance-level extensions and device-level extensions. For the surface I need to include instance-level extensions. Extensions are just string and I specify them like this:

----
_appData.instanceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
_appData.deviceExtensions.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
----

Finally I'm at the leaf node, no more unknown variables! And I already forgot why do I need all this... Ah, I wanted to create `Shader Modules`.

To summarize: here's the dependency chain:

----
VkShaderModule 🡢 VkDevice 🡢 VkPhysicalDevice 🡢 VkSurfaceKHR 🡢 VkInstance 🡢 extensions
----

And here's how this chain managed in the code:

----
// MainApplication.cpp
MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName)
{
	GLFWwindow * const window{create_window(windowWidth, windowHeight, appName)};
	
	if (window == nullptr)
		throw runtime_error{"failed to create window"};
	
	_appData.window = window;
	
	glfwSetWindowUserPointer(window, &_appData);
	glfwSetKeyCallback(window, &onKeyPress);
	
    // new code start
	MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
	                          .and_then(create_instance)
	                          .and_then(create_surface)
	                          .and_then(get_physical_device)
	                          .and_then(create_logical_device)
	                          .and_then(create_shader_modules)};
	
	if (!maybeAppData)
		throw runtime_error{maybeAppData.error()};
	
	_appData = *maybeAppData;
    // new code end
}
----

Here `MaybeAppData` is an alias to `tl::expected` (a library as a replacement for non-existent yet `std::expected`, see the https://TODO[previous article]) - it can hold an an `AppData` object or be empty, hence the suffix `maybe`.

----
using MaybeAppData = tl::expected<AppData, std::string>;
----

Just look how beautiful the code is. If the first call fails all other calls will not be executed and `expected` object will hold an error instead of valid value. By this error I can find the fail reason. Each function in the chain is a standalone pure function in separate unit - that's how I'm trying to fight the verbosity of a `Vulkan` application (the number of lines easile gets more that 1000 even in simple triangle application). Now I'm going to visit each function trying to explain what it does.

===== Getting required extensions

This one is simple because `GLFW` library helps:

----
AppData get_required_window_extensions(AppData appData)
{
	uint32_t glfwExtensionCount{0};
	char const * const * const glfwExtensions{glfwGetRequiredInstanceExtensions(&glfwExtensionCount)};

	for (uint32_t i{0}; i < glfwExtensionCount; ++i)
		appData.instanceExtensions.push_back(glfwExtensions[i]);
	
	return appData;
}
----

http://www.glfw.org/docs/latest/group__vulkan.html#ga1abcbe61033958f22f63ef82008874b1[`glfwGetRequiredInstanceExtensions`] returns a list of extesion name required for surface creation. I pass this list to a `VkInstance` creation function.

NOTE: I could pass a const reference to `AppData` to avoid copying, but since I need a copy anyway to need to modify the state I just let the runtime to do one.

===== Creating an instance

Having required instance extensions names I can create an instance.

----
MaybeAppData create_instance(AppData appData)
{
	VkInstanceCreateInfo const createInfo{get_instance_create_info(&appData.instanceExtensions, &appData.layers)};
	
	if (vkCreateInstance(&createInfo, nullptr, &appData.instance) != VK_SUCCESS)
		return make_unexpected("failed to create instance");
	
	return appData;
}
----

If call to  https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html[`vkCreateInstance`] was successful I return modified `AppData` object wrapped by `expected` object. In opposite case `tl::expected` object will hold an error instead of a valid data.

All objects in `Vulkan` are created by providing information through corrsponding structures. For an instance this structure is https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html[`VkInstanceCreateInfo`]. I isolated all structure creations in `VkStructHelpers.h` and `VkStructHelpers.cpp` files.

NOTE: It's possible to use https://github.com/KhronosGroup/Vulkan-Hpp[Vulkan-Hpp] `c++` wrapper by `Khronos`, but I decided to go low-level in this lessons.

----
VkInstanceCreateInfo get_instance_create_info(vector<char const *> const * const extensions,
	                                      vector<char const *> const * const layers)
{
	VkInstanceCreateInfo info{};
	info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; // #1
	info.pNext = nullptr; // #2
	info.flags = 0; // #3
	info.pApplicationInfo = nullptr; // #4
	info.enabledLayerCount = (layers != nullptr) ? static_cast<uint32_t>(layers->size()) : 0;
	info.ppEnabledLayerNames = (layers != nullptr) ? layers->data() : nullptr; // #5
	info.enabledExtensionCount = (extensions != nullptr) ? static_cast<uint32_t>(extensions->size()) : 0;
	info.ppEnabledExtensionNames = (extensions != nullptr) ? extensions->data() : nullptr; // #6
		
	return info;
}
----

. Every structure in `Vulkan` have a corresponding name. For `VkInstanceCreateInfo` it is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`, for other types - other names. I will not mention this anymore for new structures.

. Some information objects can be extended by providing another structure in `pNext` member. For example, information for device memory creation can be extended with additional data that marks memory as shared. This application will not use that feature so I will not mention it anymore.

. This structure doesn't use any flags. In future I will only describe `flags` field only if it have value.

. This structure can provide information about application to the driver with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkApplicationInfo.html[`VkApplicationInfo`] struct. Since it's only informatical I left it null.

. Layers are used for debugging. In this lesson it's too early for debugging and `layers` vector is empty. Notice how arrays are passed to `Vulkan` - there's no `std::vector` or other similar data structures - only raw pointers. And every array accompanied with it's size.

. Here I provide extension I got from `GLFW` window.