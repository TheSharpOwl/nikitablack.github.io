= Generic C++ delegates
:hp-tags: c++

I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that case we can create dependencies - for example, a pointer to member function in C++ looks like this:

[source,cpp]
----
int(SomeClass::*ptr)(float);
----

Here `ptr` is an actual pointer and `SomeClass` is the name of the class - owner of this function. As you can imagine, if some class needs to accept a function pointer to another class, then using raw function pointers creates a coupling between them. We can use global or static functions - in that case we don't need to specify a class name (because there's no one). But using this types of functions will complicate the code.

The problem can be solved if instead of passing function pointers we'll pass some generic wrapper - a delegate. Later this wrapper can be called and a call will be delegated to the actual function which delegate wraps. Sounds easy, right? And it is easy and there many many solutions. My favorite are http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates[The Impossibly Fast Delegates], https://blog.molecular-matters.com/2011/09/19/generic-type-safe-delegates-and-events-in-c[Generic, type-safe delegates] and http://blog.coldflake.com/posts/C++-delegates-on-steroids/[Delegates On Steroids]. And basically my implementation is a mix of aforementioned code with small additions. So, let's start.

First, let's found how can we pass a function and call it later. One way is to pass a function pointer as a function argument, store this pointer and call it later. In my example I'm not storing it but call immidiatelly:

[source,cpp]
----
int foo(int(*funcPtr)(int))
{
  return funcPtr(10);
}

int test(int a)
{
  return a;
}

foo(&test);
----

Another option is to pass function pointer as http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter[non-type template parameter]. In this case we don't need to keep a pointer - the whole function was created around specified pointer:

[source,cpp]
----
template<int(*FuncPtr)(int)>
int foo()
{
  return FuncPtr(10);
}

int test(int a)
{
  return a;
}

foo<&test>();
----

But which us better. What to choose? Of cource there's no answer. It depends. If you don't know before which function we need to use as a callback, then passing a function ponter as a function argument is the only option. But if we know, then passing it as template argument can be a good choice. Consider this example:

[source,cpp]
----
int call1(int(*funcPtr)(int))
{
  return funcPtr(10);
}

template<int(*F)(int)>
int call2()
{
  return (F)(10);
}

int test(int a)
{
  return a;
}

int main()
{
  int i{0};
  
  i += test(5);
  i += call1(&test);
  i += call2<&test>();
  
  return i;
}
----

I used https://gcc.godbolt.org/[https://gcc.godbolt.org/] to compile it. Thought it's hard to get correct output - compilers are damn smart and produces optimized code - with *gcc* compiler and *O1* optimization I got the following assembly output.






[source,cpp]
----
#include <iostream>
#include <functional>

using namespace std;

template<typename T>
class Delegate;

template<typename Ret, typename ...Args>
class Delegate<Ret(Args...)>
{
	using CallerType = Ret(*)(void*, Args&&...);

public:
	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Delegate create(T* obj)
	{
		cout << "create member" << endl;
		return Delegate{ obj, &memberCaller<T, funcPtr> };
	}

	template<Ret(*funcPtr)(Args...)>
	static Delegate create()
	{
		cout << "create global" << endl;
		return Delegate{ nullptr, &globalCaller<funcPtr> };
	}

	template<typename T,
		//typename = typename enable_if<is_same<Ret, typename result_of<remove_pointer<T>::type(Args&&...)>::type>::value>::type,
		typename = typename enable_if<is_pointer<T>::value>::type>
	static Delegate create(T&& t)
	{
		cout << "create functor" <<  endl;
		return Delegate{ t, &functorCaller<T> };
	}
	
	Ret operator()(Args&&... args)
	{
		return callback(callee, forward<Args>(args)...);
	}
    
    bool operator==(const Delegate& other)
	{
		return callee == other.callee && callback == other.callback;
	}

private:
	void* callee{ nullptr };
	CallerType callback{ nullptr };

private:
	Delegate(void* obj, CallerType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Ret memberCaller(void* callee, Args&&... args)
	{
		return (static_cast<T*>(callee)->*funcPtr)(forward<Args>(args)...);
	}

	template<Ret(*funcPtr)(Args...)>
	static Ret globalCaller(void* callee, Args&&... args)
	{
		(void)callee;
		return funcPtr(forward<Args>(args)...);
	}

	template<typename T>
	static Ret functorCaller(void* functor, Args&&... args)
	{
		return (*static_cast<T>(functor))(forward<Args>(args)...);
	}
};

int global(int a, float b)
{
	cout << "in global" << endl;
	return a + static_cast<int>(b);
}

struct Functor
{
	int operator()(int a, float b)
	{
		cout << "in functor" << endl;
		return a + static_cast<int>(b);
	}
};

struct UserStruct
{
	int member(int a, float b)
	{
		cout << "in member" << endl;
		return a + static_cast<int>(b);
	}

	static int staticMember(int a, float b)
	{
		cout << "in static" << endl;
		return a + static_cast<int>(b);
	}
};

int main()
{
	{
		cout << "lambda test" << endl;

		auto lambda = [](int a, float b)->int
		{
			cout << "in lambda" << endl;
			return a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambda) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "lambda with capture test" << endl;

		int toCapture{ 42 };
		auto lambdaWithCapture = [toCapture](int a, float b)->int
		{
			cout << "in lambda with capture" << endl;
			return toCapture + a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambdaWithCapture) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "global test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&global>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "functor test" << endl;

		Functor functor;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&functor) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "member test" << endl;

		UserStruct us;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<UserStruct, &UserStruct::member>(&us) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// user struct static member test
	{
		cout << "static test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&UserStruct::staticMember>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// function
	{
		cout << "std::funciton test" << endl;

		function<int(int, float)> f{ &global };

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&f) };
		cout << d(10, 5.0f) << endl;

		cout << endl;

	}

	cin.get();

	return 0;
}
----