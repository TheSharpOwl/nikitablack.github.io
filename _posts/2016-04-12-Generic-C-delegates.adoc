= Generic C++ delegates
:hp-tags: c++

I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that case we can create dependencies - for example, a pointer to member function in C++ looks like this:

[source,cpp]
----
int(SomeClass::*ptr)(float);
----

Here `ptr` is an actual pointer and `SomeClass` is the name of the class - owner of this function. As you can imagine, if some class needs to accept a function pointer to another class, then using raw function pointers creates a coupling between them. We can use global or static functions - in that case we don't need to specify a class name (because there's no one). But using this types of functions will complicate the code.

The problem can be solved if instead of passing function pointers we'll pass some generic wrapper - a delegate. Later this wrapper can be called and a call will be delegated to the actual function which delegate wraps. Sounds easy, right? And it is easy and there many many solutions. My favorite are http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates[The Impossibly Fast Delegates], https://blog.molecular-matters.com/2011/09/19/generic-type-safe-delegates-and-events-in-c[Generic, type-safe delegates] and http://blog.coldflake.com/posts/C++-delegates-on-steroids/[Delegates On Steroids]. And basically my implementation is a mix of aforementioned code with small additions. So, let's start.

[source,cpp]
----
#include <iostream>
#include <functional>

using namespace std;

template<typename T>
class Delegate;

template<typename Ret, typename ...Args>
class Delegate<Ret(Args...)>
{
	using CallerType = Ret(*)(void*, Args&&...);

public:
	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Delegate create(T* obj)
	{
		cout << "create member" << endl;
		return Delegate{ obj, &memberCaller<T, funcPtr> };
	}

	template<Ret(*funcPtr)(Args...)>
	static Delegate create()
	{
		cout << "create global" << endl;
		return Delegate{ nullptr, &globalCaller<funcPtr> };
	}

	template<typename T,
		//typename = typename enable_if<is_same<Ret, typename result_of<remove_pointer<T>::type(Args&&...)>::type>::value>::type,
		typename = typename enable_if<is_pointer<T>::value>::type>
	static Delegate create(T&& t)
	{
		cout << "create functor" <<  endl;
		return Delegate{ t, &functorCaller<T> };
	}
	
	Ret operator()(Args&&... args)
	{
		return callback(callee, forward<Args>(args)...);
	}
    
    bool operator==(const Delegate& other)
	{
		return callee == other.callee && callback == other.callback;
	}

private:
	void* callee{ nullptr };
	CallerType callback{ nullptr };

private:
	Delegate(void* obj, CallerType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Ret memberCaller(void* callee, Args&&... args)
	{
		return (static_cast<T*>(callee)->*funcPtr)(forward<Args>(args)...);
	}

	template<Ret(*funcPtr)(Args...)>
	static Ret globalCaller(void* callee, Args&&... args)
	{
		(void)callee;
		return funcPtr(forward<Args>(args)...);
	}

	template<typename T>
	static Ret functorCaller(void* functor, Args&&... args)
	{
		return (*static_cast<T>(functor))(forward<Args>(args)...);
	}
};

int global(int a, float b)
{
	cout << "in global" << endl;
	return a + static_cast<int>(b);
}

struct Functor
{
	int operator()(int a, float b)
	{
		cout << "in functor" << endl;
		return a + static_cast<int>(b);
	}
};

struct UserStruct
{
	int member(int a, float b)
	{
		cout << "in member" << endl;
		return a + static_cast<int>(b);
	}

	static int staticMember(int a, float b)
	{
		cout << "in static" << endl;
		return a + static_cast<int>(b);
	}
};

int main()
{
	{
		cout << "lambda test" << endl;

		auto lambda = [](int a, float b)->int
		{
			cout << "in lambda" << endl;
			return a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambda) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "lambda with capture test" << endl;

		int toCapture{ 42 };
		auto lambdaWithCapture = [toCapture](int a, float b)->int
		{
			cout << "in lambda with capture" << endl;
			return toCapture + a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambdaWithCapture) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "global test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&global>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "functor test" << endl;

		Functor functor;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&functor) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "member test" << endl;

		UserStruct us;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<UserStruct, &UserStruct::member>(&us) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// user struct static member test
	{
		cout << "static test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&UserStruct::staticMember>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// function
	{
		cout << "std::funciton test" << endl;

		function<int(int, float)> f{ &global };

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&f) };
		cout << d(10, 5.0f) << endl;

		cout << endl;

	}

	cin.get();

	return 0;
}
----