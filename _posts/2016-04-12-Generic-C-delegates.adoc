= Generic C++ delegates
:hp-tags: c++

I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that case we can create dependencies - for example, a pointer to member function in C++ looks like this:

[source,cpp]
----
int(SomeClass::*ptr)(float);
----

Here `ptr` is an actual pointer and `SomeClass` is the name of the class - owner of this function. As you can imagine, if some class needs to accept a function pointer to another class, then using raw function pointers creates a coupling between them. We can use global or static functions - in that case we don't need to specify a class name (because there's no one). But using this types of functions will complicate the code.

The problem can be solved if instead of passing function pointers we'll pass some generic wrapper - a delegate. Later this wrapper can be called and a call will be delegated to the actual function which delegate wraps. Sounds easy, right? And it is easy and there many many solutions. My favorite are http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates[The Impossibly Fast Delegates], https://blog.molecular-matters.com/2011/09/19/generic-type-safe-delegates-and-events-in-c[Generic, type-safe delegates] and http://blog.coldflake.com/posts/C++-delegates-on-steroids/[Delegates On Steroids]. And basically my implementation is a mix of aforementioned code with small additions. So, let's start.

First, let's found how can we pass a function and call it later. One way is to pass a function pointer as a function argument, store this pointer and call it later. In my example I'm not storing it but call immidiatelly:

[source,cpp]
----
int foo(int(*funcPtr)(int))
{
  return funcPtr(10);
}

int test(int a)
{
  return a;
}

foo(&test);
----

Another option is to pass function pointer as http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter[non-type template parameter]. In this case we don't need to keep a pointer - the whole function was created around specified pointer:

[source,cpp]
----
template<int(*FuncPtr)(int)>
int foo()
{
  return FuncPtr(10);
}

int test(int a)
{
  return a;
}

foo<&test>();
----

But which us better. What to choose? Of cource there's no answer. It depends. If you don't know before which function we need to use as a callback, then passing a function ponter as a function argument is the only option. But if we know, then passing it as template argument can be a good choice. Consider this example:

[source,cpp]
----
int call1(int(*funcPtr)(int))
{
  return funcPtr(10);
}

template<int(*F)(int)>
int call2()
{
  return (F)(10);
}

int test(int a)
{
  return a;
}

int main()
{
  int i{0};
  
  i += test(5);
  i += call1(&test);
  i += call2<&test>();
  
  return i;
}
----

I used https://gcc.godbolt.org/[https://gcc.godbolt.org/] to compile it. Thought it's hard to get correct output - compilers are damn smart and produces optimized code - with *gcc* compiler and *O1* optimization I got the following assembly output.

[source,cpp]
test(int):
        mov     eax, edi
        ret
call1(int (*)(int)):
        sub     rsp, 8
        mov     rax, rdi
        mov     edi, 10
        call    rax
        add     rsp, 8
        ret
main:
        sub     rsp, 8
        mov     edi, OFFSET FLAT:test(int)
        call    call1(int (*)(int))
        add     eax, 15
        add     rsp, 8
        ret
        sub     rsp, 8
        mov     edi, OFFSET FLAT:std::__ioinit
        call    std::ios_base::Init::Init()
        mov     edx, OFFSET FLAT:__dso_handle
        mov     esi, OFFSET FLAT:std::__ioinit
        mov     edi, OFFSET FLAT:std::ios_base::Init::~Init()
        call    __cxa_atexit
        add     rsp, 8
        ret
----

You don't need to know an assembly to find the interesting thing - the call to `call2()` was completely optimized out. And the only call here is a call to `call1()` function which calls the supplied callback. In other words - using the template wrapper will be replaced by the compiler to the actual callback invokation (here it also optimized out)! It's hard to tell will the compiler optimize the same way in real big project but at least it gives some sort of hope that it will.

Knowing this we can start to implement our delegate. In c++ we have a bunch of callable objects and we can split them in three categories:

* global functions - the functions declared globally and static functions. This pointers which we will pass directly to our delegate. For example `&globalFunction` will return the address of a function (`&` is optional). And we can be sure we will not have problems, because this functions always exist during program lifetime.

* member functions - the members of class or struct. The pointer to this function should be called on valid object but it's developer's  responsibility to keep an object alive. The member function pointer can be written, for example, `int(SomeObj::*funcPtr)(int)` and called `obj->*funcPtr(42)`.

* different callable objects that are not fitting to previous categories. This can be functors, lambdas, std::function objects. Thought lambda can be casted to function pointer and treated as global function this pointer can't be used as template argument. Moreover, only lambdas without capture can be casted. This is why I put lambdas in this category.

All that means that we should manage 3 cases in our code. So let's do it.

[source,cpp]
----
template<typename T>
class Delegate;

template<typename Ret, typename ...Args>
class Delegate<Ret(Args...)>
{
	using CallbackType = Ret(*)(void*, Args&&...);
    
public:
	Ret operator()(Args&&... args)
	{
		return callback(callee, forward<Args>(args)...);
	}
    
    bool operator==(const Delegate& other)
	{
		return callee == other.callee && callback == other.callback;
	}
    
private:
	void* callee{ nullptr };
	CallbackType callback{ nullptr };
    
private:
	Delegate(void* obj, CallbackType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}
}
----

Here we created an incomplete base template class and a specialization. This is simply a cosmetic stuff - I like more `Delegate<int(int, float)>` signature than `Delegate<int, int, float>`. Next we declared a callback type `Ret(\*)(void*, Args&&...)` - the function that accepts arguments that should be forwarded to supplied callback and an object - the `callee` that we'll use to call supplied callback on. This `callee` will be a pointer to class/struct instance or a pointer to a lambda/functor and null for global/static functions. Let `void*` type scare you not - it will be casted to correct type in elegant manner. Also there're a private constructor, comparison operator and a call operator, so our delegate can be called as a functor or even be passed to another delegate! Next we'll start to add some real functionality. The simplest case is a static/global function case:

[source,cpp]
----
public:
	template<Ret(*funcPtr)(Args...)>
	static Delegate create()
	{
		return Delegate{ nullptr, &globalCaller<funcPtr> }; // nullptr as first parameter because static/global functions can be called directly
	}
    
private:
	template<Ret(*funcPtr)(Args...)>
	static Ret globalCaller(void*, Args&&... args)
	{
		return funcPtr(forward<Args>(args)...);
	}
----

Nothing really complicated here - we just defined a static `create` function (which calls the private constructor) and a wrapper for the callback.  



[source,cpp]
----
template<typename T>
class Delegate;

template<typename Ret, typename ...Args>
class Delegate<Ret(Args...)>
{
	using CallerType = Ret(*)(void*, Args&&...);

public:
	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Delegate create(T* obj)
	{
		cout << "create member" << endl;
		return Delegate{ obj, &memberCaller<T, funcPtr> };
	}

	template<Ret(*funcPtr)(Args...)>
	static Delegate create()
	{
		cout << "create global" << endl;
		return Delegate{ nullptr, &globalCaller<funcPtr> };
	}

	template<typename T,
		//typename = typename enable_if<is_same<Ret, typename result_of<remove_pointer<T>::type(Args&&...)>::type>::value>::type,
		typename = typename enable_if<is_pointer<T>::value>::type>
	static Delegate create(T&& t)
	{
		cout << "create functor" <<  endl;
		return Delegate{ t, &functorCaller<T> };
	}
	
	Ret operator()(Args&&... args)
	{
		return callback(callee, forward<Args>(args)...);
	}
    
    bool operator==(const Delegate& other)
	{
		return callee == other.callee && callback == other.callback;
	}

private:
	void* callee{ nullptr };
	CallerType callback{ nullptr };

private:
	Delegate(void* obj, CallerType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Ret memberCaller(void* callee, Args&&... args)
	{
		return (static_cast<T*>(callee)->*funcPtr)(forward<Args>(args)...);
	}

	template<Ret(*funcPtr)(Args...)>
	static Ret globalCaller(void* callee, Args&&... args)
	{
		(void)callee;
		return funcPtr(forward<Args>(args)...);
	}

	template<typename T>
	static Ret functorCaller(void* functor, Args&&... args)
	{
		return (*static_cast<T>(functor))(forward<Args>(args)...);
	}
};

int global(int a, float b)
{
	cout << "in global" << endl;
	return a + static_cast<int>(b);
}

struct Functor
{
	int operator()(int a, float b)
	{
		cout << "in functor" << endl;
		return a + static_cast<int>(b);
	}
};

struct UserStruct
{
	int member(int a, float b)
	{
		cout << "in member" << endl;
		return a + static_cast<int>(b);
	}

	static int staticMember(int a, float b)
	{
		cout << "in static" << endl;
		return a + static_cast<int>(b);
	}
};

int main()
{
	{
		cout << "lambda test" << endl;

		auto lambda = [](int a, float b)->int
		{
			cout << "in lambda" << endl;
			return a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambda) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "lambda with capture test" << endl;

		int toCapture{ 42 };
		auto lambdaWithCapture = [toCapture](int a, float b)->int
		{
			cout << "in lambda with capture" << endl;
			return toCapture + a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambdaWithCapture) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "global test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&global>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "functor test" << endl;

		Functor functor;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&functor) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "member test" << endl;

		UserStruct us;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<UserStruct, &UserStruct::member>(&us) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// user struct static member test
	{
		cout << "static test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&UserStruct::staticMember>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// function
	{
		cout << "std::funciton test" << endl;

		function<int(int, float)> f{ &global };

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&f) };
		cout << d(10, 5.0f) << endl;

		cout << endl;

	}

	cin.get();

	return 0;
}
----