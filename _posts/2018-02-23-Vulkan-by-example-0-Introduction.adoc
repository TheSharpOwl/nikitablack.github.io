= Vulkan by example 0 - Introduction
:hp-tags: c++, vulkan

Hi everybody. Today I'd like talk about `Vulkan` - the modern API for communication with a GPU device. Though there're already some information and tutorials on the web as well as books I want to try to write about the API for several reasons:

- I don't want this series to be a general, about the broad application of the API. Instead, I want to focus on a single purpose application, more or less _advanced_, *not* a triangle.
- I want to understand `Vulkan` better. And, as you know, trying to explain things helps to understend them better.

I recommend to start my tutorials after you finished https://vulkan-tutorial.com/[vulkan tutorial] and https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-preface[API without Secrets]. These resources greatly explain the API usage and after reading them you should have a solid understanding what `Vulkan` is. I'll try to continue to build a mental picture around the API, to understand why and when do we need every bit of code, every structure. I’ll build every next lesson on top of the previous by *adding* a new stuf, but without modifying it - I found it easier to follow. Though this rule is not strict and sometimes I’ll have to return back and change the old code, but I’ll try to minimize it. And yes, I’ll use pictures, a lot of them.

===== Disclaimer
I'm not an expert guru ninja, I'm just learning. And definitely, there will be mistakes in my lessons. I'm kindly asking you to point to them so I can fix them soon. You can use comments on twitter, where I'm planning to leave links to the articles, or https://khronosdevs.slack.com/[cpp slack Vulkan channel] which I check quite often.

===== The goal
This is our goal:

video::8RCWeKLlVew[youtube, width=640, height=360]

The rotating teapot! Amazing, isn't it? Sorry for the blurriness - youtube mercilessly messed up with quality and I don't know how to fix it. As you can see, the application uses tesselation to change the geometry detail. It can be renderer in solid or wireframe mode. I chose it because it covers a lot of pipeline stages so I have to touch a great number of different parts of the API, which is good. I did it before with https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html[DirectX 12], so I already have some ideas how to start.

===== What will not be in tutorials
In addition to general graphics consepts I assume you know what tesselation is, why there are two related stages in the pipeline (tesselation control and tesselation evaluation), so I'll not explain it in detail. Same goes for curves surfaces - if you need to refresh your memory I recommend http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article]. I'll not explain math behaind projection and other transformation matrices. Also I assume you already have `Vulkan` SDK installed, have all required environment variables set and know how to use CMake.

===== Code organization
We'll use `CMake` as a building tool. I test my code on `Windows 10` and `Linux Mint`. On `Linux` I use `CLion` (it have nice `CMake` integration) with `gcc`, on `Windows` - `Visual Studio Community 2017` which supports `CMake` as well. Also `c++17` is my choice.

----
lesson/
├──src/
│   ├──teapot/
│   │   ├──resources/
│   │   ├──src/
│   │   │   ├──vulkan/
│   │   │   │  ├──helpers/
│   │   │   │  │   └──...
│   │   │   │  └──...
│   │   │   ├──window/
│   │   │   │  └──...
│   │   │   ├──AppData.h
│   │   │   ├──Global.h
│   │   │   ├──main.cpp
│   │   │   └──TeapotData.h
│   │   └──CMakeLists.txt
│   └──third_party/
│       ├──eigen/
│       │   └──CMakeLists.txt
│       ├──glfw-3.2.1/
│       │   └──CMakeLists.txt
│       └──tl/
│           └──CMakeLists.txt
└──CMakeLists.txt
----
This is a typical project structure for each lesson. `resources/` folder holds shader files. I chose `glsl` as a shading language, though `Vulkan` does not require it. The geometry data is stored in `TeapotData` structure. Also, there're some global variables - I'm not a big fan of it, but some libraries force to use them. And yes, I use some libraries:

- For window creation and management I use http://www.glfw.org/[`glfw`] library - it's simple and crossplatform. It have `Vulkan` support and simplifies some window related `Vulkan` parts.
- For math I use http://eigen.tuxfamily.org/index.php[`eigen`] library instead of commonly used `glm` because I'm more familiar with it.
- As you may already know almost each `Vulkan` function can fail and return some error code. When my procedure calls such a function it needs to report the result to the application - in case of success it should return an object and in case of a failure it should tell what happened. http://en.cppreference.com/w/cpp/utility/optional[`std::optional`] could be a good candidate for the return object - it can be empty or hold object, but it doesn't say why it is empty. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r4.html[`std::expected`] is what I need but it's not a part of the standard yet. Fortunatelly some smart people wrote an implementation for the current standard. I'm using `tl::expected` implementation from https://blog.tartanllama.xyz/[Simon Brand] (aka TartanLlama), you can read more about it https://blog.tartanllama.xyz/optional-expected/[here]. With it the code will look something like this:

----
// "mb" in mbAppData stands for "maybe"
auto mbAppData{get_required_window_extensions(std::move(_appData))
	           .and_then(create_instance)
	           .and_then(create_surface)
	           .and_then(get_physical_device)
	           .and_then(create_logical_device)};
----

Where each function have a similar signature, something like this:

----
MaybeAppDataPtr create_window(AppDataPtr appData) noexcept;
----

All created vulkan objects are stored in a big struct of the `AppData` type. Many functions update the structure with new objects. `AppDataPtr` is an alias to `unique_ptr<AppData>`. `MaybeAppDataPtr` is an alias to `expected<AppDataPtr, AppDataError>`, where `AppDataError` is an error type. The object of this type will be returned if the function need to report about an error. `AppDataError` declared as:

----
struct AppDataError
{
    std::string message{};
    AppDataPtr appData{};
};
----

Next I'll try to explain why the error have `appData` and why it is a `unique_ptr`.

If you read https://nikitablack.github.io/2017/03/23/Functional-programming-in-c-by-example.html[one of my previous posts] you know that I’m a big fan of a functional style' and I'll use this approach through tutorials, so be prepared for tons of free functions and lack of classes! So why not to pass a data as a reference or a pointer? The reason is that a free function have to be _pure_, have to be safe to call from different threads. If we pass the same object by reference we need to use some sort of synchronization to avoid potential data races, because in the function we don't know who uses the data outside. And we want to avoid syncronization, because it is expensive and complicates things. It is possible to pass the data by copy, making every function _pure_, but since this struct can be lenghty I decided to use a unique pointer. So if we have an agreement that all functions accept a `unique_ptr` as a parameter, we can guarantee that the application is thread safe, since the `unique_ptr` can't be in two different places (threads) at the same time. Let's see how this works step by step:

- First the data is passed to a function by moving it, since unique pointer can't be copied. At this point the calling procedure does not own the data any more.
- In the function, if everything is went well, some fields of data gets updated and the entire struct returns back in an instance of `expected` type by moving it to that instance. After the function returns the callee can get the data back.
- If something went wrong, the object of type `AppDataError` is created with a message, explaining the fail reason. Since the data at this point _can_ hold some state (from previous calls, for example), it needs to be returned back, because the outer code may use that state (for clearing, for example). After the function returns the callee knows the fail reason by reading the error and owns the data again.

Though in the tutorials I'll use only one thread, I'd like to follow this code organization anyway, because I got used to it, it is simple and readable, by my opinion.

I rewrote the tutorials multiple times trying to find the best style. In the end I came to conclusion that I don't want to copy the code to the article, but leave a link to a file on `Github` - this saves a lot of space and does not reuire to update the article in case the code changes. If you find this not very comfortable to read b̶u̶y̶ ̶a̶ ̶s̶e̶c̶o̶n̶d̶ ̶m̶o̶n̶i̶t̶o̶r̶ tell me and we'll try to come up with something to solve the problem.

===== The data
One of the first https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot[links] in Google offers us a nice teapot dataset. Though it looks good it requires some processing - if we use it as it is we'll not get a complete model:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/teapot_initial_patches.png["teapot_initial_patches", 400]

The initial data describes only a fraction of the teapot so some parts have to be duplicated - the body part have to be rendered with rotation and the handle and the spout have to be mirrored to get a closed form. This can be achieved in multiple ways - with instansing, with data duplication etc. But I chose to keep the points but add additional indices - _almost_ copies of corresponding parts. For example, the rim patch is presented by 16 indices (the dataset uses 16-point patches) - `102, 10, 104, 105, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15` - and represents the quarter of the teapot rim. So I added the same indices 3 more times to the indices vector. But as you can gues just adding an indices copy will not work - I'll end up rendering the same patch in the same place. That's why I have to introduce another vector with patch transformations. Now the original rim patch will be rendered with identity transform, the next one - with 90 degrees rotation, the next next one - with 180 degrees rotation, and the last one with 270 degrees rotation to enclose the surface completely. For mirrored parts it's a little bit trickier - if I just make a copy of indices and a use a mirror matrix (which is a scale matrix) - the winding order will chage. On the following picture I tried to visualize a problem:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/indices_mirror.png["teapot_initial_patches", 321]

Here the right triangle's face points in the positive `x` direction. Clockwise indices are `1-2-3`. Now if I want the mirrored triangle to _face_ the negative `x` direction, I can't use `1'-2'-3'` anymore - I need to change the order to `1'-3'-2'` (or change the winding order to counter clockwise - but I don't want to do that because that requires pipeline change). That's why I have to tweak indices a bit if I use a mirror matrix.

All the data is stored in `TeapotData.h` file - 28 patches in total. For visualisation I also added a vector with colors - one color for the patch. Later in shader I'll use patch id (the runtime kindly provides it) to sample transforms and colors and apply the changes to the corresponding patch.

===== The beginning
https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/AppData.h[`AppData`], as I already told, is a state holder. In this first tutorial it's pretty empty.

The https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/main.cpp[main.cpp] file starts with some includes as well with some global variables initialization. Globals are bad, you say. Indeed, I'm not a fan as well. But here's the deal: `glfw` library, which I use for window manipulation, uses callbacks for communication. For example, `glfwSetKeyCallback` calls user provided function on a keyboard press. The callback defined in https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/window/on_key_press.cpp[on_key_press.cpp] file. As you see, there's no way to pass `AppDataPtr` to that function. It is still possible to pass data around with `glfwSetWindowUserPointer` and `glfwGetWindowUserPointer`, but that breaks the agreement of a _single-unique-pointer_. So I decided to go with global variables. For now, there are https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/Global.h[three] They are used in callbacks, provided in https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/window/create_window.cpp[window creation function]. The function https://github.com/nikitablack/vulkan_by_example_2/blob/lesson_0/src/teapot/src/window/on_key_press.cpp[on_key_press] you already know - on `+` press the tesselation level increaes, on `-` - decreases, `space` press changes the rendering mode.

NOTE: The maximum tesselation level for your GPU can be found in an instance of `VkPhysicalDeviceLimits`, it's too early to know about it right now. But what is important to know, the specification guarantees certain values limits. `maxTessellationGenerationLevel`, for example, is guaranteed to be in the range 0 to 64.

After the window creation the _infinite_ loop is started. Of course it's not _that_ infinite - it will be stopped as soon as window is closed. After that happens everything should be cleared - we don't want to leave the garbage after the party, right?



----
void on_key_press(GLFWwindow * const window, int const key, int const /*scancode*/, int const action, int const /*mods*/)
{
	AppData * const appData{static_cast<AppData *>(glfwGetWindowUserPointer(window))};
	
	assert(appData);

	if (key == GLFW_KEY_KP_ADD && (action == GLFW_PRESS || action == GLFW_REPEAT))
	{
		// TODO increase tesselation level
	}
	else if (key == GLFW_KEY_KP_SUBTRACT && (action == GLFW_PRESS || action == GLFW_REPEAT))
	{
		// TODO decrease tesselation level
	}
	else if (key == GLFW_KEY_SPACE && (action == GLFW_RELEASE))
	{
		// TODO switch wireframe/solid rendering
	}
}
----

Here I obtain the data I passed earlier to `glfwSetWindowUserPointer()`.

Next I set some window size limit and finaly set a callback for the window resize.

----
void framebuffer_size_callback(GLFWwindow * const window, int const /*width*/, int const /*height*/)
{
	AppData * const appData{static_cast<AppData *>(glfwGetWindowUserPointer(window))};

	assert(appData);
	
	appData->framebufferResized = true;
}
----

All it's do is set the mentioned `framebufferResized` field to `true` but actual handling will be done in a main loop. This is done because there's no way to return an error from `glfw` callback, so if during the resize process there will be an exception we'll not know why.

NOTE: Almost all free functions in the application are _pure_, i.e. they don't change any state and don't have side effects. They always accept arguments by copy or const reference. I store each function in a separate unit (cpp file) and have all declarations in one place (`App.h` file).

After initializaition `MainApplication::run()` is called which loops until the window is closed:

----
void MainApplication::run()
{
	while (!glfwWindowShouldClose(_appData.window))
	{
		glfwPollEvents();
		render();
	}
}
----

Here in the loop I tell `glfw` to invoke registered callbacks with `glfwPollEvents` and do rendering (empty in this lesson).

In the `MainApplication` destructor I make cleaning:

----
MainApplication::~MainApplication()
{
	glfwTerminate();
}
----

For now only the window needs to be destroyed.

===== Conclusion
Wow, the whole post and no any single `Vulkan` related line of code! Sorry for that, it was a necessary long indroduction but I promise the next lesson will be much more interesting.

The source code for this lesson is https://github.com/nikitablack/vulkan_by_example/tree/lesson_0[here].