= Vulkan by example 0 - Introduction
:hp-tags: c++, vulkan

Hi everybody. Today we’ll talk about `Vulkan` - the modern API for communication with a GPU device. There're already some information and tutorials on the web as well as books but still it's not enough. Though all resources out there are great by all means, personally for me, they are a little bit hard to follow. Because `Vulkan` is huge - with tons of concepts and nuances (often we need to initialize a structure to initizlize another structure to initialize the third one ¯\\_(ツ)_/¯ ). In this series we’ll try to build a mental picture around the API, we’ll try not to just follow instructions, but to understand why do we need every bit of code. And first of all, I write the articles for myself, but I hope somebody will find them useful too.

I’ll build every next lesson on top of the previous by adding a new stuf, but without modifying it - I found it easier to follow. Though this rule is not strict and sometimes I’ll have to return back and change the old code, but I’ll try to minimize it. And yes, I’ll use pictures, a lot of them.

===== Disclaimer
I'm not an expert guru ninja, I'm just learning. And definitely, there will be mistakes in my lessons. I'm kindly asking you to point to them so I can fix them soon. You can use comments on twitter, where I'm planning to leave links to the articles, or https://khronosdevs.slack.com/[cpp slack Vulkan channel] which I check quite often.

===== What will be in tutorials
A teapot of course. We'll build an application which will show a rotating model. The application will accept an input from the user to increase/decrease tesselation level (i.e. how fine the model is) and switch between wireframe/solid rendering. In addition to usual vertex and index buffers we'll use uniform buffers for matrices (model, view, projection), storage buffer for patches transforms and colors and push constants for tesselation level. This setup is not optimal, but it covers a lot of vulkan concepts.

===== What will not be in tutorials
In addition to general graphics consepts I assume you know what tesselation is, why there are two related stages in the pipeline (tesselation control and tesselation evaluation), so I'll not explain it in detail. Same goes for curves surfaces - if you need to refresh your memory I recommend http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article]. I'll not explain math behaind projection and other transformation matrices. Also I assume you already have `Vulkan` SDK installed, have all required environment variables set and know how to use CMake.

===== Code organization
I use `CMake` for code building. I test my code on `Windows 10` and `Linux Mint`. On `Linux` I use `CLion` (it have nice `CMake` integration) with `gcc 7`, on `Windows` - `Visual Studio Community 2017` which supports `CMake` as well. Also `c++17` is my choice.

----
lesson/
├──src/
│   ├──teapot/
│   │   ├──resources/
│   │   ├──src/
│   │   │   ├──app/
│   │   │   │  ├──helpers/
│   │   │   │  │   └──...
│   │   │   │  └──...
│   │   │   ├──Main.cpp
│   │   │   ├──MainApplication.cpp
│   │   │   ├──MainApplication.h
│   │   │   └──TeapotData.h
│   │   └──CMakeLists.txt
│   └──third_party/
│       ├──eigen/
│       │   └──CMakeLists.txt
│       ├──glfw-3.2.1/
│       │   └──CMakeLists.txt
│       └──tl/
│           └──CMakeLists.txt
└──CMakeLists.txt
----
This is a typical project structure for each lesson. `resources/` folder holds shader `glsl` files. All application related files go to `app/` folder, helper wrappers around `Vulkan` functions and structs go to `helpers` folder.

I use some libraries as well:

- For window creation and management I use http://www.glfw.org/[`glfw`] library - it's simple and crossplatform. It have `Vulkan` support and simplifies some window related `Vulkan` parts.
- For math I use http://eigen.tuxfamily.org/index.php[`eigen`] library instead of commonly used `glm` because I'm more familiar with it.
- As you may already know almost each `Vulkan` function can fail and return some error code. When my procedure calls such a function it needs to report the result to the application - in case of success it should return an object and in case of a failure it should tell what happened. http://en.cppreference.com/w/cpp/utility/optional[`std::optional`] could be a good candidate for the return object - it can be empty or hold object, but it doesn't say why it is empty. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r4.html[`std::expected`] is what I need but it's not a part of the standard. Fortunatelly some smart people wrote an implementation for the current standard. I'm using `tl::expected` implementation from https://blog.tartanllama.xyz/[Simon Brand] (aka TartanLlama), you can read more about it https://blog.tartanllama.xyz/optional-expected/[here]. With it the code will look something like this:
----
using MaybeAppData = tl::expected<AppData, std::string>;
MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
	                          	.and_then(create_instance)
	                          	.and_then(create_surface)
	                          	.and_then(get_physical_device)
	                          	.and_then(create_logical_device)};
----
Here `AppData` is a state holder for the application and it gets filled with a data on each new procedure call (or not - if an error occured in one of the calls).

If you read https://nikitablack.github.io/2017/03/23/Functional-programming-in-c-by-example.html[one of my previous posts] you know that I’m a big fan of functional style and I’ll use this approach through tutorials. So prepare yourself to lots of free function and separate translation units!

===== The goal
I want to logically follow toward the goal step by step. But what's my goal? Of course, render a tesselated teapot! I chose it because it covers a lot of pipeline stages so I have to touch a lot of different parts of the API, which is good. I did it before with https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html[DirectX 12], so I already know the side to come from to that beast. This will be my goal:

video::8RCWeKLlVew[youtube, width=640, height=360]

Amazing, isn't it? Sorry for the blurriness - youtube mercilessly messed up with quality and I don't know how to achieve true HD picture.

Ok, now I know that I want a rotating teapot but before start I need a data to render.

===== The data
One of the first https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot[links] in Google offered me a nice teapot dataset. Though it looks good it requires some processing - if I use it as it is I'll get:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/teapot_initial_patches.png["teapot_initial_patches", 400]

The initial data describes only a fraction of the teapot so some parts have to be duplicated - the body part have to be rotated 3 times and the handle and the spout have to be mirrored. For these duplicated objects I just added additional indices - _almost_ copies of corresponding parts. For example, the rim patch is presented by 16 indices (the dataset uses 16-point patches) - `102, 103, 104, 105, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15` - and represents the quarter of the teapot rim. So I added the same indices 3 more times to the indices vector. But as you can gues just adding an indices copy will not work - I'll end up rendering the same patch in the same place. That's why I have to introduce another vector with patches transformations. Now the original rim patch will be rendered with identity transform, the next one - with 90 deg rotation, the next next one - with 180 deg rotation, and the last one with 270 deg rotation to enclose the surface completely. For mirrored parts it's a little bit trickier - if I just make a copy of indices and a use a mirror matrix (which basically a scale matrix) - the winding order will chage. On the following picture I tried to visualize a problem:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/vulkan_by_example/lesson_0/indices_mirror.png["teapot_initial_patches", 321]

Here the right triangle's face points in the positive `x` direction. It's clockwise indices are `1-2-3`. Now if I want the mirrored triangle to face in the negative `x` direction, I can't use `1'-2'-3'` anymore - I need to change the order to `1'-3'-2'` (or change the winding order to counter clockwise - but I don't want that, the entire mesh have to be consistent). That's why I have to tweak indices a bit if I use a mirror matrix.

All the data is stored in `TeapotData.h` file - 28 patches in total. For visualisation I also added a vector with colors - one color for the patch. Later in shader I'll use patch id (the runtime kindly provides it) to sample transforms and colors and apply the changes to the corresponding patch.

===== The preparing
The basic code flow is pretty straightforward: in `main` I create an instance of `MainApplication` and call it's method `MainApplication::run()` which starts an infinite loop until I close the window. Here's a `MainApplication` interface:

----
class MainApplication
{
public:
	MainApplication(uint32_t windowWidth, uint32_t windowHeight, std::string const & appName);
	MainApplication(MainApplication const &) = delete;
	MainApplication & operator=(MainApplication const &) = delete;
	~MainApplication();
	
	void run();
	
private:
	MainApplication();
	
	void render();

private:
	app::AppData m_appData{};
};
----

`AppData`, as I already told, is a state holder - it holds all objects required by the application. In this first tutorial it's pretty empty:

----
struct AppData
{
	GLFWwindow* window{nullptr};
	bool framebufferResized{false};
	
	TeapotData teapotData{};
};
----

All I know for now is that I need to render the `teapotData` onto some surface - a `window`. Ocassionaly the window will be resized so I need to handle that - `framebufferResized` field will help.

----
MainApplication::MainApplication(){}

MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName) : MainApplication{}
{
	app::MaybeWindow const mbWindow{app::create_window(windowWidth, windowHeight, appName)};
	
	if (!mbWindow)
		throw std::runtime_error{mbWindow.error()};
	
	m_appData.window = *mbWindow;
	
	glfwSetWindowUserPointer(m_appData.window, &m_appData);
	glfwSetKeyCallback(m_appData.window, &app::on_key_press);
	glfwSetWindowSizeLimits(m_appData.window, 640, 480, GLFW_DONT_CARE, GLFW_DONT_CARE);
	glfwSetFramebufferSizeCallback(m_appData.window, app::framebuffer_size_callback);
}
----

NOTE: Note how the main constructor delegates a call to the empty constructor - this is necessary if I want to call a destructor is case the constructor throws.

In `MainApplication's` constructor I first create a window with the help of one of many free functions - `create_window`:

----
MaybeWindow create_window(uint32_t const width, uint32_t const height, string const & title)
{
	if (!glfwInit())
		return tl::make_unexpected("failed to init glfw");
	
	if (!glfwVulkanSupported())
		return tl::make_unexpected("vulkan is not supported");
	
	glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
	glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
	
	GLFWwindow * const window{glfwCreateWindow(width, height, title.data(), nullptr, nullptr)};
	if(!window)
		return tl::make_unexpected("failed to create window");
	
	return window;
}
----

First I initialize `glfw`, next check if `Vulkan` is supported, next tell `glfw` to http://www.glfw.org/docs/latest/context_guide.html#context_object[not use a context] and create resizable windows and finally create a window.

Next step is to assosiate a data (instance of the `AppData`) with the window - later in different `glfw` callbacks I'll be able to retrieve this data. Then I set a callback with http://www.glfw.org/docs/latest/group__input.html#ga7e496507126f35ea72f01b2e6ef6d155[`glfwSetKeyCallback`] which listens for `+`, `-` or `space` keys to change tesselation level or rendering mode.

----
void on_key_press(GLFWwindow * const window, int const key, int const /*scancode*/, int const action, int const /*mods*/)
{
	AppData * const appData{static_cast<AppData *>(glfwGetWindowUserPointer(window))};
	
	assert(appData);

	if (key == GLFW_KEY_KP_ADD && (action == GLFW_PRESS || action == GLFW_REPEAT))
	{
		// TODO increase tesselation level
	}
	else if (key == GLFW_KEY_KP_SUBTRACT && (action == GLFW_PRESS || action == GLFW_REPEAT))
	{
		// TODO decrease tesselation level
	}
	else if (key == GLFW_KEY_SPACE && (action == GLFW_RELEASE))
	{
		// TODO switch wireframe/solid rendering
	}
}
----

Here I obtain the data I passed earlier to `glfwSetWindowUserPointer()`.

Next I set some window size limit and finaly set a callback for the window resize.

----
void framebuffer_size_callback(GLFWwindow * const window, int const /*width*/, int const /*height*/)
{
	AppData * const appData{static_cast<AppData *>(glfwGetWindowUserPointer(window))};

	assert(appData);
	
	appData->framebufferResized = true;
}
----

All it's do is set the mentioned `framebufferResized` field to `true` but actual handling will be done in a main loop. This is done because there's no way to return an error from `glfw` callback, so if during the resize process there will be an exception we'll not know why.

NOTE: Almost all free functions in the application are _pure_, i.e. they don't change any state and don't have side effects. They always accept arguments by copy or const reference. I store each function in a separate unit (cpp file) and have all declarations in one place (`App.h` file).

After initializaition `MainApplication::run()` is called which loops until the window is closed:

----
void MainApplication::run()
{
	while (!glfwWindowShouldClose(_appData.window))
	{
		glfwPollEvents();
		render();
	}
}
----

Here in the loop I tell `glfw` to invoke registered callbacks with `glfwPollEvents` and do rendering (empty in this lesson).

In the `MainApplication` destructor I make cleaning:

----
MainApplication::~MainApplication()
{
	glfwTerminate();
}
----

For now only the window needs to be destroyed.

===== Conclusion
Wow, the whole post and no any single `Vulkan` related line of code! Sorry for that, it was a necessary long indroduction but I promise the next lesson will be much more interesting.

The source code for this lesson is https://github.com/nikitablack/vulkan_by_example/tree/lesson_0[here].