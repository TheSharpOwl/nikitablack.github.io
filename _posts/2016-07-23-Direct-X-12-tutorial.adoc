= DirectX 12 tutorial
:hp-tags: c++, directx12

===== Disclaimer!
I'm not an expert. When I started to learn directx 12 I already was quite comfortable with directx 11. Nevertheless it was very difficult for me to switch. And even after several months of learning I still have a feeling that I just scratched a surface. So I'm still learning and this post is a syncronization of my thoughts so far and it will contain questions. Thought I hope somebody will find it useful.

Directx 12 is low level, it have many concepts and in order to make your code work well you need to take into account a lot of things. You need to profile a lot. And you need to know hardware. For example you need to know that changing descriptor heaps is a heavy operation. I have no idea what happening in hardware and why it's expensive. I'm just following guidelines and trying to remember.

Also I assume that the reader have an experience with previous directx versions because I'll not explain in this post what is swapchain or backbuffer. You should be familar with tesselation - what are tesselation factors, what is a constant function, why do you need `hull` and `domain` shaders. Also you need to know basic windows programming because we need to create a window and I'll not explain how to do it. So let's jump directly into the stove.

In this tutorial we're going to render a teapot. But not just a static mesh, no. We'll render a tesselated teapot. Why did I chose to go this way? Well, because you can find in the web different _HelloWorld_ examples. I wanted to create somethig that covers different areas of api and at the same time is simple. So our final picture will look like this:

[picture]

We're going to use 16-point patches for the teapot. We'll provide control points positions in one vertex buffer and patch indicies in one index buffer. For colors and transforms (more on this later) we'll use structured buffers.

Usually directx tutorials follows the same pattern - d3d initialization, resource creation, rendering. I decided to go different way - first we'll create the most important part of the code and later will add different components one after another as required. And the most important part, by my opinion, is *shaders*. After all this is what we want the gpu to execute and later we'll create a code to serve our shaders. Let's start.

===== Shaders
In our example we'll use `vertex`, `hull`, `domain` and `pixel` shaders.

*Vertex shader*

The first shader in our pipeline is the `vertex` shader. All it's do is accepts control point position from the application and passes it to the `hull` shader.

[source,cpp]
----
struct VertexData
{
	float3 pos : POSITION;
};

struct VertexToHull
{
	float3 pos : POSITION;
};

VertexToHull main(VertexData input)
{
	VertexToHull output;
	output.pos = input.pos;

	return output;
}
----

*Hull shader*

This shader, as you already know, accepts control point position from the `vertex` shader and also some data from the application in the form of constants which we'll use as tesseltion factors for the edge and inside of the patch.

[source,cpp]
----
#define NUM_CONTROL_POINTS 16

struct PatchTesselationFactors
{
	int edge;
	int inside;
};
ConstantBuffer<PatchTesselationFactors> tessFactors : register(b0);

struct VertexToHull
{
	float3 pos : POSITION;
};

struct PatchConstantData
{
	float EdgeTessFactor[4] : SV_TessFactor;
	float InsideTessFactor[2] : SV_InsideTessFactor;
};

struct HullToDomain
{
	float3 pos : POSITION;
};

PatchConstantData CalculatePatchConstants(InputPatch<VertexToHull, NUM_CONTROL_POINTS> ip, uint patchID : SV_PrimitiveID)
{
	PatchConstantData Output;

	Output.EdgeTessFactor[0] = tessFactors.edge;
	Output.EdgeTessFactor[1] = tessFactors.edge;
	Output.EdgeTessFactor[2] = tessFactors.edge;
	Output.EdgeTessFactor[3] = tessFactors.edge;
	Output.InsideTessFactor[0] = tessFactors.inside;
	Output.InsideTessFactor[1] = tessFactors.inside;

	return Output;
}

[domain("quad")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(NUM_CONTROL_POINTS)]
[patchconstantfunc("CalculatePatchConstants")]
HullToDomain main(InputPatch<VertexToHull, NUM_CONTROL_POINTS> ip, uint i : SV_OutputControlPointID, uint patchID : SV_PrimitiveID)
{
	HullToDomain output;
	output.pos = ip[i].pos;

	return output;
}
----

Here you see that the patch outputs 16 control points. Also note the new hlsl 5.1 syntax for the constant buffer `ConstantBuffer<PatchTesselationFactors> tessFactors : register(b0);`. Thought you can use the old syntax I like the new one more. Beyond this the shader is a simple pass-through, like a `vertex` shader.

*Domain shader*

Finally we arrived to the place of interest. Basically this is the place where all the work is done in our program.

[source,cpp]
----
#define NUM_CONTROL_POINTS 16

struct ConstantBufferPerObj
{
	row_major float4x4 wvpMat;
};
ConstantBuffer<ConstantBufferPerObj> constPerObject : register(b0);

struct PatchTransform
{
	row_major float4x4 transform;
};
StructuredBuffer<PatchTransform> patchTransforms : register(t0);

struct PatchColor
{
	float3 color;
};
StructuredBuffer<PatchColor> patchColors : register(t1);

struct PatchConstantData
{
	float EdgeTessFactor[4] : SV_TessFactor;
	float InsideTessFactor[2] : SV_InsideTessFactor;
};

struct HullToDomain
{
	float3 pos : POSITION;
};

struct DomainToPixel
{
	float4 pos : SV_POSITION;
	float3 color : COLOR;
};

float4 BernsteinBasis(float t)
{
	float invT = 1.0f - t;
	return float4(invT * invT * invT,	// (1-t)3
		3.0f * t * invT * invT,			// 3t(1-t)2
		3.0f * t * t * invT,			// 3t2(1-t)
		t * t * t);						// t3
}

float4 dBernsteinBasis(float t)
{
	float invT = 1.0f - t;
	return float4(-3 * invT * invT,		// -3(1-t)2
		3 * invT * invT - 6 * t * invT,	// 3(1-t)-6t(1-t)
		6 * t * invT - 3 * t * t,		// 6t(1-t) â€“ 3t2
		3 * t * t);						// 3t2
}

float3 EvaluateBezier(const OutputPatch<HullToDomain, NUM_CONTROL_POINTS> bezpatch, float4 BasisU, float4 BasisV)
{
	float3 Value = float3(0, 0, 0);
	Value = BasisV.x * (bezpatch[0].pos * BasisU.x + bezpatch[1].pos * BasisU.y + bezpatch[2].pos * BasisU.z + bezpatch[3].pos * BasisU.w);
	Value += BasisV.y * (bezpatch[4].pos * BasisU.x + bezpatch[5].pos * BasisU.y + bezpatch[6].pos * BasisU.z + bezpatch[7].pos * BasisU.w);
	Value += BasisV.z * (bezpatch[8].pos * BasisU.x + bezpatch[9].pos * BasisU.y + bezpatch[10].pos * BasisU.z + bezpatch[11].pos * BasisU.w);
	Value += BasisV.w * (bezpatch[12].pos * BasisU.x + bezpatch[13].pos * BasisU.y + bezpatch[14].pos * BasisU.z + bezpatch[15].pos * BasisU.w);

	return Value;
}

[domain("quad")]
DomainToPixel main(PatchConstantData input, float2 domain : SV_DomainLocation, const OutputPatch<HullToDomain, NUM_CONTROL_POINTS> patch, uint PatchID : SV_PrimitiveID)
{
	// Evaluate the basis functions at (u, v)
	float4 BasisU = BernsteinBasis(domain.x);
	float4 BasisV = BernsteinBasis(domain.y);
	float4 dBasisU = dBernsteinBasis(domain.x);
	float4 dBasisV = dBernsteinBasis(domain.y);

	// Evaluate the surface position for this vertex
	float3 WorldPos = EvaluateBezier(patch, BasisU, BasisV);

	// Evaluate the tangent space for this vertex (using derivatives)
	float3 Tangent = EvaluateBezier(patch, dBasisU, BasisV);
	float3 BiTangent = EvaluateBezier(patch, BasisU, dBasisV);
	float3 Norm = normalize(cross(Tangent, BiTangent));

	float4x4 transform = patchTransforms[PatchID].transform;
	float4 WorldPosTransformed = mul(float4(WorldPos, 1.0f), transform);
	DomainToPixel output;
	output.pos = mul(WorldPosTransformed, constPerObject.wvpMat);
	output.color = patchColors[PatchID].color;

	return output;
}
----

Going from the top we ca see that we're operating on the same 16 point patch, we have a constant buffer for the patch`s world-view-projection, structured buffer for the patch transform (more on this in a next section), structured buffer for the patch color. Here we can use one structured buffer for both transforms and colors but I deliberately split it on two to show how we can assign resources through the root table (more on this later). This data we're receiving from the application.

NOTE: There're some places where I chose non optimal path and I did this by purpose - maybe for simplicity or maybe to show different possibilities of the api. In such places I added a note. But if you found a place where things done poorly and there's no note around - that means I simply missed something and it would be great if you point this in the comment so I can make a fix.

There're also structs: `PatchConstantData` and `HullToDomain` - data from the `hull` shader (remember that position is a pass through from the `vertex` shader which also passes it through from the input assembler), `DomainToPixel` - the data we're passing further the pipeline - to the `pixel` shader.

Next is a pure math - in the `main()` function we have a list of control points (16 points) and we need to sample them so we can assign a position to the newly generated by tesselator vertex. The good overview of the math you can find http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[here]. Also http://www.gdcvault.com/play/1012740/direct3d[here] is a good presentation about tesselation in directx 11 (I took the shader code from there to be honest).

So what are we doing in the `main()` function? In the first step we're finding the vertex position in patch space.

NOTE: Recal that this function is called for every generated vertex. For example, if we have a square patch and the lowest possible tesselation applied (assuming we're not discarding a patch) the tesselator generates 4 vertices - one for every corner point. If we have edge tesselation factor of 2 and no inside tesselation we get 8 vertices (4 edges each one splitted on two parts).

Next we're obtaining some transform (next section will tell why) and transforming the vertex to the homogenious space by multiplying on world-view-projection matrix. Next we're sampling the color structured buffer (also - next section) and send all this data to our last programmable stage - `pixel` shader.



















In my https://nikitablack.github.io/2016/04/26/stdfunction-as-delegate.html[previous post] about delegates I wrote how to bind a member function to `std::function`. There was a lot of template magic involved in order to pass the correct number of http://en.cppreference.com/w/cpp/utility/functional/placeholders[placeholders]. Shortly after I published I received a lot of feedback and I'm very grateful for this. One advice was not to use http://en.cppreference.com/w/cpp/utility/functional/bind[`std::bind()`] at all. I'll paste directly the code from one of the comments and will make some time measurements:

[source,cpp]
----
template <class T, class R, class ... Args>
auto make_function(T t, R(T::*mem_fn)(Args...))
{
  return [t, mem_fn] (Args ... args) mutable -> R { return ((t).*(mem_fn))(args...); };
}
----