= DirectX 12 tutorial
:hp-tags: c++, directx12

===== Disclaimer!
I'm not an expert. When I started to learn directx 12 I already was quite comfortable with directx 11. Nevertheless it was very difficult for me to switch. And even after several months of learning I still have a feeling that I just scratched a surface. So I'm still learning and this post is a syncronization of my thoughts so far and it will contain questions. Thought I hope somebody will find it useful.

Directx 12 is low level, it have many concepts and in order to make your code work well you need to take into account a lot of things. You need to profile a lot. And you need to know hardware. For example you need to know that changing descriptor heaps is a heavy operation. I have no idea what happening in hardware and why it's expensive. I'm just following guidelines and trying to remember.

Also I assume that the reader have an experience with previous directx versions because I'll not explain in this post what is swapchain or backbuffer. You should be familar with tesselation - what are tesselation factors, what is a constant function, why do you need `hull` and `domain` shaders. Also you need to know basic windows programming because we need to create a window and I'll not explain how to do it. So let's jump directly into the stove.

In this tutorial we're going to render a teapot. But not just a static mesh, no. We'll render a tesselated teapot. Why did I chose to go this way? Well, because you can find in the web different _HelloWorld_ examples. I wanted to create somethig that covers different areas of api and at the same time is simple. So our final picture will look like this:

[picture]

Usually directx tutorials follows the same pattern - d3d initialization, resource creation, rendering. I decided to go different way - first we'll create the most important part of the code and later will add different components one after another as required. And the most important part, by my opinion, is *shaders*. After all this is what we want the gpu to execute and later we'll create a code to serve our shaders. Let's start.

===== Shaders
In our example we'll use `vertex`, `hull`, `domain` and `pixel` shaders.

*Vertex shader*

The first shader in our pipeline is the `vertex` shader. All it's do is accepts control point position from the application and passes it to the `hull` shader.

[source,cpp]
----
struct VertexData
{
	float3 pos : POSITION;
};

struct VertexToHull
{
	float3 pos : POSITION;
};

VertexToHull main(VertexData input)
{
	VertexToHull output;
	output.pos = input.pos;

	return output;
}
----

*Hull shader*

This shader, as you already know, accepts control point position from the `vertex` shader and also some data from the application in the form of constants which we'll use as tesseltion factors for the edge and inside of the patch.

[source,cpp]
----
#define NUM_CONTROL_POINTS 16

struct PatchTesselationFactors
{
	int edge;
	int inside;
};
ConstantBuffer<PatchTesselationFactors> tessFactors : register(b0);

struct VertexToHull
{
	float3 pos : POSITION;
};

struct PatchConstantData
{
	float EdgeTessFactor[4] : SV_TessFactor;
	float InsideTessFactor[2] : SV_InsideTessFactor;
};

struct HullToDomain
{
	float3 pos : POSITION;
};

PatchConstantData CalculatePatchConstants(InputPatch<VertexToHull, NUM_CONTROL_POINTS> ip, uint patchID : SV_PrimitiveID)
{
	PatchConstantData Output;

	Output.EdgeTessFactor[0] = tessFactors.edge;
	Output.EdgeTessFactor[1] = tessFactors.edge;
	Output.EdgeTessFactor[2] = tessFactors.edge;
	Output.EdgeTessFactor[3] = tessFactors.edge;
	Output.InsideTessFactor[0] = tessFactors.inside;
	Output.InsideTessFactor[1] = tessFactors.inside;

	return Output;
}

[domain("quad")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(NUM_CONTROL_POINTS)]
[patchconstantfunc("CalculatePatchConstants")]
HullToDomain main(InputPatch<VertexToHull, NUM_CONTROL_POINTS> ip, uint i : SV_OutputControlPointID, uint patchID : SV_PrimitiveID)
{
	HullToDomain output;
	output.pos = ip[i].pos;

	return output;
}
----


In my https://nikitablack.github.io/2016/04/26/stdfunction-as-delegate.html[previous post] about delegates I wrote how to bind a member function to `std::function`. There was a lot of template magic involved in order to pass the correct number of http://en.cppreference.com/w/cpp/utility/functional/placeholders[placeholders]. Shortly after I published I received a lot of feedback and I'm very grateful for this. One advice was not to use http://en.cppreference.com/w/cpp/utility/functional/bind[`std::bind()`] at all. I'll paste directly the code from one of the comments and will make some time measurements:

[source,cpp]
----
template <class T, class R, class ... Args>
auto make_function(T t, R(T::*mem_fn)(Args...))
{
  return [t, mem_fn] (Args ... args) mutable -> R { return ((t).*(mem_fn))(args...); };
}
----