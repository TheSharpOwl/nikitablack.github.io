= Vulkan by example 1 - Shaders
:hp-tags: c++, vulkan, glsl

In the https://TODO[previous lesson] I made all preparations necessary to start exploring vulkan. Here is the diagramm of the current state of the application:

[picture]

The diagramm is pretty empty now but it will grow as I progress through tutorials. For now it's enough to know that there's a CPU, which controls the application and orchestrates the GPU; a GPU itself, which do magic and produces nice pictures (not necessarily); a window which should show these pictures.

Now the logic question - what's next? I will start from the heart of every graphics application - by my opinion it is shaders, after all this is exactly what GPU runs. In my program I will use 4 shader stages - Vertex, Tesselation Control, Tesselation Eveluation, Fragment. Next I will step over all of these stages briefly explaining the purpose of each.

===== Vertex shader

This is the first stage in the pipeline and it's pretty simple. Looking back to the teapot data I know which information which needs to be passed - since I'm using patches I need to provide points describing them - `16` points for every patch.

----
#version 450

layout(location = 0) in vec3 inPosition;

out gl_PerVertex
{
    vec4 gl_Position;
};

void main()
{
    gl_Position = vec4(inPosition, 1.0);
}
----

A patch point arrives to the shader at location `0` and simply gets passed to the next stage. Thi stage will be executed for every point (vertex) that is provided. Since I use `28` patches `16` point each it will be called at least `28 * 16 = 448` times (it's not an important information - just for fun).

===== Tessellation control shader

----
#version 450

layout(push_constant) uniform TessLevel
{
	float value;
} tessLevel;

layout(vertices = 16) out;

void main()
{
    if (gl_InvocationID == 0)
    {
        gl_TessLevelInner[0] = tessLevel.value;
        gl_TessLevelInner[1] = tessLevel.value;

        gl_TessLevelOuter[0] = tessLevel.value;
        gl_TessLevelOuter[1] = tessLevel.value;
        gl_TessLevelOuter[2] = tessLevel.value;
        gl_TessLevelOuter[3] = tessLevel.value;
    }

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}
----

This shader simple as well as it doesn't do a lot of work, but it have a couple of interesting moments. The first one is how I update a tesselation level (how many details a tesselator should create). I decided to use the so called `Push Constant` - a feature that allows to pass a constant directly in command buffer. Don't affraid of all these terms right now - I'll explain what all this means when I reach the actual code that uses them. For now it's enough to know that the tesselation level is a float variable (to make a subdivision more smooth) that somehow updates from a CPU. Next I tell the GPU that this stage produces 16 control points for the patch, i.e. doesn't change the amount (yes, this stage can generate new points as well as remove some).

===== Tessellation Evaluation shader

This shader is the actual workhorse of the whole application - all the magic happens here.

----
#version 450

layout (quads, fractional_odd_spacing, cw) in;

struct PatchData
{
    mat4 transform;
    vec4 color;
};

layout(binding = 0, row_major) readonly buffer PatchDataBuffer
{
    PatchData data[];
} patchData;

layout(binding = 1) uniform Proj
{
    layout(row_major) mat4 mat;
} proj;

layout(binding = 2) uniform View
{
    layout(row_major) mat4 mat;
} view;

layout(binding = 3) uniform Model
{
    layout(row_major) mat4 mat;
} model;

layout (location = 0) out vec3 outColor;

vec4 bernsteinBasis(float t)
{
	float invT = 1.0f - t;

	return vec4(invT * invT * invT, // (1-t)^3
	            3.0f * t * invT * invT, // 3t(1-t)^2
	            3.0f * t * t * invT, // 3t2(1-t)
	            t * t * t); // t3
}

vec4 evaluateBezier(vec4 basisU, vec4 basisV)
{
	vec4 value = vec4(0.0, 0.0, 0.0, 0.0);

	value = basisV.x * (gl_in[0].gl_Position * basisU.x + gl_in[1].gl_Position * basisU.y + gl_in[2].gl_Position * basisU.z + gl_in[3].gl_Position * basisU.w);
	value += basisV.y * (gl_in[4].gl_Position * basisU.x + gl_in[5].gl_Position * basisU.y + gl_in[6].gl_Position * basisU.z + gl_in[7].gl_Position * basisU.w);
	value += basisV.z * (gl_in[8].gl_Position * basisU.x + gl_in[9].gl_Position * basisU.y + gl_in[10].gl_Position * basisU.z + gl_in[11].gl_Position * basisU.w);
	value += basisV.w * (gl_in[12].gl_Position * basisU.x + gl_in[13].gl_Position * basisU.y + gl_in[14].gl_Position * basisU.z + gl_in[15].gl_Position * basisU.w);
	value.w = 1.0;

	return value;
}

void main(void)
{
    vec4 basisU = bernsteinBasis(gl_TessCoord.x);
    vec4 basisV = bernsteinBasis(gl_TessCoord.y);

    vec4 localPos = evaluateBezier(basisU, basisV);

	gl_Position = localPos * patchData.data[gl_PrimitiveID].transform * model.mat * view.mat * proj.mat;

	outColor = patchData.data[gl_PrimitiveID].color.xyz;
}
----

First I need to specify tesselation rules: domain (`quad`), spacing (`fractional_odd_spacing`) and winding order (`cw` - clockwise). Next I define the patch information in the form of a buffer. Again, no information right now - just know that each patch should be transformed and colored (see https://TODO[introduction lesson] for more details why) and the information incoming as an array of `PatchData`. Also I need usual transformation matrices. I could provide one MVP-matrix and reduce the number of calculations but I want to show how to manipulate with multiple uniform buffers in `Vulkan`. That's why there are three matrices: model, view and projection.

Next is a scary math - calculation of a 3d point having a `gl_TessCoord` that came from tesselator. Actually the math is not that complicated, a found https://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article] very good at explaining the theory behind curves.And the code itself (functions `bernsteinBasis()` and `evaluateBezier()`) I shamelesly took from http://www.gdcvault.com/play/1012740/direct3d[this gdc presentation].

The outputs of this shader are newly generated vertex and color. Since the entire patch colored with a solid color every vertex from one patch will have the same attribute.

I think it's obvious that this shader will be invoked as many times as the number of generated vertices.

===== Fragment shader

----
#version 450

layout(location = 0) out vec4 outColor;

layout(location = 0) in vec3 fragColor;

void main()
{
    outColor = vec4(fragColor, 1.0);
}
----

Another one _"lazy"_ shader - the data is coming at input location `0` and going to the output storage location also `0`. Latter tells that there's should be some special memory region (`Image` in that case) somewhere.

Hurray! The application is almost done! Joking. Once I read the sentense which describes `Vulkan` in a nutshell: _"Show me your triangle in three months."_ The same applies here - I'm planning to write `7` or `8` parts in total. Shaders were the easiest part, all other code serves only to make them run and run *correctly*. By correctness I mean that there should not be undefined behavior, data races, pipeline stalls.

===== Finally some Vulkan

So I have some shaders written as text in some files, but I can't use them directly. In `Vulkan` shaders have to be compiled to so called `SPIR-V` binary format and supplied to the API via `VkShaderModule`. I can create one with `vkCreateShaderModule` function. Here's the definition of this function:

----
VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
----

Last parameter (`pShaderModule`) is a return value I'm interesting in. Third parameter (`pAllocator`) used for custom allocation and *never* will be used in lessons (always `nullptr`). Second parameter (`pCreateInfo`) is an information which describes a shader and can be created right now. But the first parameter (`device`) is an unknown variable.

`VkDevice` is a software representation of `GPU`. I think about it like an instance of a real physical `GPU` - it is possible to have multiple instances of it (though I will use only one). I can create one with `vkCreateDevice` function:

----
VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
----

`pDevice` - return value, `pAllocator` - `nullptr`, `pCreateInfo` - some information, `physicalDevice` - again unknown.

Continuing the analogy `VkPhysicalDevice` is a class or a blueprint. It represents unique piece of hardware and can be used for obtaining some useful info, like capabilities of the `GPU`. I can't create an instance of it, but can ask the API to give it with `vkEnumeratePhysicalDevices` call:

----
VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
----

It will never end... Here again I see an unknown variable `instance`. Moreover, this function can return a list of *all* available devices in the system but I'm interested only in one. For the application I need a GPU that supports tesselation and can output images to the operating system's present engine. Yes, it sounds weird but it looks like there are devices that can't render. In order to check device's _"presentability"_ I need some information about render surface. In `Vulkan` this information stored in `VkSurfaceKHR` object and I need to get this object. Fortunately with `GLFW` library this is an easy task:

----
VkResult glfwCreateWindowSurface(
    VkInstance instance,
    GLFWwindow * window,
    const VkAllocationCallbacks * allocator,
    VkSurfaceKHR * surface 
)
----

Again `VkInstance` It is an entity that keeps the state of the application and is used almost in every `Vulkan` function. I can create one with `vkCreateInstance` function:

----
VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
----

Previously I wrote that `GLFW` library helps with creation of a surface. But this surface thing is special. `VkSurfaceKHR` - this `KHR` ending means that this object is not a part of a _standard_ vulkan, but object which can be obtained through *extensions*. Indeed, presentation is so OS specific that it's very hard to make it as a part of a standard. Or there could be some vendor specific extensions that adds some new functionality. There are instance-level extensions and device-level extensions. For the surface I need to include instance-level extensions. Extensions are just string and I specify them like this:

----
_appData.instanceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
_appData.deviceExtensions.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
----

Finally I'm at the leaf node, no more unknown variables! And I already forgot why do I need all this... Ah, I wanted to create `Shader Modules`.

To summarize: here's the dependency chain:

----
VkShaderModule 🡢 VkDevice 🡢 VkPhysicalDevice 🡢 VkSurfaceKHR 🡢 VkInstance 🡢 extensions
----

And here's how this chain managed in the code:

----
// MainApplication.cpp
MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName) : MainApplication{}
{
	app::MaybeWindow const mbWindow{app::create_window(windowWidth, windowHeight, appName)};
	
	if (!mbWindow)
		throw std::runtime_error{mbWindow.error()};
	
	m_appData.window = *mbWindow;
	
	glfwSetWindowUserPointer(m_appData.window, &m_appData);
	glfwSetKeyCallback(m_appData.window, &app::on_key_press);
	glfwSetWindowSizeLimits(m_appData.window, 640, 480, GLFW_DONT_CARE, GLFW_DONT_CARE);
	glfwSetFramebufferSizeCallback(m_appData.window, app::framebuffer_size_callback);

	app::MaybeAppData mbData{app::MaybeAppData{app::get_required_window_extensions(std::move(m_appData))}
	                         .and_then(app::create_instance)
	                         .and_then(app::create_surface)
	                         .and_then(app::get_physical_device)
	                         .map(app::prepare_device_features)
	                         .and_then(app::create_logical_device)
	                         .and_then(app::create_shader_modules)};

	if (!mbData)
		throw std::runtime_error{mbData.error()};

	m_appData = std::move(*mbData);

	glfwSetWindowUserPointer(m_appData.window, &m_appData);
}
----

Here `MaybeAppData` is an alias to `tl::expected` (a library as a replacement for non-existent yet `std::expected`, see the https://TODO[previous article]) - it can hold an an `AppData` object or be empty, hence the suffix `maybe`.

----
using MaybeAppData = tl::expected<AppData, std::string>;
----

Just look how beautiful the code is. If the first call fails all other calls will not be executed and `expected` object will hold an error instead of valid value. By this error I can find the fail reason. Each function in the chain is a standalone pure function in separate unit - that's how I'm trying to fight the verbosity of a `Vulkan` application (the number of lines easile gets more that 1000 even in simple triangle application). Now I'm going to visit each function trying to explain what it does.

===== Getting required extensions

This one is simple because `GLFW` library helps:

----
AppData get_required_window_extensions(AppData data)
{
	uint32_t glfwExtensionCount{0};
	char const * const * const glfwExtensions{glfwGetRequiredInstanceExtensions(&glfwExtensionCount)};
		
	for (uint32_t i{0}; i < glfwExtensionCount; ++i)
		data.instanceExtensions.push_back(glfwExtensions[i]);
		
	return data;
}
----

http://www.glfw.org/docs/latest/group__vulkan.html#ga1abcbe61033958f22f63ef82008874b1[`glfwGetRequiredInstanceExtensions`] returns a list of extesion name required for surface creation. I pass this list to a `VkInstance` creation function.

NOTE: I could pass a const reference to `AppData` to avoid copying, but since I need a copy anyway to need to modify the state I just let the runtime to do one.

===== Creating an instance

Having required instance extensions names I can create an instance.

----
MaybeAppData create_instance(AppData data)
{
	helpers::MaybeInstance const mbInstance{helpers::create_instance(&data.instanceExtensions, &data.layers)};
	if(!mbInstance)
		return tl::make_unexpected(mbInstance.error());
	
	data.instance = *mbInstance;
	
	return data;
}
----

If call to  `vkCreateInstance` was successful I return modified `AppData` object wrapped by `expected` object. In opposite case `tl::expected` object will hold an error instead of a valid data.

All objects in `Vulkan` are created by providing information through corrsponding structures. For an instance this structure is `VkInstanceCreateInfo`. I isolated all structure creations in `VkStructHelpers.h` and `VkStructHelpers.cpp` files.

NOTE: It's possible to use https://github.com/KhronosGroup/Vulkan-Hpp[Vulkan-Hpp] `c++` wrapper by `Khronos`, but I decided to go low-level in this lessons.

----
VkInstanceCreateInfo get_instance_create_info(vector<char const *> const * const extensions, vector<char const *> const * const layers, VkApplicationInfo const * const applicationInfo)
{
	VkInstanceCreateInfo info{};
	info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
	info.pNext = nullptr;
	info.flags = 0;
	info.pApplicationInfo = applicationInfo;
	info.enabledLayerCount = (layers) ? static_cast<uint32_t>(layers->size()) : 0;
	info.ppEnabledLayerNames = (layers) ? layers->data() : nullptr;
	info.enabledExtensionCount = (extensions) ? static_cast<uint32_t>(extensions->size()) : 0;
	info.ppEnabledExtensionNames = (extensions) ? extensions->data() : nullptr;
	
	return info;
}
----

. Every structure in `Vulkan` have a corresponding name. For `VkInstanceCreateInfo` it is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`, for other types - other names. I will not mention this anymore for new structures.

. Some information objects can be extended by providing another structure in `pNext` member. For example, information for device memory creation can be extended with additional data that marks memory as shared. This application will not use that feature so I will not mention it anymore.

. This structure doesn't use any flags. In future I will only describe `flags` field only if it have value.

. This structure can provide information about application to the driver with `VkApplicationInfo` struct. Since it's only informatical I left it null.

. Layers are used for debugging. In this lesson it's too early for debugging and `layers` vector is empty. Notice how arrays are passed to `Vulkan` - there's no `std::vector` or other similar data structures - only raw pointers. And every array accompanied with it's size.

. I provide extensions got from `GLFW` window.

===== Creating a surface

----
MaybeAppData create_surface(AppData data)
{
	assert(data.instance);
	assert(data.window);
	
	if (glfwCreateWindowSurface(data.instance, data.window, nullptr, &data.surface) != VK_SUCCESS)
		return tl::make_unexpected("failed to create window surface");
	
	return data;
}
----

Again `GLFW` library takes care of surface creation with http://www.glfw.org/docs/latest/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965[`glfwCreateWindowSurface`] function which returns `VkResult` indicating the result of the call. Under the hood the library calls platform specific `Vulkan` function, like `vkCreateWin32SurfaceKHR` for `Windows` which uses corresponding info structure `VkWin32SurfaceCreateInfoKHR`. But `GLFW` hides this platform dependent call which is why I use it.

===== Obtaining a physical device

----
MaybeAppData get_physical_device(AppData data)
{
	assert(data.instance);
	assert(data.surface);
	
	uint32_t deviceCount{0};
	if(vkEnumeratePhysicalDevices(data.instance, &deviceCount, nullptr) != VK_SUCCESS || deviceCount == 0)
		return tl::make_unexpected("failed to find GPUs with Vulkan support");
	
	vector<VkPhysicalDevice> physicalDevices(deviceCount);
	if(vkEnumeratePhysicalDevices(data.instance, &deviceCount, physicalDevices.data()) != VK_SUCCESS)
		return tl::make_unexpected("failed to find GPUs with Vulkan support");
	
	for(VkPhysicalDevice const d : physicalDevices)
	{
		MaybeSurfaceFormat const mbSurfaceFormat{get_device_surface_format(d, data.surface)};
		if(!mbSurfaceFormat)
			continue;
		
		MaybePresentMode const mbPresentMode{get_device_surface_present_mode(d, data.surface)};
		if(!mbPresentMode)
			continue;
		
		if(!check_device_suitability(d, data.deviceExtensions))
			continue;
		
		MaybeQueueFamilies const mbQueueFamilies{get_device_graphics_and_present_queue_families(d, data.surface)};
		if(!mbQueueFamilies)
			continue;
		
		data.physicalDevice = d;
		tie(data.graphicsFamilyQueueIndex, data.presentFamilyQueueIndex) = *mbQueueFamilies;
		data.surfaceFormat = *mbSurfaceFormat;
		data.surfacePresentMode = *mbPresentMode;
		
		vkGetPhysicalDeviceProperties(data.physicalDevice, &data.physicalDeviceProperties);
		
		return data;
	}
	
	return tl::make_unexpected("failed to find suitable device");
}
----

----
using MaybeSurfaceFormat = tl::expected<VkSurfaceFormatKHR, string>;
using MaybePresentMode = tl::expected<VkPresentModeKHR, string>;
using MaybeQueueFamilies = tl::expected<tuple<uint32_t, uint32_t>, string>;
----

----
MaybeSurfaceFormat get_device_surface_format(VkPhysicalDevice const physicalDevice, VkSurfaceKHR const surface)
{
	app::helpers::MaybePhysicalDevicesSurfaceFormats const mbFormats{app::helpers::get_physical_devices_surface_formats(physicalDevice, surface)};
	if (!mbFormats)
		return tl::make_unexpected(mbFormats.error());
	
	vector<VkSurfaceFormatKHR> const formats{*mbFormats};

	if (formats.size() == 1 && formats[0].format == VK_FORMAT_UNDEFINED)
		return VkSurfaceFormatKHR{VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR};
	
	if (auto const it = find_if(begin(formats), end(formats), [](VkSurfaceFormatKHR const f) { return f.format == VK_FORMAT_B8G8R8A8_UNORM && f.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; }); it != end(formats))
		return VkSurfaceFormatKHR{VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR};
	
	return formats[0];
}
----


----
MaybePresentMode get_device_surface_present_mode(VkPhysicalDevice const physicalDevice, VkSurfaceKHR const surface)
{
	app::helpers::MaybePhysicalDevicesSurfacePresentModes const mbPresentModes{app::helpers::get_physical_device_surface_present_modes(physicalDevice, surface)};
	if (!mbPresentModes)
		return tl::make_unexpected(mbPresentModes.error());
	
	vector<VkPresentModeKHR> const presentModes{*mbPresentModes};

	if (auto const it = find(begin(presentModes), end(presentModes), VK_PRESENT_MODE_MAILBOX_KHR); it != end(presentModes))
		return VK_PRESENT_MODE_MAILBOX_KHR;
	
	if (auto const it = find(begin(presentModes), end(presentModes), VK_PRESENT_MODE_IMMEDIATE_KHR); it != end(presentModes))
		return VK_PRESENT_MODE_IMMEDIATE_KHR;
	
	return VK_PRESENT_MODE_FIFO_KHR;
}
----

----
bool check_required_device_extensions(VkPhysicalDevice const physicalDevice, vector<char const *> const & requiredExtensions)
{
	uint32_t extensionCount{0};
	if (vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr) != VK_SUCCESS)
		return false;
	
	vector<VkExtensionProperties> availableExtensions(extensionCount);
	if (vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, availableExtensions.data()) != VK_SUCCESS)
		return false;
	
	for (char const * element : requiredExtensions)
	{
		if (find_if(begin(availableExtensions), end(availableExtensions), [element](VkExtensionProperties const & extensionProp) { return strcmp(element, extensionProp.extensionName) == 0; }) == end(availableExtensions))
			return false;
	}
	
	return true;
}
----

----
bool check_device_suitability(VkPhysicalDevice const physicalDevice, vector<char const *> const & requiredExtensions)
{
	VkPhysicalDeviceProperties deviceProperties{};
	vkGetPhysicalDeviceProperties(physicalDevice, &deviceProperties);
	
	if (deviceProperties.deviceType != VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)
		return false;
	
	VkPhysicalDeviceFeatures deviceFeatures{};
	vkGetPhysicalDeviceFeatures(physicalDevice, &deviceFeatures);
	
	if (!deviceFeatures.tessellationShader)
		return false;
	
	if (deviceProperties.limits.maxTessellationPatchSize < 16)
		return false;
	
	if (!deviceFeatures.fillModeNonSolid)
		return false;
	
	if (!check_required_device_extensions(physicalDevice, requiredExtensions))
		return false;
	
	return true;
}
----

----
MaybeQueueFamilies get_device_graphics_and_present_queue_families(VkPhysicalDevice const physicalDevice, VkSurfaceKHR const surface)
{
	vector<VkQueueFamilyProperties> const queueFamilies{app::helpers::get_queue_family_properties(physicalDevice)};
	
	for (size_t i{0}; i < queueFamilies.size(); ++i)
	{
		VkQueueFamilyProperties queueFamily{queueFamilies[i]};
		
		if (queueFamily.queueCount > 0 && (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT))
		{
			VkBool32 presentSupported{VK_FALSE};
			vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, static_cast<uint32_t>(i), surface, &presentSupported);
			
			if (presentSupported)
				return make_tuple(static_cast<uint32_t>(i), static_cast<uint32_t>(i));
		}
	}
	
	int graphicsQueueIndex{-1};
	for (size_t i{0}; i < queueFamilies.size(); ++i)
	{
		VkQueueFamilyProperties queueFamily{queueFamilies[i]};
		
		if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT)
		{
			graphicsQueueIndex = static_cast<int>(i);
			break;
		}
	}
	
	if (graphicsQueueIndex == -1)
		return tl::make_unexpected("failed to find graphics queue");
	
	int presentQueueIndex{-1};
	for (size_t i{0}; i < queueFamilies.size(); ++i)
	{
		VkQueueFamilyProperties const queueFamily{queueFamilies[i]};
		
		if (queueFamily.queueCount > 0)
		{
			VkBool32 presentSupported{VK_FALSE};
			vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, static_cast<uint32_t>(i), surface, &presentSupported);
			
			if (presentSupported)
			{
				presentQueueIndex = static_cast<int>(i);
				break;
			}
		}
	}
	
	if (presentQueueIndex == -1)
		return tl::make_unexpected("failed to find present queue");
	
	return make_tuple(static_cast<uint32_t>(graphicsQueueIndex), static_cast<uint32_t>(presentQueueIndex));
}
----


----
AppData prepare_device_features(AppData data)
{
	data.physicalDeviceFeatures.tessellationShader = VK_TRUE;
	data.physicalDeviceFeatures.fillModeNonSolid = VK_TRUE;
	data.physicalDeviceFeatures.vertexPipelineStoresAndAtomics = VK_TRUE; // // though the patch buffer in the tesselation evaluation shader marked as `readonly` the validation layer still complains ("Shader requires vertexPipelineStoresAndAtomics but is not enabled on the device"). This is a bug - https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/73.
	
	return data;
}
----


----
MaybeAppData create_logical_device(AppData data)
{
	assert(data.physicalDevice);
	
	std::vector<uint32_t> queueIndices{data.graphicsFamilyQueueIndex};
	std::vector<std::vector<float>> queueNumAndPriorities{{1.0f}};
	
	if(data.graphicsFamilyQueueIndex != data.presentFamilyQueueIndex)
	{
		queueIndices.push_back(data.presentFamilyQueueIndex);
		queueNumAndPriorities.push_back({1.0f});
	}
	
	helpers::MaybeDevice const mbDevice{helpers::create_device(data.physicalDevice, &queueIndices, &queueNumAndPriorities, &data.physicalDeviceFeatures, &data.deviceExtensions)};
	if(!mbDevice)
		return tl::make_unexpected(mbDevice.error());
	
	data.device = *mbDevice;
	
	return data;
}
----


----
MaybeAppData create_shader_modules(AppData data)
{
	assert(data.device);
	
	{
		MaybeShaderData const mbShaderData{load_shader("VertexShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbVertexShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbVertexShaderModule)
			return tl::make_unexpected(mbVertexShaderModule.error());

		data.vertexShaderModule = *mbVertexShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("TesselationControlShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbTessControlShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbTessControlShaderModule)
			return tl::make_unexpected(mbTessControlShaderModule.error());

		data.tessControlShaderModule = *mbTessControlShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("TesselationEvaluationShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbTessEvaluationShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbTessEvaluationShaderModule)
			return tl::make_unexpected(mbTessEvaluationShaderModule.error());

		data.tessEvaluationShaderModule = *mbTessEvaluationShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("FragmentShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbFragmentShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbFragmentShaderModule)
			return tl::make_unexpected(mbFragmentShaderModule.error());

		data.fragmentShaderModule = *mbFragmentShaderModule;
	}

	return data;
}
----


----
using MaybeShaderData = tl::expected<vector<char>, string>;

MaybeShaderData load_shader(string const & fileName)
{
	ifstream file{fileName, ios::ate | ios::binary};

	if (!file.is_open())
		return tl::make_unexpected("failed to open shader file");

	size_t const fileSize{static_cast<size_t>(file.tellg())};
	vector<char> buffer(fileSize);

	file.seekg(0);
	file.read(buffer.data(), fileSize);

	file.close();

	if (!file)
		return tl::make_unexpected("failed to read shader file");

	if (buffer.empty() || buffer.size() % 4 != 0)
		return tl::make_unexpected("failed to read shader file");

	return buffer;
}
----