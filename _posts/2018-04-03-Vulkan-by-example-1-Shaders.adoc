= Vulkan by example 1 - Shaders
:hp-tags: c++, vulkan, glsl

In the https://TODO[previous lesson] I made all preparations necessary to start exploring vulkan. Here is the diagramm of the current state of the application:

[picture]

The diagramm is pretty empty now but it will grow as I progress through tutorials. For now it's enough to know that there's a CPU, which controls the application and sends commands to the GPU; a GPU itself, which do magic and produces nice pictures (not necessarily); a window which should show these pictures. The window put in a separate category because the presentation of the picture in it controlled by an OS and not by an application or a GPU.

Now the logic question - what's next? There are so many things to do, there are so many ways to do. I will start from the heart of every graphics application - shaders. After all this is exactly what GPU runs and we're here to programm the GPU. In my app I will use 4 shader stages - Vertex, Tesselation Control, Tesselation Eveluation, Fragment. I will step over all of these stages briefly explaining the purpose of each.

===== Vertex shader

This is the first stage in the pipeline and it's pretty simple. Looking back to the teapot data I know which information needs to be passed - since I'm using patches I need to provide points describing them - `16` points for every patch.

----
#version 450

layout(location = 0) in vec3 inPosition;

out gl_PerVertex
{
    vec4 gl_Position;
};

void main()
{
    gl_Position = vec4(inPosition, 1.0);
}
----

A patch point arrives to the shader at location `0` and simply gets passed to the next stage. This stage will be executed for every point (vertex) provided. Since I use `28` patches `16` point each it will be called at least `28 * 16 = 448` times (it's not an important information - just for fun).

===== Tessellation control shader

----
#version 450

layout(push_constant) uniform TessLevel
{
	float value;
} tessLevel;

layout(vertices = 16) out;

void main()
{
    if (gl_InvocationID == 0)
    {
        gl_TessLevelInner[0] = tessLevel.value;
        gl_TessLevelInner[1] = tessLevel.value;

        gl_TessLevelOuter[0] = tessLevel.value;
        gl_TessLevelOuter[1] = tessLevel.value;
        gl_TessLevelOuter[2] = tessLevel.value;
        gl_TessLevelOuter[3] = tessLevel.value;
    }

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}
----

This shader is simple as well as it doesn't do a lot of work, but it have a couple of interesting things. The first one is how I update a tesselation level (how many new triangles a tesselator should create). I decided to use the so called `Push Constant` - a feature that allows to pass a constant directly in command buffer. Don't be affraid of all these terms right now - I'll explain what all this means when I reach the actual code that uses them. For now it's enough to know that the tesselation level is a float variable (to make a subdivision more smooth) that somehow gets updated from a CPU. Next I tell the GPU that this stage produces 16 control points for the patch, i.e. doesn't change the amount (yes, this stage can generate new points as well as remove some).

===== Tessellation Evaluation shader

This shader is the actual workhorse of the whole application - all the magic happens here.

----
#version 450

layout (quads, fractional_odd_spacing, cw) in;

struct PatchData
{
    mat4 transform;
    vec4 color;
};

layout(binding = 0, row_major) readonly buffer PatchDataBuffer
{
    PatchData data[];
} patchData;

layout(binding = 1) uniform Proj
{
    layout(row_major) mat4 mat;
} proj;

layout(binding = 2) uniform View
{
    layout(row_major) mat4 mat;
} view;

layout(binding = 3) uniform Model
{
    layout(row_major) mat4 mat;
} model;

layout (location = 0) out vec3 outColor;

vec4 bernsteinBasis(float t)
{
	float invT = 1.0f - t;

	return vec4(invT * invT * invT, // (1-t)^3
	            3.0f * t * invT * invT, // 3t(1-t)^2
	            3.0f * t * t * invT, // 3t2(1-t)
	            t * t * t); // t3
}

vec4 evaluateBezier(vec4 basisU, vec4 basisV)
{
	vec4 value = vec4(0.0, 0.0, 0.0, 0.0);

	value = basisV.x * (gl_in[0].gl_Position * basisU.x + gl_in[1].gl_Position * basisU.y + gl_in[2].gl_Position * basisU.z + gl_in[3].gl_Position * basisU.w);
	value += basisV.y * (gl_in[4].gl_Position * basisU.x + gl_in[5].gl_Position * basisU.y + gl_in[6].gl_Position * basisU.z + gl_in[7].gl_Position * basisU.w);
	value += basisV.z * (gl_in[8].gl_Position * basisU.x + gl_in[9].gl_Position * basisU.y + gl_in[10].gl_Position * basisU.z + gl_in[11].gl_Position * basisU.w);
	value += basisV.w * (gl_in[12].gl_Position * basisU.x + gl_in[13].gl_Position * basisU.y + gl_in[14].gl_Position * basisU.z + gl_in[15].gl_Position * basisU.w);
	value.w = 1.0;

	return value;
}

void main(void)
{
    vec4 basisU = bernsteinBasis(gl_TessCoord.x);
    vec4 basisV = bernsteinBasis(gl_TessCoord.y);

    vec4 localPos = evaluateBezier(basisU, basisV);

	gl_Position = localPos * patchData.data[gl_PrimitiveID].transform * model.mat * view.mat * proj.mat;

	outColor = patchData.data[gl_PrimitiveID].color.xyz;
}
----

First I need to specify tesselation rules: domain (`quad`), spacing (`fractional_odd_spacing`) and winding order (`cw` - clockwise). Next I define the patch information in the form of a buffer. Again, no information right now - just know that each patch should be transformed and colored (see https://TODO[introduction lesson] for more details why) and the information incoming as an array of `PatchData`. Also I need usual transformation matrices. I could provide one MVP-matrix and reduce the number of calculations but I want to show how to deal with multiple uniform buffers in `Vulkan`. That's why there are three matrices: model, view and projection.

Next is a scary math - calculation of a 3d point having a `gl_TessCoord` that came from the tesselator. Actually the math is not that complicated, I found https://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article] very good at explaining the theory behind curves.And the code itself (functions `bernsteinBasis()` and `evaluateBezier()`) I shamelesly took from http://www.gdcvault.com/play/1012740/direct3d[this gdc presentation].

The outputs of this shader are newly generated vertex and color. Since the entire patch colored with a solid color every vertex from the same patch will have the same attribute.

I think it's obvious that a number of executions of this shader is equal to a number vertices produced by the tesselator.

===== Fragment shader

----
#version 450

layout(location = 0) out vec4 outColor;

layout(location = 0) in vec3 fragColor;

void main()
{
    outColor = vec4(fragColor, 1.0);
}
----

Another one _"lazy"_ shader - the data is coming at input location `0` and going to the output location `0`. The last one tells that there should be some special memory region (`Image` in that case) somewhere to keep the color.

Hurray! The application is almost done! Joking. Once I read the sentense which describes `Vulkan` in a nutshell: _"Show me your triangle in three months."_ So be patient. I'm planning to write `7` or `8` parts in total. Shaders were the easiest part, and all the remaining code we need to write should serve a single purpose - to make the shaders run. And run *correctly*. By correctness I mean that there should not be undefined behavior, data races, pipeline stalls.

===== Finally some Vulkan

So I have some shaders written as text which I can't use directly. In `Vulkan` shaders have to be compiled to so called `SPIR-V` binary format and supplied to the API via `VkShaderModule`. I can create one with `vkCreateShaderModule` function. Here's the definition of this function:

----
VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
----

Last parameter (`pShaderModule`) is a return value I'm interesting in. Third parameter (`pAllocator`) used for custom allocation and *never* will be used in these lessons (always `nullptr`). Second parameter (`pCreateInfo`) is an information which describes a shader. But the first parameter (`device`) is an unknown variable.

`VkDevice` is a software representation of `GPU`. I think about it like an instance of a real physical `GPU` - it is possible to have multiple instances of it (though we will use only one). I can create a device with `vkCreateDevice` function:

----
VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
----

`pDevice` - return value, `pAllocator` - `nullptr`, `pCreateInfo` - some information, `physicalDevice` - again unknown.

Continuing our OOP the analogy `VkPhysicalDevice` is a class itself or a blueprint. It represents unique piece of hardware and can be used for obtaining some useful info, like capabilities of the `GPU`. It exist as a single instance and we can't create it, but can ask the API to give it to us with `vkEnumeratePhysicalDevices` call - this function enumerates available physical devices in a system:

----
VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
----

It will never end... Here again we see an unknown variable `instance`. Moreover, this function can return a list of *all* available devices in the system but I'm interested only in one. For the application I need a GPU that supports tesselation and can output images to the operating system's presentation engine. Yes, it sounds weird but it looks like there are devices that can't render, at least in theory. In order to check device's _"presentability"_ I need some information about render surface. In `Vulkan` this information stored in `VkSurfaceKHR` object and I need to get this object. Fortunately with `GLFW` library this is an easy task:

----
VkResult glfwCreateWindowSurface(
    VkInstance instance,
    GLFWwindow * window,
    const VkAllocationCallbacks * allocator,
    VkSurfaceKHR * surface 
)
----

Again `VkInstance`. It is an entity that keeps the state of the application and which we can create with `vkCreateInstance` function:

----
VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
----

Previously I wrote that `GLFW` library helps with creation of a surface. But this surface thing is special. `VkSurfaceKHR` - this `KHR` ending means that this object is not a part of a _standard_ vulkan, but object which can be obtained through *extensions*. Indeed, presentation is so OS specific that it's very hard to make it as a part of a standard. Or there could be some vendor specific extensions that adds some new functionality. There are instance-level extensions and device-level extensions. Extensions are just strings and I specify them like this in the application:

----
_appData.instanceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
_appData.deviceExtensions.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
----

Finally no more unknown variables! But I already forgot why do I need all this... Ah, I wanted to create `Shader Modules`.

To summarize: here's the dependency chain:

----
VkShaderModule 🡢 VkDevice 🡢 VkPhysicalDevice 🡢 VkSurfaceKHR 🡢 VkInstance 🡢 extensions
----

And here's how this chain is managed in the code:

----
// MainApplication.cpp
MainApplication::MainApplication(uint32_t const windowWidth, uint32_t const windowHeight, std::string const & appName) : MainApplication{}
{
	app::MaybeWindow const mbWindow{app::create_window(windowWidth, windowHeight, appName)};
	
	if (!mbWindow)
		throw std::runtime_error{mbWindow.error()};
	
	m_appData.window = *mbWindow;
	
	glfwSetWindowUserPointer(m_appData.window, &m_appData);
	glfwSetKeyCallback(m_appData.window, &app::on_key_press);
	glfwSetWindowSizeLimits(m_appData.window, 640, 480, GLFW_DONT_CARE, GLFW_DONT_CARE);
	glfwSetFramebufferSizeCallback(m_appData.window, app::framebuffer_size_callback);

	app::MaybeAppData mbData{app::MaybeAppData{app::get_required_window_extensions(std::move(m_appData))}
	                         .and_then(app::create_instance)
	                         .and_then(app::create_surface)
	                         .and_then(app::get_physical_device)
	                         .map(app::prepare_device_features)
	                         .and_then(app::create_logical_device)
	                         .and_then(app::create_shader_modules)};

	if (!mbData)
		throw std::runtime_error{mbData.error()};

	m_appData = std::move(*mbData);

	glfwSetWindowUserPointer(m_appData.window, &m_appData);
}
----

Here `MaybeAppData` is an alias to `tl::expected` (a library as a replacement for non-existent yet `std::expected`, see the https://TODO[previous article]) - it can hold an an `AppData` object or be empty, hence the suffix `maybe`.

----
using MaybeAppData = tl::expected<AppData, std::string>;
----

Just look how beautiful the code is. If the first call fails all other calls will not be executed and `expected` object will hold an error instead of valid value. By this error I can find the fail reason. Each function in the chain is a standalone pure function in separate unit - that's how I'm trying to fight the verbosity of a `Vulkan` application (the number of lines easily gets over 1000 even in a simple triangle application). Now I'm going to visit each function trying to explain what it does.

===== Getting required extensions

This one is simple because `GLFW` library helps:

----
AppData get_required_window_extensions(AppData data)
{
	uint32_t glfwExtensionCount{0};
	char const * const * const glfwExtensions{glfwGetRequiredInstanceExtensions(&glfwExtensionCount)};
		
	for (uint32_t i{0}; i < glfwExtensionCount; ++i)
		data.instanceExtensions.push_back(glfwExtensions[i]);
		
	return data;
}
----

http://www.glfw.org/docs/latest/group__vulkan.html#ga1abcbe61033958f22f63ef82008874b1[`glfwGetRequiredInstanceExtensions`] returns a list of extesion names required for surface creation. I need this list to create a `VkInstance`, i.e. I need to be sure that my system can draw anything on the screen.

NOTE: I could pass a const reference to `AppData` to avoid copying, but since I need a copy anyway to return a new the state (remember - all functions should be pure) I just let the runtime to do one.

===== Creating an instance

With instance extensions names I can create an instance.

----
MaybeAppData create_instance(AppData data)
{
	helpers::MaybeInstance const mbInstance{helpers::create_instance(&data.instanceExtensions, &data.layers)};
	if(!mbInstance)
		return tl::make_unexpected(mbInstance.error());
	
	data.instance = *mbInstance;
	
	return data;
}
----

where `helpers::create_instance` declared/defined in `VkObjectHelpers.h/cpp` files:

----
// VkObjectHelpers.h
using MaybeInstance = tl::expected<VkInstance, std::string>;

// VkObjectHelpers.cpp
MaybeInstance create_instance(vector<char const *> const * const extensions, std::vector<char const *> const * const layers, VkApplicationInfo const * const applicationInfo)
{
	VkInstanceCreateInfo const createInfo{get_instance_create_info(extensions, layers, applicationInfo)};
	
	VkInstance instance{VK_NULL_HANDLE};
	if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS)
	return make_unexpected("failed to create instance");
	
	return instance;
}
----

All objects in `Vulkan` are created by providing information through corrsponding structures. For an instance this structure is `VkInstanceCreateInfo`. I isolated all structure creations in `VkStructHelpers.h/cpp` files.

NOTE: It's possible to use https://github.com/KhronosGroup/Vulkan-Hpp[Vulkan-Hpp] `c++` wrapper by `Khronos`, but I decided to go low-level in this lessons by multiple reasons - first I want to understand every bit of code and for this I want to type everything by myself, and the second reason is a `vulkan.hpp`'s size - it's almost 2MB and more than 40000 lines of code! Man, I don't want to retire waiting the compilation is done.

----
VkInstanceCreateInfo get_instance_create_info(vector<char const *> const * const extensions, vector<char const *> const * const layers, VkApplicationInfo const * const applicationInfo)
{
	VkInstanceCreateInfo info{};
	info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; // #1
	info.pNext = nullptr; // #2
	info.flags = 0; // #3
	info.pApplicationInfo = applicationInfo; // #4
	info.enabledLayerCount = (layers) ? static_cast<uint32_t>(layers->size()) : 0; // #5
	info.ppEnabledLayerNames = (layers) ? layers->data() : nullptr;
	info.enabledExtensionCount = (extensions) ? static_cast<uint32_t>(extensions->size()) : 0; // #6
	info.ppEnabledExtensionNames = (extensions) ? extensions->data() : nullptr;
	
	return info;
}
----

. Every structure in `Vulkan` have a corresponding name. For `VkInstanceCreateInfo` it is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`, for other types - other names. I will not mention this anymore for new structures.

. Some information objects can be extended by providing another structure in `pNext` member. For example, information for device memory creation can be extended with additional data that marks memory as shared. This application will not use that feature so I will not mention it anymore.

. This structure doesn't use any flags. In future I will only describe `flags` field only if it's not empty.

. This structure can provide information about application to the driver with `VkApplicationInfo` struct. Since it's only informatical I pass a `nullptr`.

. Layers are used for debugging. In this lesson it's too early for debugging and `layers` vector is empty. Notice how arrays are passed to `Vulkan` - there's no `std::vector` or other similar data structures - only raw pointers. And every array accompanied with it's size.

. I provide extensions I got from `GLFW` window.

===== Creating a surface

----
MaybeAppData create_surface(AppData data)
{
	assert(data.instance);
	assert(data.window);
	
	if (glfwCreateWindowSurface(data.instance, data.window, nullptr, &data.surface) != VK_SUCCESS)
		return tl::make_unexpected("failed to create window surface");
	
	return data;
}
----

Again `GLFW` library takes care of surface creation with http://www.glfw.org/docs/latest/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965[`glfwCreateWindowSurface`] function which returns `VkResult` indicating the result of the call. Under the hood the library calls platform specific `Vulkan` function, like `vkCreateWin32SurfaceKHR` for `Windows` which uses corresponding info structure `VkWin32SurfaceCreateInfoKHR`. But `GLFW` hides this platform dependent call and this is why I use it.

===== Obtaining a physical device

We have the Vulkan instance and the window surface, now we can enumerate all available devices (GPUs) and select one fulfilling our needs.

----
MaybeAppData get_physical_device(AppData data)
{
	assert(data.instance);
	assert(data.surface);
	
	helpers::MaybePhysicalDevices const mbPhysicalDevices{helpers::get_physical_devices(data.instance)}; // #1
	if(!mbPhysicalDevices)
		return tl::make_unexpected(mbPhysicalDevices.error());
	
	vector<VkPhysicalDevice> const & physicalDevices{*mbPhysicalDevices};
	
	for(VkPhysicalDevice const d : physicalDevices)
	{
		if(!check_device_suitability(d, data.deviceExtensions)) // #2
			continue;
		
		MaybeSurfaceFormat const mbSurfaceFormat{get_device_surface_format(d, data.surface)}; // #3
		if(!mbSurfaceFormat)
			continue;
		
		MaybePresentMode const mbPresentMode{get_device_surface_present_mode(d, data.surface)}; // #4
		if(!mbPresentMode)
			continue;
		
		MaybeQueueFamilies const mbQueueFamilies{get_device_graphics_and_present_queue_families(d, data.surface)}; // #5
		if(!mbQueueFamilies)
			continue;
		
		data.physicalDevice = d;
		tie(data.graphicsFamilyQueueIndex, data.presentFamilyQueueIndex) = *mbQueueFamilies;
		data.surfaceFormat = *mbSurfaceFormat;
		data.surfacePresentMode = *mbPresentMode;
		
		vkGetPhysicalDeviceProperties(data.physicalDevice, &data.physicalDeviceProperties); // #6
		
		return data;
	}
	
	return tl::make_unexpected("failed to find suitable device");
}
----

As can be seen the function calls other functions. Let's investigate each in order.

. First I get all available devices in my system with the helper function:

----
MaybePhysicalDevices get_physical_devices(VkInstance const instance)
{
	assert(instance);
	
	uint32_t deviceCount{0};
	if(vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr) != VK_SUCCESS || deviceCount == 0) // #a
		return make_unexpected("failed to find GPUs with Vulkan support");
	
	vector<VkPhysicalDevice> physicalDevices(deviceCount);
	if(vkEnumeratePhysicalDevices(instance, &deviceCount, physicalDevices.data()) != VK_SUCCESS) // #b
		return make_unexpected("failed to find GPUs with Vulkan support");
	
	return physicalDevices;
}
----

.. A typical pattern in `Vulkan` - if you want to get the number of something you call a function with a null argument. So I call `vkEnumeratePhysicalDevices` with last argument as `nullptr` and the implementation fills `deviceCount` with an actual number of devices.

.. This time I call `vkEnumeratePhysicalDevices` with a pointer to the container and the implementation fills the container with `deviceCount` physical devices.

[start=2]
. Next I iterate over all devices and check if the current one fits our needs:

----
bool check_device_suitability(VkPhysicalDevice const physicalDevice, vector<char const *> const & requiredExtensions)
{
	VkPhysicalDeviceProperties deviceProperties{};
	vkGetPhysicalDeviceProperties(physicalDevice, &deviceProperties); // #a
	
	if (deviceProperties.deviceType != VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) // #b
		return false;
	
	VkPhysicalDeviceFeatures deviceFeatures{};
	vkGetPhysicalDeviceFeatures(physicalDevice, &deviceFeatures); // #c
	
	if (!deviceFeatures.tessellationShader) // #d
		return false;
	
	if (deviceProperties.limits.maxTessellationPatchSize < 16) // #e
		return false;
	
	if (!deviceFeatures.fillModeNonSolid) // #f
		return false;
	
	if (!check_required_device_extensions(physicalDevice, requiredExtensions)) // #g
		return false;
	
	return true;
}
----

.. First I get device properties with `vkGetPhysicalDeviceProperties` call. This function never fails according to specs so no checks here.

.. One of my test machines have 2 GPUs and I want to use the more powerfull one so I ignore all non discrete adapters (i.e. integrated). But if your laptop have a modern Intel GPU you can remove this check.

.. Next I get device features. The difference between properties and features is that the former is a general properties which just show the GPU capabilities while the latter can be enabled or disabled per request.

.. Here I check that a _tesselation feature_ can be enabled for the considered device.

.. Next I check the size of a patch. Remember that I'm using 16 point patches so I need to be sure the GPU knows how to deal with them. This is a GPU _property_ and it can be requested only if the corresponding _feature_ (`deviceFeatures.tessellationShader`) is supported.

.. Next feature to check is an ability to draw in wireframe mode.

.. And the last one thing to do for now is to check if required extensions are supported by the selected device. Remember, earlier I mentioned extensions and we even added some for the instance creation. You can think of instance extensions as global ones, i.e. you turn them on once per application. But device extensions can be turned on, well, per device. One of the examples of such extensions is `VK_KHR_SWAPCHAIN_EXTENSION_NAME` - the extension that is needed for swap chain creation. Since we don't know yet what is it this list of required extensions is empty. But later when we need one we just add the string to the vector. The `check_required_device_extensions` defined so:

----
bool check_required_device_extensions(VkPhysicalDevice const physicalDevice, vector<char const *> const & requiredExtensions)
{
	app::helpers::MaybeExtensionProperties mbExtensions{app::helpers::get_physical_device_device_extension_properties(physicalDevice)};
	if(!mbExtensions)
		return false;
	
	vector<VkExtensionProperties> const & availableExtensions{*mbExtensions};
	
	for (char const * element : requiredExtensions)
	{
		if (find_if(begin(availableExtensions), end(availableExtensions), [element](VkExtensionProperties const & extensionProp) { return strcmp(element, extensionProp.extensionName) == 0; }) == end(availableExtensions))
			return false;
	}
	
	return true;
}
----

Where the helper function lools like this:

----
MaybeExtensionProperties get_physical_device_device_extension_properties(VkPhysicalDevice const physicalDevice)
{
	assert(physicalDevice);
	
	uint32_t extensionCount{0};
	if (vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr) != VK_SUCCESS)
		return make_unexpected("failed to get physical device extension properties");
	
	vector<VkExtensionProperties> extensions(extensionCount);
	if (vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, extensions.data()) != VK_SUCCESS)
		return make_unexpected("failed to get physical device extension properties");
	
	return extensions;
}
----

Here we see the familiar pattern for obtaining the list of elements of unknown size in Vulkan.

[start=3]
. Next I try to get an underlying window surface format - we need to know it since we want to render to that surface and we want our picture to be correct.

----
MaybeSurfaceFormat get_device_surface_format(VkPhysicalDevice const physicalDevice, VkSurfaceKHR const surface)
{
	app::helpers::MaybePhysicalDevicesSurfaceFormats const mbFormats{app::helpers::get_physical_devices_surface_formats(physicalDevice, surface)}; // #a
	if (!mbFormats)
		return tl::make_unexpected(mbFormats.error());
	
	vector<VkSurfaceFormatKHR> const formats{*mbFormats};

	if (formats.size() == 1 && formats[0].format == VK_FORMAT_UNDEFINED)
		return VkSurfaceFormatKHR{VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; // #b
	
	if (auto const it = find_if(begin(formats), end(formats), [](VkSurfaceFormatKHR const f) { return f.format == VK_FORMAT_B8G8R8A8_UNORM && f.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR; }); it != end(formats))
		return VkSurfaceFormatKHR{VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}; // #c
	
	return formats[0]; // #d
}
----

.. `get_physical_devices_surface_formats` lives in the helper file:

----
MaybePhysicalDevicesSurfaceFormats get_physical_devices_surface_formats(VkPhysicalDevice const physicalDevice, VkSurfaceKHR const surface)
{
	assert(physicalDevice);
	assert(surface);
	
	uint32_t formatsCount{0};
	if (vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatsCount, nullptr) != VK_SUCCESS)
		return make_unexpected("failed to get physical device surface formats");
	
	vector<VkSurfaceFormatKHR> formats(formatsCount);
	if (formatsCount == 0 || vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatsCount, formats.data()) != VK_SUCCESS)
		return make_unexpected("failed to get physical device surface formats");
	
	return formats;
}
----

Nothing new or anything to talk about. It just gives us the list of all formats gpu supports for the given device and the surface.

[start=2]
.. Having a list of supported formats for the selected device we need to choose the one we will use. Here's a quote from the specification:

[source]
--
If pSurfaceFormats includes just one entry, whose value for format is VK_FORMAT_UNDEFINED, surface has no preferred format. In this case, the application can use any valid VkFormat value.
--

So if this condition is true I simply return `VK_FORMAT_B8G8R8A8_UNORM` as format and `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` as a color space.

[start=3]
.. If the previous condition was not true I iterate over all supported formats searching for the one I like (`{VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR}`).

.. Finally if the desired format was not found I just return the first one.




. Next

----
using MaybeSurfaceFormat = tl::expected<VkSurfaceFormatKHR, string>;
using MaybePresentMode = tl::expected<VkPresentModeKHR, string>;
using MaybeQueueFamilies = tl::expected<tuple<uint32_t, uint32_t>, string>;
----








----
AppData prepare_device_features(AppData data)
{
	data.physicalDeviceFeatures.tessellationShader = VK_TRUE;
	data.physicalDeviceFeatures.fillModeNonSolid = VK_TRUE;
	data.physicalDeviceFeatures.vertexPipelineStoresAndAtomics = VK_TRUE; // // though the patch buffer in the tesselation evaluation shader marked as `readonly` the validation layer still complains ("Shader requires vertexPipelineStoresAndAtomics but is not enabled on the device"). This is a bug - https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/73.
	
	return data;
}
----


----
MaybeAppData create_logical_device(AppData data)
{
	assert(data.physicalDevice);
	
	std::vector<uint32_t> queueIndices{data.graphicsFamilyQueueIndex};
	std::vector<std::vector<float>> queueNumAndPriorities{{1.0f}};
	
	if(data.graphicsFamilyQueueIndex != data.presentFamilyQueueIndex)
	{
		queueIndices.push_back(data.presentFamilyQueueIndex);
		queueNumAndPriorities.push_back({1.0f});
	}
	
	helpers::MaybeDevice const mbDevice{helpers::create_device(data.physicalDevice, &queueIndices, &queueNumAndPriorities, &data.physicalDeviceFeatures, &data.deviceExtensions)};
	if(!mbDevice)
		return tl::make_unexpected(mbDevice.error());
	
	data.device = *mbDevice;
	
	return data;
}
----


----
MaybeAppData create_shader_modules(AppData data)
{
	assert(data.device);
	
	{
		MaybeShaderData const mbShaderData{load_shader("VertexShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbVertexShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbVertexShaderModule)
			return tl::make_unexpected(mbVertexShaderModule.error());

		data.vertexShaderModule = *mbVertexShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("TesselationControlShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbTessControlShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbTessControlShaderModule)
			return tl::make_unexpected(mbTessControlShaderModule.error());

		data.tessControlShaderModule = *mbTessControlShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("TesselationEvaluationShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbTessEvaluationShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbTessEvaluationShaderModule)
			return tl::make_unexpected(mbTessEvaluationShaderModule.error());

		data.tessEvaluationShaderModule = *mbTessEvaluationShaderModule;
	}

	{
		MaybeShaderData const mbShaderData{load_shader("FragmentShader.spv")};
		if (!mbShaderData)
			tl::make_unexpected(mbShaderData.error());

		helpers::MaybeShaderModule const mbFragmentShaderModule{helpers::create_shader_module(data.device, &(*mbShaderData))};
		if (!mbFragmentShaderModule)
			return tl::make_unexpected(mbFragmentShaderModule.error());

		data.fragmentShaderModule = *mbFragmentShaderModule;
	}

	return data;
}
----


----
using MaybeShaderData = tl::expected<vector<char>, string>;

MaybeShaderData load_shader(string const & fileName)
{
	ifstream file{fileName, ios::ate | ios::binary};

	if (!file.is_open())
		return tl::make_unexpected("failed to open shader file");

	size_t const fileSize{static_cast<size_t>(file.tellg())};
	vector<char> buffer(fileSize);

	file.seekg(0);
	file.read(buffer.data(), fileSize);

	file.close();

	if (!file)
		return tl::make_unexpected("failed to read shader file");

	if (buffer.empty() || buffer.size() % 4 != 0)
		return tl::make_unexpected("failed to read shader file");

	return buffer;
}
----