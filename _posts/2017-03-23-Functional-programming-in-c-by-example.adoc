= Functional programming in c++ by example
:hp-tags: c++, functional

Functional programming (*FP*) is popular these days. Articles, books, blogs. Every conference has a couple of talks about the beauty of functional approach. I looked at it from the side for a long time and now I want to try it in practice. After I dug a lot through the theory I decided to write a small application in a functional style. I'll take a code from my https://nikitablack.github.io/2017/02/02/Data-Oriented-Design-by-example.html[previous article] so the example will be a 2D physics simulation.

The Russian version of the post is https://habrahabr.ru/post/324518/[here].

===== Disclaimer

I'm not an expert, so take all my words with a grain of salt. From all of the functional languages, I had an experience only with Erlang. This article is my attempt to better understand *FP* and a field of its appliance. Here I'll write step by step how I transformed *OOP* code to some sort of functional. In other words, here I'm presenting my learning process. And of course, I welcome criticism.

===== Introduction

I'll not touch *FP* theory at all - you can find a way better sources around. Thought I tried to write the program in the pure functional style I couldn't achieve it by 100%. Sometimes because there's no sense because the language doesn't support a feature (pattern matching, for example), sometimes because of lack of experience. For example, rendering is done in usual *OOP* style. Why? Because one of the *FP* principles is data immutability and absence of a state. But for DirectX (API I'm using), it's necessary to keep buffers, textures, devices. Though it's possible to recreate everything every frame it'll be too long (we'll talk about performance later). Also, you'll not find here lazy evaluations - because I couldn't find a place where I could use it.

The source code can be found https://github.com/nikitablack/cpp-tests/tree/master/functional/almost_pure_functional[here].

===== Main

In the `main()` function we create shapes (`struct Shape`) and start an infinite loop where we'll update the simulation. It's worth to mention the code organization - every function resides in a separate cpp file and in place of it's use it have to be declared as `extern`. Using this approach there's no need to create a header which plausibly affects compilation time. Moreover, it makes the code more clear: one function - one file.

After the creation of initial data, we need to pass it further to `updateSimulation()` function.

===== Update Simulation

This function is the heart of our program. This is the signature:

[source,cpp]
----
vector<Shape> updateSimulation(float const dt, vector<Shape> const shapes, float const width, float const height);
----

We're taking the data by value and return a copy of modified data. But why a copy and not a const reference? Earlier I wrote that one of the principles of *FP* is data immutability and `const reference` guarantees that. That's right, but there's another important principle - the function should be pure, i.e. it shouldn't introduce side effects and with the same input data output should be always the same. But taking a reference function can't have that guarantee. Let's look at the example:

[source,cpp]
----
int foo(vector<int> const & data)
{
    return accumulate(data.begin(), data.end(), 0);
}

vector<int> data{1, 1, 1};
int result{foo(data)};
----

Though `foo()` takes input by const reference the data itself is not constant. That means it can be changed before or during the call to `accumulate()` for example by another thread. On the other side if we'll obey the rule of passing data by copy the modification of data excluded.

Moreover, in order to maintain data immutability principle, all fields of all user types should be const. This is, for example, `Vec2` type:

[source,cpp]
----
struct Vec2
{
	float const x;
	float const y;

	Vec2(float const x = 0.0f, float const y = 0.0f) : x{ x }, y{ y }
	{}

	// member functions - all const
}
----

As you can see, the state is set during object creation and never changes. It's even hard to call this a state - it's just the data.

Let's go back to the function `updateSimulation()`. It's called the following way:

[source,cpp]
----
shapes = updateSimulation(dtStep, move(shapes), wSize.x, wSize.y);
----

Since `shapes` is not constant here we can move the data (`std::move()`) - potentially this can avoid unnecessary copying. In our case, however, there's no effect - we're working with primitive types and moving is equal to copying.

One more interesting thing - the function returns a new data which assigned to the old variable `shapes`. By theory, this violates the rule of state absence. However, by my humble opinion, we can use local variable freely since it has no effect on the result, i.e. the state encapsulated inside the function.

This is function's body:

[source,cpp]
----
vector<Shape> updateSimulation(float const dt, vector<Shape> const shapes, float const width, float const height)
{
	// step 1 - update calculate current positions
	vector<Shape> const updatedShapes1{ calculatePositionsAndBounds(dt, shapes) };

	// step 2 - for each shape calculate cells it fits in
	uint32_t rows;
	uint32_t columns;
	tie(rows, columns) = getNumberOfCells(width, height); // auto [rows, columns] = getNumberOfCells(width, height); - c++17 structured bindings - not supported in vs2017 at the moment of writing

	vector<Shape> const updatedShapes2{ calculateCellsRanges(width, height, rows, columns, updatedShapes1) };

	// step 3 - put shapes in corresponding cells
	vector<vector<Shape>> const cellsWithShapes{ fillGrid(width, height, rows, columns, updatedShapes2) };

	// step 4 - calculate collisions
	vector<VelocityAfterImpact> const velocityAfterImpact{ solveCollisions(cellsWithShapes, columns) };

	// step 5 - apply velocities
	vector<Shape> const updatedShapes3{ applyVelocities(updatedShapes2, velocityAfterImpact) };

	return updatedShapes3;
}
----

As always we take the data by copy and return the copy. This code is easy to understand - we call a function after function passing data from one stage to another - just like a pipeline.

Next, we'll run through the algorithm and will see what we have to do to make it work with *FP*.

===== Ð¡alculate Positions And Bounds

[source,cpp]
----
vector<Shape> calculatePositionsAndBounds(float const dt, vector<Shape> const shapes)
{
	vector<Shape> updatedShapes;
	updatedShapes.reserve(shapes.size());

	transform(shapes.begin(), shapes.end(), back_inserter(updatedShapes), [dt](Shape const shape)
	{
		Shape const newShape{ shape.id, shape.vertices, calculatePosition(shape, dt), shape.velocity, shape.bounds, shape.cellsRange, shape.color, shape.massInverse };
		return Shape{ newShape.id, newShape.vertices, newShape.position, newShape.velocity, calculateBounds(newShape), newShape.cellsRange, newShape.color, newShape.massInverse };
	});

	return updatedShapes;
}
----

The standard library supports *FP* for many years. Algorithm `transform()` is a high-order function, i.e. the function that accepts other functions as parameters. *STL* have tons of interesting algorithms and it's very important to know them if you're writing in functional style.

There's interesting thing in this example. In pure *FP* there're no loops, since loop counter is a state. Instead of loops *FP* uses recursion. Let's try to rewrite our function with it:

[source,cpp]
----
vector<Shape> updateOne(float const dt, vector<Shape> shapes, vector<Shape> updatedShapes)
{
	if (shapes.size() > 0)
	{
		Shape shape{ shapes.back() };
		shapes.pop_back();

		Shape const newShape{ shape.id, shape.vertices, calculatePosition(shape, dt), shape.velocity, shape.bounds, shape.cellsRange, shape.color, shape.massInverse };
		updatedShapes.emplace_back(newShape.id, newShape.vertices, newShape.position, newShape.velocity, calculateBounds(newShape), newShape.cellsRange, newShape.color, newShape.massInverse);
	}
	else
	{
		return updatedShapes;
	}

	return updateOne(dt, move(shapes), move(updatedShapes));
}

vector<Shape> calculatePositionsAndBounds(float const dt, vector<Shape> const shapes)
{
	return updateOne(dt, move(shapes), {});
}
----

Instead of one function, we have two. And what is more important the readability became worse (at least for me - the guy who grown up on traditional *OOP*). In this approach, we used so-called tail recursion. In theory, in this case, the stack should be cleared on every recursion entrance. However, I couldn't find in c++ standard the correct behavior. Because of this, I can't guarantee that there will be no stack overflow. Taking all this into account I decided not to use recursion in my code.