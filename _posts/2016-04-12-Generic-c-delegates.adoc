= Generic c++ delegates
:hp-tags: c++

blah blah blah

[source,cpp]
----
#include <iostream>
#include <functional>

using namespace std;

template<typename T>
class Delegate;

template<typename Ret, typename ...Args>
class Delegate<Ret(Args...)>
{
	using CallerType = Ret(*)(void*, Args&&...);

public:
	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Delegate create(T* obj)
	{
		cout << "create member" << endl;
		return Delegate{ obj, &memberCaller<T, funcPtr> };
	}

	template<Ret(*funcPtr)(Args...)>
	static Delegate create()
	{
		cout << "create global" << endl;
		return Delegate{ nullptr, &globalCaller<funcPtr> };
	}

	template<typename T,
		//typename = typename enable_if<is_same<Ret, typename result_of<remove_pointer<T>::type(Args&&...)>::type>::value>::type,
		typename = typename enable_if<is_pointer<T>::value>::type>
	static Delegate create(T&& t)
	{
		cout << "create functor" <<  endl;
		return Delegate{ t, &functorCaller<T> };
	}
	
	Ret operator()(Args&&... args)
	{
		return callback(callee, forward<Args>(args)...);
	}
    
    bool operator==(const Delegate& other)
	{
		return callee == other.callee && callback == other.callback;
	}

private:
	void* callee{ nullptr };
	CallerType callback{ nullptr };

private:
	Delegate(void* obj, CallerType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	static Ret memberCaller(void* callee, Args&&... args)
	{
		return (static_cast<T*>(callee)->*funcPtr)(forward<Args>(args)...);
	}

	template<Ret(*funcPtr)(Args...)>
	static Ret globalCaller(void* callee, Args&&... args)
	{
		(void)callee;
		return funcPtr(forward<Args>(args)...);
	}

	template<typename T>
	static Ret functorCaller(void* functor, Args&&... args)
	{
		return (*static_cast<T>(functor))(forward<Args>(args)...);
	}
};

int global(int a, float b)
{
	cout << "in global" << endl;
	return a + static_cast<int>(b);
}

struct Functor
{
	int operator()(int a, float b)
	{
		cout << "in functor" << endl;
		return a + static_cast<int>(b);
	}
};

struct UserStruct
{
	int member(int a, float b)
	{
		cout << "in member" << endl;
		return a + static_cast<int>(b);
	}

	static int staticMember(int a, float b)
	{
		cout << "in static" << endl;
		return a + static_cast<int>(b);
	}
};

int main()
{
	{
		cout << "lambda test" << endl;

		auto lambda = [](int a, float b)->int
		{
			cout << "in lambda" << endl;
			return a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambda) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "lambda with capture test" << endl;

		int toCapture{ 42 };
		auto lambdaWithCapture = [toCapture](int a, float b)->int
		{
			cout << "in lambda with capture" << endl;
			return toCapture + a + static_cast<int>(b);
		};

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&lambdaWithCapture) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "global test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&global>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "functor test" << endl;

		Functor functor;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&functor) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	{
		cout << "member test" << endl;

		UserStruct us;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<UserStruct, &UserStruct::member>(&us) };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// user struct static member test
	{
		cout << "static test" << endl;

		Delegate<int, int, float> d{ Delegate<int, int, float>::create<&UserStruct::staticMember>() };
		cout << d(10, 5.0f) << endl;

		cout << endl;
	}
	
	// function
	{
		cout << "std::funciton test" << endl;

		function<int(int, float)> f{ &global };

		Delegate<int, int, float> d{ Delegate<int, int, float>::create(&f) };
		cout << d(10, 5.0f) << endl;

		cout << endl;

	}

	cin.get();

	return 0;
}
----