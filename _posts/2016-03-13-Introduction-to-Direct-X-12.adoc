= Introduction to DirectX 12
:hp-tags: c++, directx12

Preface.

*1. Main function*

[source,cpp]
----
#include <Windows.h>
#include <wrl/client.h>
#include <dxgi1_4.h>
#include <d3d12.h>
#include <cstdint>
#include <stdexcept>
#include <cmath>
#include <vector>

#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "d3d12.lib")

using namespace std;
using Microsoft::WRL::ComPtr;

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	const LONG width{ 800 };
	const LONG height{ 600 };
	const UINT bufferCount{ 2 };

	HWND hWnd;
	ComPtr<IDXGIFactory4> dxgiFactory;
	ComPtr<IDXGIAdapter3> adapter;
	ComPtr<ID3D12Device> device;
	ComPtr<ID3D12CommandQueue> commandQueue;
	ComPtr<IDXGISwapChain3> swapChain;
	vector<ComPtr<ID3D12Resource>> buffers;
	ComPtr<ID3D12DescriptorHeap> descHeapRtv;
	ComPtr<ID3D12CommandAllocator> commandAlloc;
	ComPtr<ID3D12GraphicsCommandList> commandList;
	ComPtr<ID3D12Fence> fence;
	HANDLE fenceEventHandle;
	
	try
	{
		hWnd = createWindow(width, height);
		dxgiFactory = createFactory();
		adapter = getAdapter(dxgiFactory.Get());
		device = createDevice(adapter.Get());
		commandQueue = createCommandQueue(device.Get());
		swapChain = createSwapChain(width, height, bufferCount, dxgiFactory.Get(), commandQueue.Get(), hWnd);
		buffers = getBuffers(bufferCount, swapChain.Get());
		descHeapRtv = createDescriptoprHeapRTV(device.Get(), bufferCount, buffers);
		commandAlloc = createCommandAllocator(device.Get());
		commandList = createCommandList(device.Get(), commandAlloc.Get());
		fence = createFence(device.Get());
		fenceEventHandle = createFenceEvent();
	}
	catch (runtime_error& err)
	{
		MessageBox(nullptr, err.what(), "Error", MB_OK);
		return 0;
	}

	MSG msg;
	ZeroMemory(&msg, sizeof(msg));

	while(msg.message != WM_QUIT)
	{
		BOOL r{ PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) };
		if(r == 0)
		{
			try
			{
				render(device.Get(), descHeapRtv.Get(), bufferCount, width, height, buffers, commandList.Get(), commandQueue.Get(), swapChain.Get(), fence.Get(), fenceEventHandle, commandAlloc.Get());
			}
			catch (runtime_error& err)
			{
				MessageBox(nullptr, err.what(), "Error", MB_OK);
				return 0;
			}
		}
		else
		{
			DispatchMessage(&msg);
		}
	}

	return 0;
}
----

*2. Create a window*
[source,cpp]
----
HWND createWindow(const LONG width, const LONG height)
{
	WNDCLASSEX wcex;
	ZeroMemory(&wcex, sizeof(wcex)); // 2.1
	wcex.cbSize = sizeof(WNDCLASSEX); // 2.2
	wcex.style = CS_HREDRAW | CS_VREDRAW; // 2.3
	wcex.lpfnWndProc = WndProc; // 2.4
	wcex.cbClsExtra = 0; // 2.5
	wcex.cbWndExtra = 0; // 2.6
	wcex.hInstance = (HMODULE)GetModuleHandle(0); // 2.7
	wcex.hIcon = LoadIcon(NULL, IDI_SHIELD);// nullptr; // 2.8
	wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); // 2.9
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 2.10
	wcex.lpszMenuName = nullptr; // 2.11
	wcex.lpszClassName = "WindowClass"; // 2.12
	wcex.hIconSm = LoadIcon(NULL, IDI_WARNING); // 2.13

	// 2.14
	if (RegisterClassEx(&wcex) == 0)
	{
		throw(runtime_error{ "Error registering window." });
	}

	// 2.15
	RECT rect{ 0, 0, width, height };
	AdjustWindowRectEx(&rect, WS_OVERLAPPEDWINDOW, FALSE, 0);

	// 2.16
	HWND hWnd{ CreateWindowEx(0, "WindowClass", "Hello World", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, rect.right - rect.left, rect.bottom - rect.top, nullptr, nullptr, nullptr, nullptr) };
	if (!hWnd)
	{
		throw(runtime_error{ "Error creating window." });
	}

	ShowWindow(hWnd, SW_SHOW); // 2.17
	
	return hWnd; // 2.18
}
----

We need several simple steps to create a simple window:

 - Register a class for the window
 - Create a window
 - Show a window

To create a window we first need to register a window class with some name. Later we can use this name to create as many windows of the same type as we want.

NOTE: In Windows every UI control is a window. And as you may guess there're a lot of already registered classes for different controls. For example, to create a button we need to use https://msdn.microsoft.com/en-us/library/windows/desktop/bb775943%28v=vs.85%29.aspx[`BUTTON`] class.

To register a window class we need to use a special structure: https://msdn.microsoft.com/en-us/library/windows/desktop/ms633576%28v=vs.85%29.aspx[`WNDCLASS`] or https://msdn.microsoft.com/en-us/library/windows/desktop/ms633577%28v=vs.85%29.aspx[`WNDCLASSEX`]. The difference between them is that the second have some additional functionality (`EX` means extended). I always prefer to use such 'maximal' types so in my example I'll use https://msdn.microsoft.com/en-us/library/windows/desktop/ms633577%28v=vs.85%29.aspx[`WNDCLASSEX`]. This structure have a lot of fields and I will not describe all of them - please refer to documentation.

1. First I clear a structure. If I'll not do it - the struct will be filled with a garbage and we can get a strange behavior if we'll not fill all the fields.

2. Simply a size of the structure. This line always be the same for this type.

3. Window class styles. https://msdn.microsoft.com/en-us/library/windows/desktop/ff729176%28v=vs.85%29.aspx#CS_HREDRAW[`CS_HREDRAW`] and https://msdn.microsoft.com/en-us/library/windows/desktop/ff729176%28v=vs.85%29.aspx#CS_VREDRAW[`CS_VREDRAW`] tells that the window have to be redrawn if movement or size adjustment changes the width or the height of the window.

4. This is a pointer to the function called a *window procedure*. Every action on window send some event and we can intercept this event in this function and react accordingly. This event can be a keyboard key press, for example. Remember this place, I'll return to this function a little bit later.

5. Additional memory for the structure. We're not interested in this.

6. Also some memory. Needs if we're going to create some special type of window. We'll not so leave this field empty.

7. We need to specify where a window procedure I wrote in *#4* resides (in which module). In my example it defined in the same executable as a window. https://msdn.microsoft.com/en-us/library/windows/desktop/ms683199%28v=vs.85%29.aspx[`GetModuleHandle(NULL)`] return us this exe file handle.

8. A handle to a class icon that will be shown in the taskbar. If set `NULL` a default icon will be used. I use https://msdn.microsoft.com/en-us/library/windows/desktop/ms648072%28v=vs.85%29.aspx[`LoadIcon()`] function here. `NULL` as first parameter indicates that standard icon will be used. And the second parameter is icon itself.

9. A handle to the class cursor. If make this `NULL` there will be no cursor at all over the window by default. I want to use a predefined cursor so I pass `NULL` to https://msdn.microsoft.com/en-us/library/windows/desktop/ms648391%28v=vs.85%29.aspx[`LoadCursor()`] function and the name of the cursor.

10. Window background color. Actually it's not necessary here because we'll draw everything with DirectX. But to show how it should be defined I set one of the standard colors. We need `+1` here because... well, because the documentation says so.

11. If we need a window menu we need to provide a name here. I don't need it in my example.

12. The name we gave our window class.

13. Icon that will be shown in the top left corner of the window. I used different icon than in #8.

14. After filling a structure we register our class. The function https://msdn.microsoft.com/en-us/library/windows/desktop/ms633587%28v=vs.85%29.aspx[`RegisterClassEx()`] return `0` in case of failure (in this case I simply show a https://msdn.microsoft.com/en-us/library/windows/desktop/ms645505%28v=vs.85%29.aspx[`MessageBox`] window and finish a program).

15. A window *client area* is an area of the window that doesn't encloses top bar, resize bars, menu etc. We mostly interested in this area when we create different textures or render targets. But when we create a window we specify it's full size. In order to calculate the full size based on the desired size we use https://msdn.microsoft.com/en-us/library/windows/desktop/ms632667%28v=vs.85%29.aspx[`AdjustWindowRectEx()`] function where we pass a desired size, window style (https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600%28v=vs.85%29.aspx#WS_OVERLAPPEDWINDOW[`WS_OVERLAPPEDWINDOW`]) is a style for a window with a status bar, thick frame and others - should be the same as a style for window creation, `FALSE` indicating we're not using any menu, and an extended style (`0` since we're not using any). The function can return `0` in case of failure but I don't care too much in this case. In case of success the rect will hold 'true' size (with borders etc).

16. Finally we're ready to create a window. https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680%28v=vs.85%29.aspx[`CreateWindowEx()`] to the help. The parameters are:

* extended window style - I'm not using any, so `0`.
* name of the window class - remember *#12*.
* the name of the window that will be shown on the window's top bar.
* window style - same as in *#15*.
* `x` position. `CW_USEDEFAULT` says the system to use some default position. In this case `y` will be ignored.
* `y` position - it will be ignored since we used `CW_USEDEFAULT` for the `x` position.
* width of the window. We're using adjusted width (*#15*).
* height of the window. We're using adjusted height (*#15*).
* window's parent. We're creating a single top level window, so no parent here.
* menu or some aditional data. We're not interested.
* a handle to the module associated with a window. Optional. We can specify an executable like we did in *#7* or we can ignore it.
* we can associate any data with a window and pass it in this parameter. This can be handy when we need some data in window procedure, which is a static or global function (*#4*). In this example we're not need any.

The function return a handle to the created window or `NULL` if it can't be created.

17. After we created a window we need to show it. We're using https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548%28v=vs.85%29.aspx[`ShowWindow()`] with a state https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548%28v=vs.85%29.aspx#SW_SHOW[`SW_SHOW`] to display it on the screen.