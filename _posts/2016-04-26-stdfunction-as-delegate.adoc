= std::function as delegate
:hp-tags: c++

After my https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html[previous] post some people asked why I invented what was invented already? Why did I try to write another http://en.cppreference.com/w/cpp/utility/functional/function[`std::function`]? Thought `stl` provides a great way to store functions and call them later it simply not fulfils my requirement - function callbacks should be added and removed runtime. Also the same function shouldn't be added twice. `std::function` doesn't have a comparison operator. Yes, there's http://en.cppreference.com/w/cpp/utility/functional/function/target[`std::function::target()`] method that should return a pointer to the callable type. But I don't know how to use it with member functions. Recall that in order to create a wrapper around a member function we need to bind it with http://en.cppreference.com/w/cpp/utility/functional/bind[`std::bind()`]:


[source,cpp]
----
function<void()> f{ bind(&SomeStruct::someMemberFunc) };
----

And `std::bind()` returns an *unspecified type*. The standard doesn't say it should be comparable. That means that each compiler will have different implementation for this type. Take a look at the following code:

[source,cpp]
----
SomeStruct obj;

// same function binded twice
function<void()> f{ bind(&SomeStruct::someMemberFunc, obj) };
function<void()> f2{ bind(&SomeStruct::someMemberFunc, obj) };

// get the type of underlying callable object
using RetType = decltype(bind(&SomeStruct::someMemberFunc));

auto a = f.target<T>();
auto b = f2.target<T>();

bool b{ a == b }; // false
----

Here I binded the same function of the same object to different wrappers. Obviously this two wrappers should be equal. I can't compare them directly, but I can get the callable objects. With Visual Studio I can compare this objects but the fact that they are different!

Since I can't compare `std::function` objects I decided to use some sort of hashing. Let's look at the example:

[source,cpp]
----
template<void(*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) };
	string hash{ to_string(ptr) };
}
----

I take the pointer to function and convert it to string - now I have unique key which I can compare. The http://en.cppreference.com/w/cpp/language/reinterpret_cast[documentation] says:

> "Any pointer can be converted to any integral type large enough to hold the value of the pointer (e.g. to std::uintptr_t)".

But cplusplus wouldn't be cplusplus if it was so easy. The pointer to member is not usual pointer and `reinterpret_cast` doesn't work for it. I.e. the following code is incorrect:


[source,cpp]
----
template<typename T, void(T::*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) }; // cannot convert to 'uintptr_t'
	string hash{ to_string(ptr) };
}
----

In other words - it's so simple to get a pointer to member as `int` or any other representation, even `void*`. We can do some hack:

[source,cpp]
----
template<typename T, void(T::*funcPtr)()>
void add()
{
	auto ptr = funcPtr;
	void* ptr2 = &ptr; // get address of the pointer
	char arr[sizeof(uintptr_t)];
	memcpy(arr, ptr2, sizeof(uintptr_t)); // copy the contents of pointer (which is the address to the function)
	uintptr_t ptr3 = *(reinterpret_cast<uintptr_t*>(arr)); // cast to necessary type
}
----

It *can* work. But it's not http://stackoverflow.com/a/36837375/1341942[guaranteed]. It looks I should forget about hash string. At least at that moment I don't know how to get string representation of member function robustly.

While I'm searching for the way to hash pointer to member I decided to take the dumbest approach - pass a tag together with data:

[source,cpp]
----
template<void(*funcPtr)()>
void add(const string& tag)
{
}

template<typename T, void(T::*funcPtr)()>
void add(const string& tag)
{
}
----

It's not elegant and it adds some complexity to the code but at least it's robust, haha. Now I can start to implement the `Dispatcher` class (remember https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html[previous post]) with `std::function`.

[source,cpp]
----
template<typename T>
class Dispatcher;

template<typename Ret, typename ...Args>
class Dispatcher<Ret(Args...)>
{
public:
	template<Ret(*funcPtr)(Args...)>
	bool add(const string& tag)
	{
		addImpl(tag, funcPtr);
		return true;
	}

	template<typename T>
	bool add(const string& tag, shared_ptr<T> t)
	{
		addImpl(tag, *t.get());
		return true;
	}

	bool remove(const string& tag)
	{
        auto it = find(tags.begin(), tags.end(), tag);
        if (it == tags.end())
		{
			return false;
		}
        
        auto index{ distance(tags.begin(), it) };
        tags.erase(it);
        
        delegates.erase(delegates.begin() + index);
        
		return true;
	}

	void operator()(Args... args)
	{
		for (auto& delegate : delegates)
		{
			delegate(args...);
		};
	}

private:
	bool addImpl(const string& tag, function<Ret(Args...)> delegate)
	{
		if (find(tags.begin(), tags.end(), tag) != tags.end())
		{
			return false;
		}

		delegates.push_back(delegate);
		tags.push_back(tag);

		return true;
	}
    
private:
	vector<function<Ret(Args...)>> delegates;
    vector<string> tags;
};
----

The `addImpl()` function accepts a `std::function` as a second parameter. In different `add()` functions I call it and pass a callable object which will be converted to `std::function` implicitly. Curious reader already noticed that I didn't provide an implementation for a member function. Why? Because it's not trivial. Let's find out.

[source,cpp]
----
struct UserStruct
{
	int member(int a, float b)
	{
		return a + static_cast<int>(b);
	}
};

UserStruct us;
function<int(int, float)> f{ bind(&UserStruct::member, us, placeholders::_1, placeholders::_2) };
f(5, 10.0f);
----

That's how we bind and call a member function. Have you noticed `std::placeholders`? If we don't know what parameters we'll pass to wrapper - we have to use this stubs. Since we're trying to build "generic" system we choosed to use variadic parameter pack for arguments. Because of this we don't know the number of this placeholder beforehand. And as you maybe guessed we need to generate them!

After some search we can get to this http://en.cppreference.com/w/cpp/utility/functional/is_placeholder[documentation]. it looks like what we need. And even with an example. It says that we can use our own custom placeholder if we'll follow certain rules. Let's try:

[source,cpp]
----
template<size_t>
struct MyPlaceholder{};

namespace std
{
	template<>
	struct is_placeholder<MyPlaceholder<1>> : public integral_constant<size_t, 1>{};
    
    template<>
	struct is_placeholder<MyPlaceholder<2>> : public integral_constant<size_t, 2>{};
}

function<int(int, float)> f{ bind(&UserStruct::member, us, MyPlaceholder<1>{}, MyPlaceholder<2>{}) };
f(5, 10.0f)
---

Wow, it works! But we don't like this enumeration in `std` namespace, do we?

[source,cpp]
----
template<size_t>
struct MyPlaceholder{};

namespace std
{
	template<size_t N>
	struct is_placeholder<MyPlaceholder<N>> : public integral_constant<size_t, N>{};
}

function<int(int, float)> f{ bind(&UserStruct::member, us, MyPlaceholder<1>{}, MyPlaceholder<2>{}) };
f(5, 10.0f)
---

Much better, but now we need to remove placeholder's manual instantiation in `bind()` function. In one of my https://nikitablack.github.io/2016/02/21/Call-a-function-from-the-string-name-and-arguments.html[previous] posts I wrote about http://en.cppreference.com/w/cpp/utility/integer_sequence[integer sequence] and it seems we can use it here too. Let's replace our placeholders with some function-generator:

[source,cpp]
----
template <typename T, typename Ret, size_t... Idx, typename... Args>
auto bindImpl(T* obj, Ret(T::*funcPtr)(Args...), index_sequence<Idx...>)
{
    return bind(funcPtr, obj, getPlaceholder<Idx>()...);
}

function<int(int, float)> f{ bindImpl(&us, &UserStruct::member, index_sequence_for<int, float>{}) };
f(5, 10.0f)
---



[source,cpp]
----
template<size_t>
struct MyPlaceholder{};

namespace std
{
	template<size_t N>
	struct is_placeholder<MyPlaceholder<N>> : public integral_constant<size_t, N>{};
}

template<typename T>
class Dispatcher;

template<typename Ret, typename ...Args>
class Dispatcher<Ret(Args...)>
{
public:
	template<Ret(*funcPtr)(Args...)>
	bool add(const string& tag)
	{
		addImpl(tag, funcPtr);
		return true;
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	bool add(const string& tag, shared_ptr<T> obj)
	{
		addImpl(tag, bindImpl(obj.get(), funcPtr, index_sequence_for<Args...>{}));
		return true;
	}

	template<typename T>
	bool add(const string& tag, shared_ptr<T> t)
	{
		addImpl(tag, *t.get());
		return true;
	}

	bool remove(const string& tag)
	{
        auto it = find(tags.begin(), tags.end(), tag);
        if (it == tags.end())
		{
			return false;
		}
        
        auto index{ distance(tags.begin(), it) };
        tags.erase(it);
        
        delegates.erase(delegates.begin() + index);
        
		return true;
	}

	void operator()(Args... args)
	{
		for (auto& delegate : delegates)
		{
			delegate(args...);
		};
	}

private:
	bool addImpl(const string& tag, function<Ret(Args...)> delegate)
	{
		if (find(tags.begin(), tags.end(), tag) != tags.end())
		{
			return false;
		}

		delegates.push_back(delegate);
		tags.push_back(tag);

		return true;
	}

	template <typename T, size_t... Idx>
	function<Ret(Args...)> bindImpl(T* obj, Ret(T::*funcPtr)(Args...), index_sequence<Idx...>)
	{
		return bind(funcPtr, obj, getPlaceholder<Idx>()...);
	}

	template <size_t N>
	MyPlaceholder<N + 1> getPlaceholder()
	{
		return {};
	}
private:
	vector<function<Ret(Args...)>> delegates;
    vector<string> tags;
};
----