= std::function as delegate
:hp-tags: c++

After my https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html[previous] post some people asked why I invented what was invented already? Why did I try to write another http://en.cppreference.com/w/cpp/utility/functional/function[`std::function`]? Thought `stl` provides a great way to store functions and call them later it simply not fulfils my requirement - function callbacks should be added and removed runtime. Also the same function shouldn't be added twice. `std::function` doesn't have a comparison operator. Yes, there's http://en.cppreference.com/w/cpp/utility/functional/function/target[`std::function::target()`] method that should return a pointer to the callable type. But I don't know how to use it with member functions. Recall that in order to create a wrapper around a member function we need to bind it with http://en.cppreference.com/w/cpp/utility/functional/bind[`std::bind()`]:


[source,cpp]
----
function<void()> f{ bind(&SomeStruct::someMemberFunc) };
----

And `std::bind()` returns an *unspecified type*. The standard doesn't say it should be comparable. That means that each compiler will have different implementation for this type. Take a look at the following code:

[source,cpp]
----
SomeStruct obj;

// same function binded twice
function<void()> f{ bind(&SomeStruct::someMemberFunc, obj) };
function<void()> f2{ bind(&SomeStruct::someMemberFunc, obj) };

// get the type of underlying callable object
using RetType = decltype(bind(&SomeStruct::someMemberFunc));

auto a = f.target<T>();
auto b = f2.target<T>();

bool b{ a == b }; // false
----

Here I binded the same function of the same object to different wrappers. Obviously this two wrappers should be equal. I can't compare them directly, but I can get the callable objects. With Visual Studio I can compare this objects but the fact that they are different!

Since I can't compare `std::function` objects I decided to use some sort of hashing. Let's look at the example:

[source,cpp]
----
template<void(*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) };
	string hash{ to_string(ptr) };
}
----

I take the pointer to function and convert it to string - now I have unique key which I can compare. The http://en.cppreference.com/w/cpp/language/reinterpret_cast[documentation] says:

> "Any pointer can be converted to any integral type large enough to hold the value of the pointer (e.g. to std::uintptr_t)".

But cplusplus wouldn't be cplusplus if it was so easy. The pointer to member is not usual pointer and `reinterpret_cast` doesn't work for it. I.e. the following code is incorrect:


[source,cpp]
----
template<typename T, void(T::*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) }; // cannot convert to 'uintptr_t'
	string hash{ to_string(ptr) };
}
----

In other words - it's so simple to get a pointer to member as `int` or any other representation, even `void*`. We can do some hack:

[source,cpp]
----
template<typename T, void(T::*funcPtr)()>
void add()
{
	auto ptr = funcPtr;
	void* ptr2 = &ptr; // get address of the pointer
	char arr[sizeof(uintptr_t)];
	memcpy(arr, ptr2, sizeof(uintptr_t)); // copy the contents of pointer (which is the address to the function)
	uintptr_t ptr3 = *(reinterpret_cast<uintptr_t*>(arr)); // cast to necessary type
}
----

It *can* work. But it's not http://stackoverflow.com/a/36837375/1341942[guaranteed]. It looks I should forget about hash string. At least at that moment I don't know how to get string representation of member function robustly.

While I'm searching for the way to hash pointer to member I decided to take the dumbest approach - pass a tag together with data:

[source,cpp]
----
template<void(*funcPtr)()>
void add(const string& tag)
{
}

template<typename T, void(T::*funcPtr)()>
void add(const string& tag)
{
}
----

It's not elegant and it adds some complexity to the code but at least it's robust, haha. Now I can start to implement the `Dispatcher` class (remember https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html[previous post]) with `std::function`.









[source,cpp]
----
template<size_t>
struct MyPlaceholder{};

namespace std
{
	template<size_t N>
	struct is_placeholder<MyPlaceholder<N>> : public integral_constant<size_t, N>{};
}

template<typename T>
class Dispatcher;

template<typename Ret, typename ...Args>
class Dispatcher<Ret(Args...)>
{
public:
	template<Ret(*funcPtr)(Args...)>
	bool add(const string& tag)
	{
		addImpl(tag, funcPtr);
		return true;
	}

	template<typename T, Ret(T::*funcPtr)(Args...)>
	bool add(const string& tag, shared_ptr<T> obj)
	{
		addImpl(tag, bindImpl(obj.get(), funcPtr, index_sequence_for<Args...>{}));
		return true;
	}

	template<typename T>
	bool add(const string& tag, shared_ptr<T> t)
	{
		addImpl(tag, *t.get());
		return true;
	}

	bool remove(const string& tag)
	{
        auto it = find(tags.begin(), tags.end(), tag);
        if (it == tags.end())
		{
			return false;
		}
        
        auto index{ distance(tags.begin(), it) };
        tags.erase(it);
        
        delegates.erase(delegates.begin() + index);
        
		return true;
	}

	void operator()(Args... args)
	{
		for (auto& delegate : delegates)
		{
			delegate(args...);
		};
	}

private:
	bool addImpl(const string& tag, function<Ret(Args...)> delegate)
	{
		if (find(tags.begin(), tags.end(), tag) != tags.end())
		{
			return false;
		}

		delegates.push_back(delegate);
		tags.push_back(tag);

		return true;
	}

	template <typename T, size_t... Idx>
	function<Ret(Args...)> bindImpl(T* obj, Ret(T::*funcPtr)(Args...), index_sequence<Idx...>)
	{
		return bind(funcPtr, obj, getPlaceholder<Idx>()...);
	}

	template <size_t N>
	MyPlaceholder<N + 1> getPlaceholder()
	{
		return {};
	}
private:
	vector<function<Ret(Args...)>> delegates;
    vector<string> tags;
};
----