= std::function as delegate
:hp-tags: c++

After my https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html[previous] post some people asked why I invented what was invented already? Why did I try to write another http://en.cppreference.com/w/cpp/utility/functional/function[`std::function`]? Thought `stl` provides a great way to store functions and call them later it simply not fulfils my requirement - function callbacks should be added and removed runtime. Also the same function shouldn't be added twice. `std::function` doesn't have a comparison operator. Yes, there's http://en.cppreference.com/w/cpp/utility/functional/function/target[`std::function::target()`] method that should return a pointer to the callable type. But I don't know how to use it with member functions. Recall that in order to create a wrapper around a member function we need to bind it with http://en.cppreference.com/w/cpp/utility/functional/bind[`std::bind()`]:


[source,cpp]
----
function<void()> f{ bind(&SomeStruct::someMemberFunc) };
----

And `std::bind()` returns an *unspecified type*. The standard doesn't say it should be comparable. That means that each compiler will have different implementation for this type. Take a look at the following code:

[source,cpp]
----
SomeStruct obj;

// same function binded twice
function<void()> f{ bind(&SomeStruct::someMemberFunc, obj) };
function<void()> f2{ bind(&SomeStruct::someMemberFunc, obj) };

// get the type of underlying callable object
using RetType = decltype(bind(&SomeStruct::someMemberFunc));

auto a = f.target<T>();
auto b = f2.target<T>();

bool b{ a == b }; // false
----

Here I binded the same function of the same object to different wrappers. Obviously this two wrappers should be equal. I can't compare them directly, but I can get the callable objects. With Visual Studio I can compare this objects but the fact that they are different!

Since I can't compare `std::function` objects I decided to use some sort of hashing. Let's look at the example:

[source,cpp]
----
template<void(*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) };
	string hash{ to_string(ptr) };
}
----

I take the pointer to function and convert it to string - now I have unique key which I can compare. The http://en.cppreference.com/w/cpp/language/reinterpret_cast[documentation] says:

> "Any pointer can be converted to any integral type large enough to hold the value of the pointer (e.g. to std::uintptr_t)".

But cplusplus wouldn't be cplusplus if it was so easy. The pointer to member is not usual pointer and `reinterpret_cast` doesn't work for it. I.e. the following code is incorrect:


[source,cpp]
----
template<void(*funcPtr)()>
void add()
{
	uintptr_t ptr{ reinterpret_cast<uintptr_t>(funcPtr) };
	string hash{ to_string(ptr) };
}
----