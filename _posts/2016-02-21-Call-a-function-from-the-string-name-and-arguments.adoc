= Call a function from the string name and arguments
:hp-tags: c++

Recently I had an interesting task on my work - a cheat system for a game. All the system should do is to call functions during apllication run with console commands (game console). Functions can accept different number of arguments. In other words the system should be able to call a function:

[source,cpp]
----
bool foo(int, float);
----

with a console command:

----
foo 42 10.5
----

I'll not describe in this post how I'm receiving this string as well how I'm parsing it. Let's assume that I'm operating with a vector of strings where the first element - the name of the function and the rest - function parameters. So at some point I have this vector:

[source,cpp]
----
{ "foo", "42", "10.5" }
----

And I need somehow call a correct function and pass a correct number of parameters with a correct type.

There's no way to call an unknown function just knowing it's name in C++. At least I don't know such a way. So in order to call something I need first register it. By registration I mean storing of a function pointer together with some string - it's name. The `std::map` is a good candidate for that. But I don't store raw pointer. Instead, I have a wrapper class, called `Cheat`, for my function. Cheat is a templated class with function arguments types as template parameters. It's declaration looks like this:

[source,cpp]
----
template<typename ...Args>
class Cheat : public CheatBase
{
	Cheat(void(* const funcPtr)(Args...)) : func{ funcPtr }
	{

	}
	// ...
private:
	void(* const func)(Args...); # <1>
}
----

Here `func` is our pointer to function which we need to call later.

NOTE: For simplcity the only functions that can be passed are global or static functions or lambdas without capture (such a lambda can be casted to function pointer). But member functions can be added with additional template argument and a little bit of code.

As you already guessed, it's not possible to store instances of this class directly in `std::map` because for every new function with a new signature the `Cheat` class type will be different. For example `Cheat<int>` for the function taking one `int` parameter and  `Cheat<int, float>` for the function takind an `int` and a `float`. Therefore they all should have common base class. It's very simple:

[source,cpp]
----
class CheatBase
{
public:
	virtual ~CheatBase() {};
	virtual bool call(const std::vector<std::string>& cheatParams) = 0;
};
----

It's an abstract class with pure virtual function which takes an array of parameters as strings which will be converted to corresponding types.

NOTE: Instead of `call()` function we could use `operator()` function.

Now we can create cheats like this:

[source,cpp]
----
CheatBase* cheat{new Cheat<int, float>};
----

Or with a helper:


[source,cpp]
----
template<typename ...Args>
std::shared_ptr<CheatBase> makeCheat(void(*funcPtr)(Args... arguments))
{
	return std::make_shared<Cheat<Args...>>(funcPtr);
}

myMap["foo"] = makeCheat(&foo);
----

Thanks to type deduction I don't need to type template parameters for the function.

NOTE: Here for simplcity I'm passing arguments by value. The better approach is to use http://en.cppreference.com/w/cpp/utility/forward[perfect forwarding].

Btw, the strange looking `template<typename ...Args>` is called a http://en.cppreference.com/w/cpp/language/parameter_pack[parameter pack]. And together with templated class it's called *variadic template*. This is one of the amazing features of modern C++. I highly recommend you to investigate this topic. It's really really cool! I can recommend for the start this great posts - http://eli.thegreenplace.net/2014/variadic-templates-in-c/[one], https://jguegant.github.io/blogs/tech/thread-safe-multi-type-map.html[two].

That was pretty standard and boring. And now the interesting part - the actual cheat implementation!

The heart of the `Cheat` class is a `call()` function override:

[source,cpp]
----
bool call(const std::vector<std::string>& cheatParams) override
{
	if (sizeof...(Args) != cheatParams.size()) # <1>
	{
		// if a number of passed arguments is not equal to a number of parameters declared in cheat return false - this is an error.
		return false;
	}

	callHelper(cheatParams, std::index_sequence_for<Args...>{});

	return true;
}
----
<1> http://en.cppreference.com/w/cpp/language/sizeof...[`sizeof...(Args)`] return a number of arguments of parameter pack that was used during `Cheat` class instantiation. This operator also can be used during compile-time.

First we check that we passed correct number of arguments. And all the magic happens in `callHelper()` function. Don't think about `index_sequence_for<Args...>` for now, we'll come to this later.

[source,cpp]
----
template <std::size_t... Idx>
void callHelper(const std::vector<std::string>& strArgs, std::index_sequence<Idx...>)
{
	(func)(fromString<Args>(getStringFromArray<Idx>(strArgs))...);
}
----

Wow! Looks scary. Actually, not. `callHelper()` is a variadic templated function which accepts a vector with string arguments which should be converted to appropriated types and a http://en.cppreference.com/w/cpp/utility/integer_sequence[sequence of integers]. What are this integers? Why? I can better explain it if we'll start from the end. Let's stick to `foo(int, type)` function signature to the rest of this post. In the very end I need to call this function with correct parameters, for example:

[source,cpp]
----
foo(42, 10.5);
----

But I have only vector of strings `{"42", "10.5"}`. I need some conversion function that will return a correct type from the corresponding string. Moreover I need to call this function several times - once for each parameter:

[source,cpp]
----
foo(fromString("42"), fromString("10.5"));
----

In order to convert to correct type `fromString()` we'll use templated function with overload for *every* type I need. For the case with `int` the overload is:

[source,cpp]
----
template<typename T>
typename std::enable_if<std::is_same<T, int>::value, int>::type fromString(const std::string& str)
{
	return std::stoi(str);
}
----

For the `float` it's similar. The http://en.cppreference.com/w/cpp/language/sfinae[SFINAE] technique is used here. Good explanation can be found http://www.bfilipek.com/2016/02/notes-on-c-sfinae.html[in this awesome blog]. In shorts - `std::is_same<T, int>::value` return `true` if `T` is `int` and `false` overwise. Next, `std::enable_if<true, int>::type` will return `int` and `std::enable_if<false, int>::type` simply will not compile. That mean we'll get a *compile time* error if we'll use a type for which there's no overload exist! Awesome, tis types of errors are much much better than exception during runtime.

Knowing all this we can create a first version of our `callHelper()` function:

[source,cpp]
----
void callHelper(const std::vector<std::string>& strArgs)
{
	foo(fromString<Args>(getStringFromArray(strArgs))...);
}
----

`Args` is a parameter pack and `fromString<Args>()...` is a parameter pack expansion. For my case with `int` and `float` this will become:
----
void callHelper(const std::vector<std::string>& strArgs)
{
	foo(fromString<int>(getStringFromArray(strArgs)), fromString<float>(getStringFromArray(strArgs)));
}
----
I already have two `fromString()` overloads for my types. Now the trick is to pass the correct string, i.e. implement `getStringFromArray()` function. The naive approach would be to remove this function completely and just use strArgs together with some counter which will be incremented every time I access vector element:

[source,cpp]
----
void callHelper(const std::vector<std::string>& strArgs)
{
	size_t counter{0};
	foo(fromString<int>(strArgs[counter++], fromString<float>(strArgs[counter++]));
}
----

Unfortunately this not works. The C++ standard does not specify the order of function arguments eveluation. That means it can differ from compiler to compiler. And it possible to have this setup:

[source,cpp]
----
foo(fromString<int>(strArgs[1]), fromString<float>(strArgs[0])); // will pass wrong arguments
----

I need instead robust solution that will work with all compilers. No imagine if Iâ€™ll rewrite callHelper slightly:

[source,cpp]
----
void callHelper(const std::vector<std::string>& strArgs)
{
	foo(fromString<int>(getStringFromArray<0>(strArgs)), fromString<float>(getStringFromArray<1>(strArgs)));
}
----

Notice the extra template parameters <0> and <1>. And the definition of `getStringFromArray()` function:

[source,cpp]
----
template <std::size_t N>
std::string getStringFromArray(const std::vector<std::string>& strArgs)
{
	return strArgs[N];
}
----

Now no matter what is the order this function will return correct string, since `<0>` and `<1>` template paameters will always be in right order. The next question is how to ensure this order of integers? And here http://en.cppreference.com/w/cpp/utility/integer_sequence[sequence of integers] comes to the resque. For the moment let's not think how we create one but see what happens when the function receives it:

[source,cpp]
----
template <std::size_t... Idx>
void callHelper(const std::vector<std::string>& strArgs, std::index_sequence<Idx...>)
{
	(func)(fromString<Args>(getStringFromArray<Idx>(strArgs))...);
}
----

The function itself templated with http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter[non-type] parameter pack, in simple words the template parameters are integers with number equal to the number of `Args` (class parameter pack). This `Idx` sequence will be deduced from the function second nameless argument `std::index_sequence<Idx...>`. So the only reason for this second argument is to provide compile-time integers. In the function's body the two parameter packs - `Args` and `Idx` will be expanded together simultaneously. In my case everything will be expanded to:

[source,cpp]
----
template <0, 1>
void callHelper(const std::vector<std::string>& strArgs, std::index_sequence<0, 1>)
{
	(func)(fromString<int>(getStringFromArray<0>(strArgs)), fromString<float>(getStringFromArray<1>(strArgs)));
}
----

Amazing, isn't it?

There's last piece of puzzle left - how to get integer sequence? In C++11 this should be done manually. https://ngathanasiou.wordpress.com/2015/02/19/compile-time-integer-sequences/[Here] the great explanation how to do this. But happy owners of c++14 compliant compiler can use http://en.cppreference.com/w/cpp/utility/integer_sequence[ standard sequence of integers]. I'll put here explanation directly from the link:

__
A helper alias template std::index_sequence_for is defined to convert any type parameter pack into an index sequence of the same length.
__

