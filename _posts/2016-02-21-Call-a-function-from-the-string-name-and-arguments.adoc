= Call a function from the string name and arguments
:hp-tags: c++

Recently I had an interesting task on my work - creation of a cheat system. All the system should do is to call functions during apllication run (in my case - a game) through a console command (game console). Functions can accept different number of arguments. In simple words the system should be able to call a function:

[source,cpp]
----
bool foo(int, float);
----

with a console command:
----
foo 42 10.5
----
I'll not describe in this post how I'm receiving this string as well how I'm parsing it. Let's assume that I'm operating with a vector of strings where the first element - the name of the function and the rest - function parameters:
[source,cpp]
----
{ "foo", "42", "10.5" }
----
Having this I need somehow call a correct function and pass a correct number of parameters with a correct type.

There's no way to call an unknown function by it's name. At least I don't know such a way. So in order to call something I need first register it. I have a wrapper class for my function and a helper to create an instance of it:
[source,cpp]
----
template<typename ...Args>
std::shared_ptr<CheatBase> makeCheat(void(*funcPtr)(Args... arguments))
{
	return std::make_shared<Cheat<Args...>>(funcPtr);
}
----
The returned `CheatBase` (more on this later) is that wrapper I wrote about. And the registration is very simple - I store this cheat in `std::map` where the key is the name of the cheat:
----
myMap["foo"] = makeCheat(&foo);
----
Thanks to type deduction I don't need to provide template parameters for the function.

NOTE: Here for simplcity I'm passing arguments by value. The better approach is to use http://en.cppreference.com/w/cpp/utility/forward[perfect forwarding]

That was pretty standard and boring. And now the interesting part - the actual cheat implementation. Since I'm having a deal with functions with different signatures and I need to store them somehow and somewhere I can't just use raw function pointers or http://en.cppreference.com/w/cpp/utility/functional/function[std::function] - every object will have a differnt type, like `std::function<bool()>` or `std::function<bool(int, float)>` etc. I need a base class or interface which I'll operate on:
[source,cpp]
----
class CheatBase
{
public:
	virtual ~CheatBase() {};
	virtual bool call(const std::vector<std::string>& cheatParams) = 0;
};
----
It's an abstract class with pure virtual function which takes an array of parameters as strings which will be converted to corresponding types. The concrete class is a templated class ans since I don't know the number of arguments before I'll use http://en.cppreference.com/w/cpp/language/parameter_pack[variadic templates]:
[source,cpp]
----
template<typename ...Args>
class Cheat : public CheatBase
{
	// implementation
private:
	void(* const func)(Args...); # <1>
}
----
<1> The only data member is a pointer to a function which I need to call.

NOTE: For simplcity I'm the only functions that can be passed are global or static functions or lambdas without capture (such a lambda can be casted to function pointer). But member functions can be edded with additional template argument and a little code.

The function pointer is passed in cheat constructor:
[source,cpp]
----
Cheat(void(* const funcPtr)(Args...)) : func{ funcPtr }
{
}
----

The second public method is `call` override:

[source,cpp]
----
bool call(const std::vector<std::string>& cheatParams) override
{
	if (sizeof...(Args) != cheatParams.size()) # <1>
	{
		// if a number of passed arguments is not equal to a number of parameters declared in cheat return false - this is an error.
		return false;
	}

	callHelper(cheatParams, std::index_sequence_for<Args...>{});

	return true;
}
----
<1> http://en.cppreference.com/w/cpp/language/sizeof...[`sizeof...(Args)`] return a number of arguments of parameter pack. This operator also can be used during compile-time.

NOTE: Instead of `call()` function I could use `operator()()`.

All magic happens in `callHelper()` function.

[source,cpp]
----
template <std::size_t... Idx>
void callHelper(const std::vector<std::string>& strArgs, std::index_sequence<Idx...>)
{
	(func)(fromString<Args>(getStringFromArray<Idx>(strArgs))...);
}

template <std::size_t N>
std::string getStringFromArray(const std::vector<std::string>& strArgs)
{
	return strArgs[N];
}
----
`callHelper()` is a variadic templated function which accepts a vector with string arguments that should be converted to appropriated type and a http://en.cppreference.com/w/cpp/utility/integer_sequence[sequence of integers]. What are this integers? Why?
