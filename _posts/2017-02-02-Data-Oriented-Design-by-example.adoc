= Data Oriented Design by example
:hp-tags: c++, dod

The last couple of years interesting but not so popular paradigm appears more often. I'm talking about *Data Oriented Design* (*DOD*). If you're searching for a job that involves high-performance calculations be ready to hear corresponding questions. And I was surprised knowing that some my colleagues never hear about the approach and after short discussion stayed skeptical. In this article I'll try to compare traditional *OOP* approach with *DOD* on a real world example.

===== What is DOD?

This post is an attempt to compare different programming approach without trying to explain them. I assume you should know what we'll talk about. There're a lot of articles on the web about the subject. https://fuzzyreflection.com/2016/07/14/maximizing-code-performance-by-thinking-data-first-part-1/[This one] is good. https://www.youtube.com/watch?v=rX0ItVEVjHc[This video] from *CppCon* also is a _must see_.But in layman's terms, *DOD* is a way to work with data in _cache friendly_ manner. Better see an example:

[source,cpp]
----
#include <chrono>
#include <iostream>
#include <vector>

using namespace std;
using namespace std::chrono;

struct S
{
	uint64_t u;
	double d;
	int i;
	float f;
};

struct Data
{
	vector<uint64_t> vu;
	vector<double> vd;
	vector<int> vi;
	vector<float> vf;
};

int test1(S const & s1, S const & s2)
{
	return s1.i + s2.i;
}

int test2(Data const & data, size_t const ind1, size_t const ind2)
{
	return data.vi[ind1] + data.vi[ind2];
}

int main()
{
	size_t const N{ 30000 };
	size_t const R{ 10 };

	vector<S> v(N);
	Data data;
	data.vu.resize(N);
	data.vd.resize(N);
	data.vi.resize(N);
	data.vf.resize(N);

	int result{ 0 };

	cout << "test #1" << endl;
	for (uint32_t i{ 0 }; i < R; ++i)
	{
		auto const start{ high_resolution_clock::now() };
		for (size_t a{ 0 }; a < v.size() - 1; ++a)
		{
			for (size_t b{ a + 1 }; b < v.size(); ++b)
			{
				result += test1(v[a], v[b]);
			}
		}
		cout << duration<float>{ high_resolution_clock::now() - start }.count() << endl;
	}

	cout << "test #2" << endl;
	for (uint32_t i{ 0 }; i < R; ++i)
	{
		auto const start{ high_resolution_clock::now() };
		for (size_t a{ 0 }; a < v.size() - 1; ++a)
		{
			for (size_t b{ a + 1 }; b < v.size(); ++b)
			{
				result += test2(data, a, b);
			}
		}
		cout << duration<float>{ high_resolution_clock::now() - start }.count() << endl;
	}
    
    return result;
}
----

The second test runs faster by 30% (in VS2017 and gcc7.0.1). But why?

The size of the `S` struct is `24` bytes. My CPU (Intel Core i7) have `32KB` L1 cache for each core with `64B` cache line. That means that when we're requesting data from the main memory one cache line can hold only two full `S` structs at most. In the first test we're reading only one `int` field, i.e. in the best case scenario one cache line can hold only two `S::i` (ok, sometimes three). In the second test we're reading similar `int` but from the vector of integers. `std::vector` guarantees sequentiality of the data it holds. That means that one cache line can hold up to `16` (`64KB` / `sizeof(int)` = `16`) values we need. Obviously, we're communicating with the RAM less often. And it's known that memory operations are the bottleneck in modern CPUs.

===== What about real life?

The example above clearly shows the benefits of *SoA* (**S**truct **o**f **A**rrays) vs *AoS* (**A**rray **o**f **S**tructures). But this example was from the _Hello World_ category, i.e. it's very far from real world applications. In reality, the code has lots of dependencies and specific data which probably will not give such performance increase. One more thing - if in our example we'll read all fields of the struct there will be no difference in speed.

In order to understand possibility to apply *DOD* I decided to write more or less complex program with both (*OOP* and *DOD*) approaches. Let it be a 2d rigid body simulation - we'll create *N* convex polygons with different parameters - mass, speed etc. - and we'll see how many such objects we can simulate staying on 30 fps.

===== Array of Structures
*Initial program*

Source code for this version can be found in https://github.com/nikitablack/cpp-tests/tree/b672ca106ef5c88a23d7f8e2a909e07d6e54ca4a/data_oriented/oop/oop[this] commit. Now we briefly run through the code.

For simplicity reasons the program is written in Visual Studio for Windows and uses DirectX11 for rendering.

NOTE: I'm using the latest VS2017 and some features of c++17, namely http://en.cppreference.com/w/cpp/utility/optional[std::optional]. Intersection detector takes two objects and returns by value a struct with intersection information - normal, penetration depth. Previously I used a boolean flag inside that structure that showed was there an intersection at all. With the new `std::optional` I got rid of that flag and the code became more clear.

The purpose of this article is to show some numbers on CPU so we'll not discuss graphics.

The `Shape` class which represents physical body looks like this (simplified):

[source,cpp]
----
class Shape
{
public:
	math::Vec2 position{ 0.0f, 0.0f };
	math::Vec2 velocity{ 0.0f, 0.0f };
	math::Vec2 overlapResolveAccumulator{ 0.0f, 0.0f };
	float massInverse;
	math::Color color;
	std::vector<math::Vec2> vertices;
	math::Bounds bounds;
};
----

* I believe `position` and `velocity` fields don't need a discussion
* vertices — a random number of polygon vertices
* bounds — shape's bounding box. Used for broad collision detection
* massInverse — one over mass (`1 / m`). We'll use only this value so no need to keep mass itself
* color — used for rendering but stored in shape
* overlapResolveAccumulator - see below.

NOTE: From the structure, it's already seen that `color` not used for calculations at all. But steel takes place in the cache line.

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/dod_by_example/1.png["Teapot", 400]

Когда треугольник пересекается с фигурой a, мы должны подвинуть его немного, чтобы исключить наложение фигур друг на друга. Также мы должны пересчитать bounds. Но после перемещения треугольник пересекает другую фигуру — b, и мы снова должны переместить его и снова пересчитать bounds. Заметьте, что после второго перемещения треугольник снова окажется над фигурой a. Чтобы избежать повторных вычислений мы будем хранить величину, на которую нужно переместить треугольник в специальном аккумуляторе — overlapResolveAccumulator — и позже будем перемещать фигуру на это значение, но только один раз.

Сердце нашей программы — это метод ShapesApp::update(). Вот его упрощенный вариант:

[source,cpp]
----
void ShapesApp::update(float const dt)
{
	float const dtStep{ dt / NUM_PHYSICS_STEPS };
	for (uint32_t s{ 0 }; s < NUM_PHYSICS_STEPS; ++s)
	{
		updatePositions(dtStep);

		for (size_t i{ 0 }; i < _shapes.size() - 1; ++i)
		{
			for (size_t j{ i + 1 }; j < _shapes.size(); ++j)
			{
				CollisionSolver::solveCollision(_shapes[i].get(), _shapes[j].get());
			}
		}
	}
}
----

Каждый кадр мы вызываем ShapesApp::updatePositions() метод, который меняет положение каждой фигуры и рассчитывает новый Shape::bounds. Затем мы проверяем каждую фигуру с каждой другой на пересечение — CollisionSolver::solveCollision(). Я использовал Separating Axis Theorem (SAT). Все эти проверки мы делаем NUM_PHYSICS_STEPS раз. Эта переменная служит нескольким целям — во-первых, физика получается более стабильная, во-вторых, она ограничивает количество объектов на экране. с++ быстр, очень быстр, и без этой переменной у нас будут десятки тысяч фигур, что замедлит отрисовку. Я использовал NUM_PHYSICS_STEPS = 20

На моем стареньком ноутбуке эта программа рассчитывает 500 фигур максимум, перед тем, как fps начинает падать ниже 30. Фуууу, всего 500???! Согласен, немного, но не забывайте, что каждый кадр мы повторяем рассчеты 20 раз.

Думаю, что стоит разбавить статью скриншотами, поэтому вот:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/dod_by_example/2.png["Teapot", 600]

*Оптимизация номер 1. Spatial Grid*

Я упоминал, что хочу провести тесты на как можно более приближенной к реальности программе. То, что мы написали выше в реальности не используется — проверять каждую фигуру с каждой ооочень медленно. Для ускорения рассчетов обычно используется специальная структура. Предлагаю использовать обыкновенную 2d сетку — я назвал ее Grid — которая состоит из NxM ячеек — Cell. В начале рассчетов мы будем записывать в каждую ячейку объекты, которые находятся в ней. Тогда нам нужно будет всего лишь пробежаться по всем ячейкам и проверить пересечения нескольких пар объектов. Я неоднократно использовал этот подход в релизах и он зарекомедовал себя — пишется очень быстро, легко отлаживается, прост в понимании.

Коммит второй версии программы можно посмотреть https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx[здесь]. Появился новый класс Grid и немного изменился метод ShapesApp::update() — теперь он вызывает методы сетки для проверки пересечений.

Эта версия держит уже 8000 фигур при 30 fps (не забываем про 20 итераций в каждом кадре)! Пришлось уменьшить фигуры в 10 раз, чтобы они поместились в окне.

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/dod_by_example/3.png["Teapot", 600]

*Оптимизация номер 2. Multithreading.*

Сегодня, когда даже на телефонах устанавливаются процессоры с четырьмя ядрами, игнорировать многопоточность просто глупо. В этой, последней, оптимизации мы добавим пул потоков и разделим основные задачи на равные таски. Так, например, метод ShapesApp::updatePositions, который раньше пробегал по всем фигурам, устанавливая новую позицию и пересчитывая bounds, теперь пробегает только по части фигур, уменьшая, тем самым, нагрузку на одно ядро. Класс пула был честно скопипастен отсюда. В тестах я использую четыре потока (считая основной). Готовую версию можно найти https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx[здесь].

Разделение основных задач добавило немного головной боли. Так например, если фигура пересекает границу ячейки в сетке, то она будет находится одновременно в нескольких ячейках:

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/dod_by_example/4.png["Teapot", 400]

Здесь фигура a находится в одной ячейке, тогда как b сразу в четырех. Поэтому доступ к этим ячейкам необходимо синхронизировать. Также нужно синхронизировать доступ к некоторым полям класса Shape. Для этого мы добавили std::mutex в Shape и Cell.

Запустив эту версию я могу наблюдать 13000 фигур при 30 fps. Для такого количества объектов пришлось увеличить окно! И снова — в каждом кадре мы повторяем симуляцию 20 раз.

image::https://raw.githubusercontent.com/nikitablack/articles_stuff/master/dod_by_example/5.png["Teapot", 400]

===== Structure of Arrays

*Первая версия программы*

То, что мы писали выше я называю традиционным подходом — я пишу такой код много лет и читаю, в основном, похожий код. Но теперь мы убем стуктуру Shape и посмотрим — сможет ли эта небольшая модификация повлиять на производительность. Ко всеобщей радости рефакторинг оказался не сложным, даже тривиальным. Вместо Shape мы будем использовать структуру с векторами:

[source,cpp]
----
struct ShapesData
{
	std::vector<math::Vec2> positions;
	std::vector<math::Vec2> velocities;
	std::vector<math::Vec2> overlapAccumulators;
	std::vector<float> massesInverses;
	std::vector<math::Color> colors;
	std::vector<std::vector<math::Vec2>> vertices;
	std::vector<math::Bounds> bounds;
};
----

И передаем мы эту структуру так `solveCollision(struct ShapesData & data, std::size_t const indA, std::size_t const indB);`. Т.е. вместо конкретных фигур передаются их индексы и в методе из нужных векторов берутся нужные данные.

https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx[Эта версия программы] выдает 500 фигур при 30 fps, т.е. не отличается от самой первой версии. Связано это с тем, что измерения проводятся на малом количестве данных и к тому же самый тяжелый метод использует почти все поля структуры.

Далее без картинок, т.к. они точно такие же, как были ранее.

*Оптимизация номер 1. Spatial Grid*

Все как и раньше, меняем только AoS на SoA. Код здесь. Результат лучше, чем был ранее — 9500 фигур (было 8000), т.е. разница в производительности около 15%.

*Оптимизация номер 2. Multithreading.*

Снова берем старый код, меняем структуры и получаем 15000 фигур при 30 fps. Т.е. прирост производительности около 15%. Исходный код финальной версии лежит https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx[здесь].

===== Заключение

Изначально код писался для себя с целью проверить различные подходы, их производительность и удобство. Как показали результаты, небольшое изменение в коде может дать довольно ощутимый прирост. А может и не дать, может быть даже наоборот — производительность будет хуже. Так например, если нам нужна всего один экземпляр, то используя стандартный подход мы прочитаем его из памяти только один раз и будем иметь доступ ко всем полям. Используя же структуру векторов, мы вынуждены будем запрашивать каждое поле индивидуально, имея cache-miss при каждом запросе. Плюс ко всему немного ухудшается читабельность и усложняется код. 

Поэтому однознано ответить — стоит ли переходить на новую парадигму всем и каждому — невозможно. Когда я работал в геймдеве над игровым движком, 10% прироста производительности — внушительная цифра. Когда я писал пользовательские утилиты типа лаунчера, то применение DOD подхода вызвало бы только недоумение коллег. В общем, профилируйте, измеряйте и делайте выводы сами :).