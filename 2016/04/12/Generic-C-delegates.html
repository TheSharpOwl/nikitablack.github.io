<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Generic C++ delegates</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="//nikitablack.github.io/themes/Roon/favicon.ico">

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:400,700,400italic,700italic|Open+Sans:400italic,700italic,700,400">
    <link rel="stylesheet" type="text/css" href="//nikitablack.github.io/themes/Roon/assets/css/screen.css?v=1.0.0" />

    <link rel="canonical" href="https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html" />
    
    <meta property="og:site_name" content="Simply about complex" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Generic C++ delegates" />
    <meta property="og:description" content="I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that..." />
    <meta property="og:url" content="https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html" />
    <meta property="article:published_time" content="2016-04-11T22:00:00.000Z" />
    <meta property="article:modified_time" content="2016-04-20T13:29:27.160Z" />
    <meta property="article:tag" content="c++" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Generic C++ delegates" />
    <meta name="twitter:description" content="I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that..." />
    <meta name="twitter:url" content="https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html" />
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Simply about complex",
    "author": {
        "@type": "Person",
        "name": "nikitablack",
        "image": "https://avatars.githubusercontent.com/u/6390092?v=3",
        "url": "undefined/author/undefined",
        "sameAs": "https://nikitablack.github.io"
    },
    "headline": "Generic C++ delegates",
    "url": "https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html",
    "datePublished": "2016-04-11T22:00:00.000Z",
    "dateModified": "2016-04-20T13:29:27.160Z",
    "keywords": "c++",
    "description": "I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that..."
}
    </script>

    <meta name="generator" content="Ghost ?" />
    <link rel="alternate" type="application/rss+xml" title="Simply about complex" href="https://nikitablack.github.io/rss" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
</head>
<body class="post-template tag-c  noimage">

    


    <article role="main" class="">
        <header>
            <a href="https://nikitablack.github.io" id="home_link">Â«</a>
            <div class="meta"><time datetime="2016-04-12"><a href="/2016/04/12/Generic-C-delegates.html">April 12, 2016</a></time> <span class="count" id="js-reading-time"></span></div>
            <h1>Generic C++ delegates</h1>
        </header>

        <div class="text" id="js-post-content">
            <div class="paragraph">
<p>I like module programming - the style where each separate part of the functionality knows nothing about any other part. But the modules need to communicate with each other somehow. We can pass callbacks to each other but in that case we can create dependencies - for example, a pointer to member function in C++ looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int(SomeClass::*ptr)(float);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here <code>ptr</code> is an actual pointer and <code>SomeClass</code> is the name of the class - owner of this function. As you can imagine, if some class needs to accept a function pointer to another class, then using raw function pointers creates a coupling between them. We can use global or static functions - in that case we don&#8217;t need to specify a class name (because there&#8217;s no one). But using this types of functions will complicate the code.</p>
</div>
<div class="paragraph">
<p>The problem can be solved if instead of passing function pointers we&#8217;ll pass some generic wrapper - a delegate. Later this wrapper can be called and a call will be delegated to the actual function which delegate wraps. Sounds easy, right? And in fact it&#8217;s easy and there many many ready solutions. My favorites are <a href="http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates">The Impossibly Fast Delegates</a>, <a href="https://blog.molecular-matters.com/2011/09/19/generic-type-safe-delegates-and-events-in-c">Generic type-safe delegates</a> and <a href="http://blog.coldflake.com/posts/C++-delegates-on-steroids/">Delegates On Steroids</a>. And basically my implementation is a mix of aforementioned code with small additions. So, let&#8217;s start.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s found how can we pass a function and call it later. One way is to pass a function pointer as a function argument, store this pointer and call it later. In following example I&#8217;m not storing it but call immediately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int foo(int(*funcPtr)(int))
{
  return funcPtr(10);
}

int test(int a)
{
  return a;
}

foo(&amp;test);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is to pass function pointer as <a href="http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">non-type template parameter</a>. In this case we don&#8217;t need to keep a pointer - the whole function was created around specified pointer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;int(*FuncPtr)(int)&gt;
int foo()
{
  return FuncPtr(10);
}

int test(int a)
{
  return a;
}

foo&lt;&amp;test&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>But which us better? What to use? Of cource there&#8217;s no answer. It depends. If you don&#8217;t know before which function you need to use as a callback, then passing a function pointer is the only option. But if you know, then passing it as template argument can be a good choice. Check this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int call1(int(*funcPtr)(int))
{
  return funcPtr(10);
}

template&lt;int(*F)(int)&gt;
int call2()
{
  return (F)(10);
}

int test(int a)
{
  return a;
}

int main()
{
  int i{0};

  i += test(5);
  i += call1(&amp;test);
  i += call2&lt;&amp;test&gt;();

  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I used <a href="https://gcc.godbolt.org/">https://gcc.godbolt.org/</a> to compile it. Thought it&#8217;s hard to get useful output - compilers are damn smart and produce optimized code - with <strong>gcc</strong> compiler and <strong>O1</strong> optimization I got the following assembly output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">test(int):
        mov     eax, edi
        ret
call1(int (*)(int)):
        sub     rsp, 8
        mov     rax, rdi
        mov     edi, 10
        call    rax
        add     rsp, 8
        ret
main:
        sub     rsp, 8
        mov     edi, OFFSET FLAT:test(int)
        call    call1(int (*)(int))
        add     eax, 15
        add     rsp, 8
        ret
        sub     rsp, 8
        mov     edi, OFFSET FLAT:std::__ioinit
        call    std::ios_base::Init::Init()
        mov     edx, OFFSET FLAT:__dso_handle
        mov     esi, OFFSET FLAT:std::__ioinit
        mov     edi, OFFSET FLAT:std::ios_base::Init::~Init()
        call    __cxa_atexit
        add     rsp, 8
        ret
----</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don&#8217;t need to know an assembly to find one interesting thing - the call to <code>call2()</code> was <strong>completely</strong> optimized out. And the only call here is a call to <code>call1()</code> function which calls the supplied callback. In other words - the template wrapper was replaced by the compiler to the actual callback invokation (here it also optimized out)! It&#8217;s hard to tell will the compiler optimize in the same way in real big project but at least this output gives some hope that it will.</p>
</div>
<div class="paragraph">
<p>Knowing this we can start to implement our delegate. In c++ we have a bunch of callable objects and we can split them in three categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>global functions - functions declared globally and static functions. The pointer to such a function will be passed to our delegate. For example <code>&amp;globalFunction</code> will return the address of a function (<code>&amp;</code> is optional). We can be sure we will not have problems calling it later, because this functions are always exist during program lifetime.</p>
</li>
<li>
<p>member functions - members of a class or a struct. The pointer to this function should be called on valid object and it&#8217;s developer&#8217;s  responsibility to keep an object alive. The member function pointer can be written, for example, <code>int(SomeObj::*funcPtr)(int)</code> and called <code>obj&#8594;*funcPtr(42)</code>, where <code>obj</code> is a pointer.</p>
</li>
<li>
<p>different callable objects that are not fitting in previous categories. This can be functors, lambdas, <code>std::function</code> objects. Thought lambda can be casted to a function pointer and treated as global/static function such a pointer can&#8217;t be used as template argument. Moreover, only lambdas without capture can be casted. This is why I put lambdas in this category.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All that means that we should manage 3 cases in our delegate implementation. So let&#8217;s do it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class Delegate;

template&lt;typename Ret, typename ...Args&gt;
class Delegate&lt;Ret(Args...)&gt;
{
	using CallbackType = Ret(*)(shared_ptr&lt;void&gt;, Args...);

public:
	Ret operator()(Args... args)
	{
		return callback(callee, args...);
	}

    bool operator==(const Delegate&amp; other)
	{
		return callee == other.callee &amp;&amp; callback == other.callback;
	}

private:
	shared_ptr&lt;void&gt; callee{ nullptr };
	CallbackType callback{ nullptr };

private:
	Delegate(shared_ptr&lt;void&gt; obj, CallbackType funcPtr) : callee{ obj }, callback{ funcPtr }
	{
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we created an incomplete base template class and a specialization. This is simply a cosmetic stuff - I like more <code>Delegate&lt;int(int, float)&gt;</code> signature than <code>Delegate&lt;int, int, float&gt;</code>. Next we declared a callback type <code>Ret(*)(shared_ptr&lt;void&gt;, Args&#8230;&#8203;)</code> - the function that accepts arguments that should be passed to supplied callback and an object - the <code>callee</code> - which we&#8217;ll use to call supplied callback on. This <code>callee</code> will be a pointer to a class/struct instance or a pointer to a lambda/functor and <code>nullptr</code> for global/static functions. Let <code>shared_ptr&lt;void&gt;</code> type scare you not - it will be casted to correct type in elegant manner. Also there&#8217;re a private constructor - mainly because constructors in c++ can&#8217;t be called with explicit template parameters and for ceation we&#8217;ll use a factory function, comparison operator - for having only single callback of the same time and for removing of a callback, and a call operator, so our delegate can be called as a functor or even be passed to another delegate!</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s add some meat to our skeleton. The simplest case is a static/global function case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">public:
	template&lt;Ret(*funcPtr)(Args...)&gt;
	static Delegate create()
	{
		return Delegate{ nullptr, &amp;globalCaller&lt;funcPtr&gt; }; // nullptr as first parameter because static/global functions can be called directly
	}

private:
	template&lt;Ret(*funcPtr)(Args...)&gt;
	static Ret globalCaller(shared_ptr&lt;void&gt;, Args... args)
	{
		return funcPtr(args...);
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing really complicated here - we just defined a static <code>create</code> function (which calls the private constructor) and a wrapper for the callback. This wrapper is stored for later use. I&#8217;ll repeat it here - the standard doesn&#8217;t allow to call a constructor with explicit template arguments. That&#8217;s why we need <code>create</code> factory function.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The downside of template here is that we need to manually type template argument - it can&#8217;t be deduced.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can create and call our first delegate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int global(int a, float b)
{
	return a + static_cast&lt;int&gt;(b);
}

Delegate&lt;int(int, float)&gt; d{ Delegate&lt;int(int, float)&gt;::create&lt;&amp;global&gt;() };
d(10, 5.0f);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Member function case is slightly more difficult:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">public:
	template&lt;typename T, Ret(T::*funcPtr)(Args...)&gt;
	static Delegate create(shared_ptr&lt;T&gt; obj)
	{
		return Delegate{ obj, &amp;memberCaller&lt;T, funcPtr&gt; };
	}

private:
	template&lt;typename T, Ret(T::*funcPtr)(Args...)&gt;
	static Ret memberCaller(shared_ptr&lt;void&gt; callee, Args... args)
	{
		return (static_cast&lt;T*&gt;(callee.get())-&gt;*funcPtr)(args...);
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have <strong>overloaded</strong> <code>create()</code> function. And here we need to pass a pointer to existing object which will be stored for later use as well as a wrapper. I decided to use <code>shared_ptr</code> because I want to be sure that object is valid when I call a delegate. With <code>shared_ptr</code> I have this guarantee. The <code>memberCaller()</code> wrapper casts the <code>void*</code> pointer to the provided type so we can say we have some sort of type safety here.</p>
</div>
<div class="paragraph">
<p>And that&#8217;s how it can be created and called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct UserStruct
{
	int member(int a, float b)
	{
		return a + static_cast&lt;int&gt;(b);
	}
};

Delegate&lt;int(int, float)&gt; d{ Delegate&lt;int(int, float)&gt;::create&lt;UserStruct, &amp;UserStruct::member&gt;(make_shared&lt;UserStruct&gt;()) };
d(10, 5.0f);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final case is a functor case. Here we don&#8217;t have a function pointer but only the callable object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">public:
	template&lt;typename T&gt;
	static Delegate create(shared_ptr&lt;T&gt; t)
	{
		return Delegate{ t, &amp;functorCaller&lt;T&gt; };
	}

private:
	template&lt;typename T&gt;
	static Ret functorCaller(shared_ptr&lt;void&gt; functor, Args... args)
	{
		return (*static_cast&lt;T*&gt;(functor.get()))(args...);
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have another <strong>overloaded</strong> <code>create</code> function. We can go wild here and add different compile time checks (for example the check that passed parameter is a callable object) and add readable error message if requirements are violated. But this signature will report about the problems anyway, maybe not in a friendly manner. As in the case with a member function we cast our functor to right type in a <code>functorCaller()</code> wrapper, so no type problems here.</p>
</div>
<div class="paragraph">
<p>The tricky part is to create a lambda shared pointer. As you may know there&#8217;s no strict type for lambda. Instead, on every lambda creation new type will be introduced. And this code <code>typeid([](){}).name() == typeid([](){}).name()</code> will return <code>false</code>. In order to create a necessary <code>shared_ptr</code> I created this function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename T, typename L = typename std::decay&lt;T&gt;::type&gt;
shared_ptr&lt;L&gt; make_shared_lambda(T&amp;&amp; t)
{
	return make_shared&lt;L&gt;(forward&lt;T&gt;(t));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s not ideal - the underlying lambda will be copied/moved. Anyway, now we can use functors with a delegate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto ptr = make_shared_lambda([](int a, float b)-&gt;int
{
	return a + static_cast&lt;int&gt;(b);
});

Delegate&lt;int(int, float)&gt; d{ Delegate&lt;int(int, float)&gt;::create(ptr) };
d(10, 5.0f);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The main point of a delegate - call underlying function later. And we want to be sure that callable object exist. That&#8217;s why we need to track the object&#8217;s lifetime.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you probably noticed - the declaration of the delegate is pretty verbose. Can it be simplified? I beleive it can with macros and template magic, but I prefer to have a helper class. This class will handle adding and removing of delegates. I call it - <code>Dispatcher</code>. Imagine some abstract <code>Button</code> class. It can have a <code>Dispatcher</code> for some event - a <code>click</code>, for example. Now every entity that want to listen for this <code>click</code> event can add a delegate to this <code>Dispatcher</code>. And when the real event triggers this <code>Dispatcher</code> will invoke all callbacks that was added to it. Here&#8217;s a simple implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class Dispatcher;

template&lt;typename Ret, typename ...Args&gt;
class Dispatcher&lt;Ret(Args...)&gt;
{
public:
	template&lt;Ret(*funcPtr)(Args...)&gt;
	bool add()
	{
		return add(Delegate&lt;Ret(Args...)&gt;::create&lt;funcPtr&gt;());
	}

	template&lt;Ret(*funcPtr)(Args...)&gt;
	bool remove()
	{
		return remove(Delegate&lt;Ret(Args...)&gt;::create&lt;funcPtr&gt;());
	}

	template&lt;typename T, Ret(T::*funcPtr)(Args...)&gt;
	bool add(shared_ptr&lt;T&gt; obj)
	{
		return add(Delegate&lt;Ret(Args...)&gt;::create&lt;T, funcPtr&gt;(obj));
	}

	template&lt;typename T, Ret(T::*funcPtr)(Args...)&gt;
	bool remove(shared_ptr&lt;T&gt; obj)
	{
		return remove(Delegate&lt;Ret(Args...)&gt;::create&lt;T, funcPtr&gt;(obj));
	}

	template&lt;typename T&gt;
	bool add(shared_ptr&lt;T&gt; t)
	{
		return add(Delegate&lt;Ret(Args...)&gt;::create(t));
	}

	template&lt;typename T&gt;
	bool remove(shared_ptr&lt;T&gt; t)
	{
		return remove(Delegate&lt;Ret(Args...)&gt;::create(t));
	}

	void operator()(Args... args)
	{
		for (auto&amp; delegate : delegates)
		{
			delegate(args...);
		};
	}

	bool add(Delegate&lt;Ret(Args...)&gt; delegate)
	{
    		// if we already added same delegate - don't add it again
		if (find(delegates.begin(), delegates.end(), delegate) != delegates.end())
		{
			return false;
		}

		delegates.push_back(delegate);

		return true;
	}

	bool remove(Delegate&lt;Ret(Args...)&gt; delegate)
	{
    		// remove delegate only if it exist
		auto it = find(delegates.begin(), delegates.end(), delegate);

		if (it == delegates.end())
		{
			return false;
		}

		delegates.erase(it);

		return true;
	}
private:
	vector&lt;Delegate&lt;Ret(Args...)&gt;&gt; delegates;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mostly it&#8217;s a wrappers around delegate creation functions. Couple of notes here.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we want to add a delegate - the new one will be created. If we want to remove it - we also need to create it to be able to compare. But that&#8217;s the price we need to pay in order to have compact delegates, without storing callback pointer and different comparing logic.</p>
</li>
<li>
<p>During call of <code>operator()</code> the callback function will be called. And if in this callback we remove the delegate from the dispatcher - bad things can happen. In other words in this implementation it&#8217;s possible to remove an item from the vector whhile iterating over this vector. This will lead to crash/corruption and additional logic needed here to avoid this situation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And we can use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">Dispatcher&lt;int(int, float)&gt; dispatcher;
dispatcher.add&lt;&amp;global&gt;();

auto ptr = make_shared&lt;UserStruct&gt;();
dispatcher.add&lt;UserStruct, &amp;UserStruct::member&gt;(ptr);

dispatcher(10, 5.0f);

dispatcher.remove&lt;&amp;global&gt;();
dispatcher.remove&lt;UserStruct, &amp;UserStruct::member&gt;(ptr);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Things that can be improved:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maybe it would be better to return some delegate handle after adding the delegate to the dispatcher. Keeping this handle will act the same as keeping <code>Delegate</code> instance, but it&#8217;s more compact and simple. Later we can use the handle to remove a delegate and there will be no need to create a new <code>Delegate</code> instance for comparison.</p>
</li>
<li>
<p>The parameters passed to <code>Dispatcher::operator()</code> and <code>Delegate::operator()</code> are passed by copy. It would better to use perfect forwarding. But the proble is that we have <code>typename &#8230;&#8203;Args</code> parameter pack in class definition but usage of it - <code>Args&#8230;&#8203; args</code> in the function. In other words we have a templated class but not a function. And <a href="http://en.cppreference.com/w/cpp/utility/forward#Example">perfect forwarding</a> with <a href="http://en.cppreference.com/w/cpp/language/reference">reference collapsing rules</a> applies only to function templates. I believe we can fix this templating a function with another parameter pack and comparing this pack with one declared in class template.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The source code together with usage example can be found <a href="https://github.com/nikitablack/cpp-tests/blob/master/Delegate/Delegate.cpp">here</a>.</p>
</div>
        </div>


        <footer class="post-footer" role="contentinfo">

            <div class="vcard">
                <!-- <a href="https://nikitablack.github.io/rss" id="btn_feed" class="btn" title="Feed" target="_blank">
                    <span aria-hidden="true" data-icon=")"></span>
                    <strong>Feed</strong>
                </a> -->

                <a href="" class="photo">
                    <span style="background-image: url('https://avatars.githubusercontent.com/u/6390092?v=3');">
                        <img src="https://avatars.githubusercontent.com/u/6390092?v=3" alt="nikitablack">
                    </span>
                </a>

                <div class="details">
                    <h4><a href="" class="url n">nikitablack</a></h4>
                    
                    <a href="https://nikitablack.github.io" class="js-remove-domain-schema">https://nikitablack.github.io</a>
                </div>
            </div>

            <div id="user_bio">
                <div class="inner">
                    
                </div>
            </div>

        </footer>




    <section class="post-comments">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
      var disqus_shortname = 'nikitablack'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </section>


    </article>

    <div id="share_modal">
        <div class="wrap">
            <div class="inner">
                <header>
                    Share
                    <a href="" class="close" title="Close">&times;</a>
                </header>

                <div class="roon-share-links">
                    <a href="https://twitter.com/share" class="twitter-share-button" data-dnt="true">Tweet</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                    <div id="fb-elems">
                        <div id="fb-root"></div>
                        <script>(function(d, s, id) {
                        var js, fjs = d.getElementsByTagName(s)[0];
                        if (d.getElementById(id)) return;
                        js = d.createElement(s); js.id = id;
                        js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=463438580397968";
                        fjs.parentNode.insertBefore(js, fjs);
                        }(document, 'script', 'facebook-jssdk'));</script>
                        <div class="fb-like" data-send="false" data-layout="button_count" data-width="110" data-show-faces="false" data-font="arial"></div>
                    </div>

                    <div id="pinit-btn">
                        <a href="//pinterest.com/pin/create/button/?url=https://nikitablack.github.io/2016/04/12/Generic-C-delegates.html&amp;description=Generic%20C%2B%2B%20delegates-Simply%20about%20complex " data-pin-do="buttonPin" data-pin-config="beside"><img src="//assets.pinterest.com/images/pidgets/pin_it_button.png"></a>
                        <script type="text/javascript" src="//assets.pinterest.com/js/pinit.js"></script>
                    </div>
                </div>
            </div>
        </div>
    </div>




        <a href="https://nikitablack.github.io" id="blog_badge">
            <span style="background-image: url('https://raw.githubusercontent.com/nikitablack/nikitablack.github.io/master/images/logo.jpg');">Simply about complex</span>
        </a>


    <script>

            function get_text(el) {
                ret = "";
                var length = el.childNodes.length;
                for(var i = 0; i < length; i++) {
                    var node = el.childNodes[i];
                    if(node.nodeType != 8) {
                        ret += node.nodeType != 1 ? node.nodeValue : get_text(node);
                    }
                }
                return ret;
            }
            function reading_time () {
                var post_content = document.getElementById('js-post-content');
                if (post_content) {
                    var words = get_text(post_content),
                        count = words.split(/\s+/).length,
                        read_time = Math.ceil((count / 150)),
                        read_time_node = document.createTextNode(read_time + ' min read');
                    document.getElementById('js-reading-time').appendChild(read_time_node);
                }
            }

        function no_schema_links () {
            var links = document.querySelectorAll('.js-remove-domain-schema');
            if (links) {
                for (i = 0; i < links.length; ++i) {
                    var link = links[i],
                        text = link.innerHTML,
                        no_schema = text.replace(/.*?:\/\//g, "");
                    link.innerHTML = no_schema;
                }
            }
        }

        window.onload = function () {
            no_schema_links();

            reading_time();
        }
    </script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();      
      </script>

        <script>
            $(function(){
                var share_modal = $("#share_modal"),
                    update_social_links = true;

                $("#btn_share").click(function(){
                    var that = $(this);
                    share_modal.fadeIn(200);
                    return false;
                });

                share_modal.click(function(e){
                    if (e.target.className == "wrap" || e.target.id == "share_modal") {
                        share_modal.fadeOut(200);
                    }
                    return false;
                });

                share_modal.find("div.inner > header > a.close").click(function(){
                    share_modal.fadeOut(200);
                    return false;
                });
            });
        </script>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-69402602-2', 'auto');
    ga('send', 'pageview');

    </script>

</body>
</html>
