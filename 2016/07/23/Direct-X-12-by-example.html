<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>DirectX 12 by example</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="//nikitablack.github.io/themes/roon/favicon.ico">

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:400,700,400italic,700italic|Open+Sans:400italic,700italic,700,400">
    <link rel="stylesheet" type="text/css" href="//nikitablack.github.io/themes/roon/assets/css/screen.css?v=1.0.0" />

    <link rel="canonical" href="https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html" />
    
    <meta property="og:site_name" content="Simply about complex" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="DirectX 12 by example" />
    <meta property="og:description" content="Disclaimer! I&amp;#8217;m not an expert, computer graphics is my hobby. When I started to learn directx 12 I already was quite comfortable with directx 11 but it was still difficult to switch. And even after several months of..." />
    <meta property="og:url" content="https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html" />
    <meta property="article:published_time" content="2016-07-22T22:00:00.000Z" />
    <meta property="article:modified_time" content="2016-08-15T20:12:42.657Z" />
    <meta property="article:tag" content="c++" />
    <meta property="article:tag" content="directx12" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="DirectX 12 by example" />
    <meta name="twitter:description" content="Disclaimer! I&amp;#8217;m not an expert, computer graphics is my hobby. When I started to learn directx 12 I already was quite comfortable with directx 11 but it was still difficult to switch. And even after several months of..." />
    <meta name="twitter:url" content="https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html" />
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Simply about complex",
    "author": {
        "@type": "Person",
        "name": "nikitablack",
        "image": "https://avatars.githubusercontent.com/u/6390092?v=3",
        "url": "undefined/author/undefined",
        "sameAs": "https://nikitablack.github.io"
    },
    "headline": "DirectX 12 by example",
    "url": "https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html",
    "datePublished": "2016-07-22T22:00:00.000Z",
    "dateModified": "2016-08-15T20:12:42.657Z",
    "keywords": "c++,  directx12",
    "description": "Disclaimer! I&amp;#8217;m not an expert, computer graphics is my hobby. When I started to learn directx 12 I already was quite comfortable with directx 11 but it was still difficult to switch. And even after several months of..."
}
    </script>

    <meta name="generator" content="Ghost ?" />
    <link rel="alternate" type="application/rss+xml" title="Simply about complex" href="https://nikitablack.github.io/rss" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
</head>
<body class="post-template tag-c tag-directx12  noimage">

    


    <article role="main" class="">
        <header>
            <a href="https://nikitablack.github.io" id="home_link">Â«</a>
            <div class="meta"><time datetime="2016-07-23"><a href="/2016/07/23/Direct-X-12-by-example.html">July 23, 2016</a></time> <span class="count" id="js-reading-time"></span></div>
            <h1>DirectX 12 by example</h1>
        </header>

        <div class="text" id="js-post-content">
            <div class="sect4">
<h5 id="_disclaimer">Disclaimer!</h5>
<div class="paragraph">
<p>I&#8217;m not an expert, computer graphics is my hobby. When I started to learn directx 12 I already was quite comfortable with directx 11 but it was still difficult to switch. And even after several months of investigations I still have a feeling that I just scratched a surface. I&#8217;m constantly learning and this post is a syncronization of my thoughts. I found that attempts to explain complex things makes me understand these things better. Thought the artile was written by me for me I hope you&#8217;ll find it useful too.</p>
</div>
<div class="paragraph">
<p>Directx 12 is low level, it have many concepts and in order to make your code work well you need to take into account a lot of things. You need to profile a lot. And you need to know a hardware. For example you need to know that changing descriptor heaps is a heavy operation. I have no idea what&#8217;s happening in hardware and why it&#8217;s expensive. I&#8217;m just following guidelines trying to remember and reading gpu specs in parallel.</p>
</div>
<div class="paragraph">
<p>Also I assume that you have an experience with previous directx versions because I&#8217;ll not explain in this post what is swapchain or backbuffer. You should be familar with tesselation - what are tesselation factors, what is a constant function, why do you need hull and domain shaders. Good overview of directx 11 tesselation can be found <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx">here</a>. Also you need to know basic windows programming because we need to create a window and I&#8217;ll not explain how to do it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_preface">Preface</h5>
<div class="paragraph">
<p>In this tutorial we&#8217;ll render a teapot. But not just a static mesh, no. We&#8217;ll render a tesselated teapot. Why did I choose this? Well, because you can find in the web a plenty of different <em>HelloWorld</em> examples. I didn&#8217;t want to create another <em>HelloWorld</em> but somethig that covers different areas of the api and at the same time is simple.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/images/teapot_tutorial/teapot.png" alt="Teapot" width="400">
</div>
</div>
<div class="paragraph">
<p>We&#8217;re going to use <code>16</code>-point patches for the teapot. We&#8217;ll provide control points positions in one vertex buffer and patch indicies in one index buffer. For colors and transforms (more on this later) we&#8217;ll use structured buffers.</p>
</div>
<div class="paragraph">
<p>Usually directx tutorials follow the same pattern - initialization, resource creation, rendering. I decided to go slightly different way - first we&#8217;ll create the most important part and later will add different components to support it - one after another as required. And the most important part, by my opinion, are shaders. After all this is what we want the gpu to execute. This approach helped me to tie different parts of the api and undesrtand how they related to each other.</p>
</div>
<div class="paragraph">
<p>In order to write a shader we need to figure out what data it operates on. So let&#8217;s first define it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_teapot_data">Teapot Data</h5>
<div class="paragraph">
<p>Since we&#8217;re going to use tesselation we&#8217;re not interested in <em>"usual"</em> mesh made of triangles. We need patches. Of course somebody already did this for us and we can use ready data. For example <a href="https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot#The_Teapot_DataSet">here</a> is the set of <code>16</code>-point patches that describe a teapot. Unfortunatelly we can&#8217;t use this data as is but we need to adjust it a little. This set doesn&#8217;t have a bottom - it&#8217;s ok, we&#8217;ll not use it either but existing patches describe only parts of the teapot. For example <em>rim</em>, <em>body</em> and <em>lid</em> describe only a quarter of a teapot and <em>handle</em> and <em>spout</em> describe only half of respective parts. So if we&#8217;ll render this set we&#8217;ll get this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/images/teapot_tutorial/teapot_quarter.png" alt="Teapot" width="400">
</div>
</div>
<div class="paragraph">
<p>There&#8217;re several ways to fix it. One way is to use separate draw call for every part. This way we can render rim four times with different transformations. Another way is to draw a part once but use instancing. This way we&#8217;ll have a draw call for every part&#8217;s family (<em>rim</em>, <em>body</em> etc.) but the repeated parts will be instances.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll go other way and render everything in one draw call. For this we&#8217;ll duplicate indices required number of times and also provide a transformation for every part. Let&#8217;s take a rim as an example. Instead of having one patch for the quarter we&#8217;ll have <code>4</code> patches for the entire circle, that means <code>16 * 4 = 64</code> indices for this part. In the shader knowing the patch id we can apply a transform. In our case we&#8217;ll rotate initial patch around an axis by <code>0</code>, <code>90</code>, <code>180</code> and <code>270</code> degrees. All that means that together with points positions and indices we need to provide a transformation data as. Additionaly to visually separate patches we&#8217;ll use different colors which also should be provided as a separate data. In total we&#8217;ll have <code>28</code> patches and our data will consist of list of points (some points are shared between patches - that&#8217;s why we need indices), list of indices (<code>28 * 16</code>), list of transforms (<code>28</code> matrices) and list of colors (<code>28</code> randomly generated rgb colors). Final data can be found <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/TeapotData.cpp">here</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_shaders">Shaders</h5>
<div class="paragraph">
<p>In our example we&#8217;ll use vertex, hull, domain and pixel shaders.</p>
</div>
<div class="paragraph">
<p><strong>Vertex shader</strong></p>
</div>
<div class="paragraph">
<p>The first shader in our pipeline is the vertex shader. All it&#8217;s do is accepts control point position from the application and passes it to the hull shader. Because of it&#8217;s simplicity I&#8217;ll not provide it here but you can observe it in <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/VertexShader.hlsl">github</a>.</p>
</div>
<div class="paragraph">
<p>Just for the remainder - the vertex shader will be called once for every control point in the patch. For <code>28</code> patches (recall that this is the number of patches used for the model) <code>16</code> points each this is <code>448</code> times.</p>
</div>
<div class="paragraph">
<p><strong>Hull shader</strong></p>
</div>
<div class="paragraph">
<p>This shader, as you already know, receives control point position from the vertex shader and also some data from the application in the form of constants which we&#8217;ll use as tesseltion factors for edge and inside of the patch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define NUM_CONTROL_POINTS 16

struct PatchTesselationFactors
{
	int edge;
	int inside;
};
ConstantBuffer&lt;PatchTesselationFactors&gt; tessFactors : register(b0);

struct VertexToHull
{
	float3 pos : POSITION;
};

struct PatchConstantData
{
	float edgeTessFactor[4] : SV_TessFactor;
	float insideTessFactor[2] : SV_InsideTessFactor;
};

struct HullToDomain
{
	float3 pos : POSITION;
};

PatchConstantData calculatePatchConstants()
{
	PatchConstantData output;

	output.edgeTessFactor[0] = tessFactors.edge;
	output.edgeTessFactor[1] = tessFactors.edge;
	output.edgeTessFactor[2] = tessFactors.edge;
	output.edgeTessFactor[3] = tessFactors.edge;
	output.insideTessFactor[0] = tessFactors.inside;
	output.insideTessFactor[1] = tessFactors.inside;

	return output;
}

[domain("quad")]
[partitioning("integer")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(NUM_CONTROL_POINTS)]
[patchconstantfunc("calculatePatchConstants")]
HullToDomain main(InputPatch&lt;VertexToHull, NUM_CONTROL_POINTS&gt; input, uint i : SV_OutputControlPointID)
{
	HullToDomain output;
	output.pos = input[i].pos;

	return output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here you can see that the patch outputs the same <code>16</code> control points, uses <code>integer</code> partitioning and <code>quad</code> domain. Also note the new <code>hlsl 5.1</code> syntax for the constant buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">ConstantBuffer&lt;PatchTesselationFactors&gt; tessFactors : register(b0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thought you can use the old syntax I like the new one more. Beyond this the shader is a simple pass-through, like a vertex shader.</p>
</div>
<div class="paragraph">
<p>This shader will be invoked <code>28</code> number of times (by the number of patches).</p>
</div>
<div class="paragraph">
<p><strong>Domain shader</strong></p>
</div>
<div class="paragraph">
<p>Finally we arrived to the point of interest. Basically this is the place where all the work is done in our program.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define NUM_CONTROL_POINTS 16

struct ConstantBufferPerObj
{
	row_major float4x4 wvpMat;
};
ConstantBuffer&lt;ConstantBufferPerObj&gt; constPerObject : register(b0);

struct PatchTransform
{
	row_major float4x4 transform;
};
StructuredBuffer&lt;PatchTransform&gt; patchTransforms : register(t0);

struct PatchColor
{
	float3 color;
};
StructuredBuffer&lt;PatchColor&gt; patchColors : register(t1);

struct PatchConstantData
{
	float edgeTessFactor[4] : SV_TessFactor;
	float insideTessFactor[2] : SV_InsideTessFactor;
};

struct HullToDomain
{
	float3 pos : POSITION;
};

struct DomainToPixel
{
	float4 pos : SV_POSITION;
	float3 color : COLOR;
};

float4 bernsteinBasis(float t)
{
	float invT = 1.0f - t;
	return float4(invT * invT * invT, // (1-t)3
		3.0f * t * invT * invT, // 3t(1-t)2
		3.0f * t * t * invT, // 3t2(1-t)
		t * t * t); // t3
}

float3 evaluateBezier(const OutputPatch&lt;HullToDomain, NUM_CONTROL_POINTS&gt; bezpatch, float4 basisU, float4 basisV)
{
	float3 value = float3(0, 0, 0);
	value = basisV.x * (bezpatch[0].pos * basisU.x + bezpatch[1].pos * basisU.y + bezpatch[2].pos * basisU.z + bezpatch[3].pos * basisU.w);
	value += basisV.y * (bezpatch[4].pos * basisU.x + bezpatch[5].pos * basisU.y + bezpatch[6].pos * basisU.z + bezpatch[7].pos * basisU.w);
	value += basisV.z * (bezpatch[8].pos * basisU.x + bezpatch[9].pos * basisU.y + bezpatch[10].pos * basisU.z + bezpatch[11].pos * basisU.w);
	value += basisV.w * (bezpatch[12].pos * basisU.x + bezpatch[13].pos * basisU.y + bezpatch[14].pos * basisU.z + bezpatch[15].pos * basisU.w);

	return value;
}

[domain("quad")]
DomainToPixel main(PatchConstantData input, float2 domain : SV_DomainLocation, const OutputPatch&lt;HullToDomain, NUM_CONTROL_POINTS&gt; patch, uint patchID : SV_PrimitiveID)
{
	// Evaluate the basis functions at (u, v)
	float4 basisU = bernsteinBasis(domain.x);
	float4 basisV = bernsteinBasis(domain.y);

	// Evaluate the surface position for this vertex
	float3 localPos = evaluateBezier(patch, basisU, basisV);

	float4x4 transform = patchTransforms[patchID].transform;
	float4 localPosTransformed = mul(float4(localPos, 1.0f), transform);

	DomainToPixel output;
	output.pos = mul(localPosTransformed, constPerObject.wvpMat);
	output.color = patchColors[patchID].color;

	return output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Going from the top we see that we&#8217;re operating on the same <code>16</code> point patch, we have a constant buffer for the teapot`s world-view-projection transform, structured buffer for the patch transform and structured buffer for the patch color. In practice we can use one structured buffer for both transforms and colors but I deliberately split it in two to show how we can assign resources through the root table (more on this later). This data we&#8217;re receiving from the application.</p>
</div>
<div class="paragraph">
<p>There&#8217;re also structs: <code>PatchConstantData</code> and <code>HullToDomain</code> - data from the hull shader (remember that position is a pass through from the vertex shader which also passes it from the input assembler), <code>DomainToPixel</code> - the data we&#8217;re passing further down the pipeline - to the pixel shader.</p>
</div>
<div class="paragraph">
<p>Next is a pure math - in the <code>main()</code> function we have a list of control points for one patch (<code>16</code> points) and we need to sample it so we can assign a position to the new vertex generated by tesselator. The good overview of the math behind you can find <a href="http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php">here</a>. Also <a href="http://www.gdcvault.com/play/1012740/direct3d">this presentation</a> is a very good reading about patch tesselation in <code>directx 11</code> (I took the most of the code from there to be honest).</p>
</div>
<div class="paragraph">
<p>So what are we doing in the <code>main()</code> function? The first <code>3</code> function parameters are pretty standard - the constant data which we defined in the hull shader (not used here, but have to be provided), <code>uv</code> coordinates for our point in the quad domain - generated by tesselator, and initial patch information from the hull shader. The last parameter - <code>PatchID</code> with special semantics is worth paying litle attention. As you remember, in our demo we have the total number of patches equal to <code>28</code> and we want to apply some parameters to each patch, for example a color. That means that for every generated vertex in the same patch we need to assign the same color information and pass it to the <code>pixel</code> shader. And this is where <code>SV_PrimitiveID</code> semantics will come to the rescue - for every vertex of the same patch (no matter how many vertices were generated) this value will be the same. The first patch will get id of <code>0</code>, second patch - <code>1</code> and so on. One thing worth to remember - all patches should be rendered in one draw call. Every new draw call resets the id (as well as new instance in instance drawing).</p>
</div>
<div class="paragraph">
<p>First we&#8217;re finding the vertex position in patch space. Next with the help of the patch id we&#8217;re obtaining th patch transform (recall an example - we need to rotate a rim <code>4</code> times) and applying it to the vertex. Next we&#8217;re transforming the vertex to the homogenious space by multiplying it on world-view-projection matrix. In the final step we&#8217;re sampling the color structured buffer and sending this data to our last programmable stage - pixel shader.</p>
</div>
<div class="paragraph">
<p>This function will be called for every generated vertex (generated by tesselator). The number of generated vertices depends on the tesselation factors (edge and inside for the quad patch) and partitioning scheme (<code>[partitioning("integer")]</code> in the hull shader).</p>
</div>
<div class="paragraph">
<p><strong>Pixel shader</strong></p>
</div>
<div class="paragraph">
<p>This is also a very simple shader, don&#8217;t even need to be discussed. You can find the code <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/PixelShader.hlsl">here</a>.</p>
</div>
<div class="paragraph">
<p>That&#8217;s basically it - we have a program and we need to make our hardware to run it. All other code just exist for this purpose - to help the gpu execute shaders. To summarize things I drew a diagram that shows shader stages and resources we need.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://raw.githubusercontent.com/nikitablack/nikitablack.github.io/master/images/teapot_tutorial/shader_res_1.png"><img src="/images/teapot_tutorial/shader_res_1.png" alt="Shader Resources" width="800"></a>
</div>
</div>
<div class="paragraph">
<p>Couple of things to note. Resources are stored in gpu memory. Gpu have no idea what&#8217;s stored inside it and how to interpret it - it&#8217;s just a blob of data. It&#8217;s our task to tell it where the data resides, the size and the format. For vertex buffer and index buffer it&#8217;s pretty easy - we&#8217;re creating these buffers and later tell the gpu to use it with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn986883(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::IASetVertexBuffers()</code></a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn986882(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::IASetIndexBuffer()</code></a> methods. On the diagram I showed solid a arrow from input to these resources. With other resources things are different. There&#8217;s no such method like <code>DSSetStructuredBufferInSlot()</code> or similar and we need to use a special structure called <code>RootSignature</code> to bind shaders and resources together. That&#8217;s why there&#8217;re question marks between shader and resource. We&#8217;ll find out how to bind resources in the next sections. Also on the diagram I specified the size of our data together with alignment size (for example <code>1416B / 64kB</code> for the <code>vertex buffer</code>). Id directx 12 (and 11) buffers should be aligned by <code>64kB</code>. We can specify this value during resource creation or let the api do it for us. That means if we have a lot of small buffers we&#8217;re wasting a lot of space. But it&#8217;s just an interesting point and we shoudn&#8217;t bother about this in our example.</p>
</div>
</div>
<div class="sect4">
<h5 id="_briefly_about_descriptors">Briefly about Descriptors</h5>
<div class="paragraph">
<p>As I mentioned above gpu can&#8217;t use resource memory directly. How can we say then that some memory is a structured buffer, for example? As you already guessed - with a descriptor (another name is view). This is a small structure that describes the resource - it&#8217;s format, size etc. Since this information used by gpu it&#8217;s convenient to strore it in the gpu itself. We keep descriptors in special place called descriptor heap. We&#8217;ll touch descriptors more closely in later sections but for now you just need to remember that resource stored in memory is just a bunch on bits and bytes. This bunch can be described with descriptors - lightweight data that tells gpu how to interpret particular part of memory. This descriptors are stored in gpu memory in descriptor heaps. Of course directx wouldn&#8217;t be directx if everything would be so easy - there different ways to provide information to the gpu, for example we can bypass descriptor heap and pass descriptor directly or avoid desciptor at all! We&#8217;ll cover this options in the course of this article.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_organization">Code Organization</h5>
<div class="paragraph">
<p>When I started to write this tutorial I wanted to make it as simple as possible and put everything in one file. But when this file became more than <code>1000</code> lines I decided to split the code on several logic units. <code>Window</code> is a class which encapsulates window creation and accepts a key press callback in the form of <code>std::function</code>. We&#8217;ll use this callback to change demo parameters. <code>Graphics</code> is a base class for our demo. It creates a <code>Window</code> and also initializes d3d. For example it creates device, swap chain, depth buffer, back buffers, command list and so on. <code>TeapotTutorial</code> extends this class and adds functionality related to our demo - resources creation, rendering. I&#8217;ll describe why each method exist and we&#8217;ll start with creation of the root signature.</p>
</div>
</div>
<div class="sect4">
<h5 id="_root_signature">Root Signature</h5>
<div class="paragraph">
<p>At this point we should know that shaders require resources and this resources should be bound to the correct resource slots (<code>b0</code> for constant buffer, <code>t0</code> for structured buffer, for example). In directx 12 we bind with special interface - <code>ID3D12RootSignature</code>. With the help of the interface we can describe which resources a shader needs and in which slot. We can say that signature only declares input parameters, just like usual c++ function signature. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void rootSignature(std::array&lt;int, 2&gt; constants, XMFLOAT4X4* wvpMatrix, std::vector&lt;XMFLOAT3*&gt;* colors);</code></pre>
</div>
</div>
<div class="paragraph">
<p>What we see here is that our function expects <code>3</code> parameters - two ints, copied by value; pointer to a matrix, and a pointer to vector of pointers to some colors. This is what happening if we&#8217;re using these values: the first parameter - two ints - will be copied to registers so accessing them will be extremely fast; for the second parameter we need to dereference a pointer and it will lead to memory read with a potential cache miss, so it&#8217;s slower that the first parameter; the third parameter is the slowest one - to read from the vector we need to dereference it first and then dereference the element we want to access - that means two indirections.</p>
</div>
<div class="paragraph">
<p>Please notice that this is just a signature - it doesn&#8217;t tell us what are the actual parameter values. Basically we can use as many different combinations of parameters as we can imagine with a single signature - the only mandatory is that we need to maintain correct types. Why did I tell all this? Because this is exactly how root signature works! We specify the input parameters and their types and later during runtime we call the function passing the actual data.</p>
</div>
<div class="paragraph">
<p>As you remember we have <code>4</code> resources for our demo - hull constant buffer, domain constant buffer and <code>2</code> domain structured buffers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
"But there&#8217;re also vertex and index buffers" - somebody can ask. Right, but they are <em>special</em> buffers - we need to create resources and corresponding views and pass this views directly to the pipeline in command list (as we&#8217;ll see later). These views don&#8217;t even need a resource heap!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also as we saw previously, the information about this resources should be stored in descriptors which should be stored in descriptor heaps. But I also mentioned that there&#8217;re some other ways to pass data around. That&#8217;s how we&#8217;ll do it in our demo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Tesselation factors for the hull shader we&#8217;ll pass <strong>directly</strong> in root signature. That means we don&#8217;t need to create descriptor or descriptor heap or even resource itself! This works because we can pass <code>32bit</code> constants in root signature and they appear in shader as a constant buffer. Since we have only <code>2</code> tesselation factors this type of passing looks like a good choice. Moreover, this data will be accessed in a shader without indirection, just like <code>std::array&lt;int, 2&gt;</code> in an example c++ function signature!</p>
</li>
<li>
<p>For domain shader&#8217;s constant buffer we will use a descriptor. But this decriptor will be passed as a part of the root signature. And that means we can bypass a descriptor heap. The descriptor will be inlined in the root signature - that&#8217;s why we don&#8217;t need to store it somewhere else. With root descriptor the shader first will read resource&#8217;s address and than read the actual data. Just like <code>XMFLOAT4X4*</code> in an example c++ function signature!</p>
</li>
<li>
<p>For domain shader&#8217;s structured buffers we will finaly use descriptor and descriptor heaps. That means we need to create a descriptor heap to hold <code>2</code> descriptors (one for every buffer) and desciptors itself. In order to pass information to the root signature we need to pack it to descriptor table. Descriptor table just tells which descriptor heap to use and the number of descriptors. When we need to access a buffer in a shader the runtime will first read the table, next will read the descriptor and finally will read the actual data. Just like <code>std::vector&lt;XMFLOAT3*&gt;*</code> in an example c++ function signature!</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
"Why do we need to use descriptors or tables if we can pass everything as root constants?" Root signature has a very limited size - <code>64DWORD</code> (<code>1DWORD</code> == <code>32bit</code>). That means we can store <code>64</code> ints inside it, or <code>4</code> matrices. If there&#8217;s not enough place the data will be stored somewhere else and it will add one more level of indirection. Root descriptor asks for <code>2DWORD</code> and table only <code>1DWORD</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Interesting note - <a href="https://developer.nvidia.com/dx12-dos-and-donts#roots">Nvidia</a> guys recommend to use root descriptors as much as you can. But <a href="http://gpuopen.com/performance-root-signature-descriptor-sets/">AMD</a> guys recommend to use tables.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Remember that signature doesn&#8217;t define any parameters - it just declares the type and the order. The actual data will be passed later.</p>
</div>
<div class="paragraph">
<p>Knowing all this we can write our first <code>directx 12</code> code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12RootSignature&gt; rootSignature;

// TeapotTutorial.cpp
void TeapotTutorial::createRootSignature()
{
	// #1
	D3D12_DESCRIPTOR_RANGE dsTransformAndColorSrvRange;
	ZeroMemory(&amp;dsTransformAndColorSrvRange, sizeof(dsTransformAndColorSrvRange));
	dsTransformAndColorSrvRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // we're using structured buffers - it's a SRV
	dsTransformAndColorSrvRange.NumDescriptors = 2; // we have 2 structured buffers and 2 descriptors
	dsTransformAndColorSrvRange.BaseShaderRegister = 0; // we start from the first register (t0)
	dsTransformAndColorSrvRange.RegisterSpace = 0; // this allows us to use the same register name if we use different space
	dsTransformAndColorSrvRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

	// #2
	D3D12_ROOT_PARAMETER dsTransformAndColorSrv;
	ZeroMemory(&amp;dsTransformAndColorSrv, sizeof(dsTransformAndColorSrv));
	dsTransformAndColorSrv.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	dsTransformAndColorSrv.DescriptorTable = { 1, &amp;dsTransformAndColorSrvRange }; // one range
	dsTransformAndColorSrv.ShaderVisibility = D3D12_SHADER_VISIBILITY_DOMAIN; // only used in domain shader

	//#3
	D3D12_ROOT_PARAMETER dsObjCb;
	ZeroMemory(&amp;dsObjCb, sizeof(dsObjCb));
	dsObjCb.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // constant buffer
	dsObjCb.Descriptor = { 0, 0 }; // first register (b0) in first register space
	dsObjCb.ShaderVisibility = D3D12_SHADER_VISIBILITY_DOMAIN; // only used in domain shader

	// #4
	D3D12_ROOT_PARAMETER hsTessFactorsCb;
	ZeroMemory(&amp;hsTessFactorsCb, sizeof(hsTessFactorsCb));
	hsTessFactorsCb.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
	hsTessFactorsCb.Constants = { 0, 0, 2 }; // 2 constants in first register (b0) in first register space
	hsTessFactorsCb.ShaderVisibility = D3D12_SHADER_VISIBILITY_HULL; // only used in hull shader

	vector&lt;D3D12_ROOT_PARAMETER&gt; rootParameters{ dsObjCb, hsTessFactorsCb, dsTransformAndColorSrv };

	// #5
	D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags{
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT | // we're using vertex and index buffers
		D3D12_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS |
		D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS |
		D3D12_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS
	};

	// #6
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc;
	ZeroMemory(&amp;rootSignatureDesc, sizeof(rootSignatureDesc));
	rootSignatureDesc.NumParameters = static_cast&lt;UINT&gt;(rootParameters.size());
	rootSignatureDesc.pParameters = rootParameters.data();
	rootSignatureDesc.NumStaticSamplers = 0; // samplers can be stored in root signature separately and consume no space
	rootSignatureDesc.pStaticSamplers = nullptr; // we're not using texturing
	rootSignatureDesc.Flags = rootSignatureFlags;

	// #7
	ComPtr&lt;ID3DBlob&gt; signature;
	ComPtr&lt;ID3DBlob&gt; error;
	if (FAILED(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, signature.ReleaseAndGetAddressOf(), error.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error serializing root signature" });
	}

	// finally create the root signature
	// #8
	if (FAILED(device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(rootSignature.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating root signature" });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re using <code>3</code> root parameters: root descriptor for domain shader&#8217;s constant buffer, <code>2</code> root constants for hull shader&#8217;s constant buffer and a descriptor table for <code>2</code> structured buffers.</p>
</div>
<div class="paragraph">
<p>First we&#8217;re creating a descriptor table - for this we need to specify the range of descriptors (<strong>#1</strong>) we&#8217;ll use and pass this range to the parameter description (<strong>#2</strong>). Next we&#8217;re creating a root descriptor for the domain constant buffer (<strong>#3</strong>). The final parameter is our root constants (<strong>#4</strong>). Notice how we specified shader visibility for each parameter. The api will validate this input and say us if there&#8217;s something wrong. Also notice how we excluded certain stages from accessing root signature (<strong>#5</strong>) - this is recommended. Next we&#8217;re creating root signature description struct (<strong>#6</strong>) with all the information we have so far and serializing it (<strong>#7</strong>). The last step is necessary because there&#8217;s another way to create a root signature - directly in shader, not c++ app. And finally we&#8217;re creating our root signature.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Directx team kindly provided a helper header that simplifies creation of different structures - <code>d3dx12.h</code>. Thought the header is not a part of <code>directx 12</code> it&#8217;s <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn708058(v=vs.85).aspx">well documented</a> in <code>msdn</code> and pretty solid. The <code>D3D12_DESCRIPTOR_RANGE</code> creation can be replaced with <code>CD3DX12_DESCRIPTOR_RANGE</code>, <code>D3D12_ROOT_PARAMETER</code> with <code>CD3DX12_ROOT_PARAMETER</code> and <code>D3D12_ROOT_SIGNATURE_DESC</code> with <code>CD3DX12_ROOT_SIGNATURE_DESC</code>. Using this helpers allow us to reduce and hence simplify code dramatically. I deliberatelly removed all <code>d3dx12.h</code> dependencies from my code just to show how api works under the hood.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When we serialize the signature we can get errors which will be writtent to <code>error</code> instance. There&#8217;re a lot of checks happens during serialization - for example if we&#8217;ll overlap registers for the same shader (have two <code>b0</code>) we&#8217;ll get an error. Very handy tool!</p>
</div>
<div class="paragraph">
<p>Now when we know about root signature we can update our diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://raw.githubusercontent.com/nikitablack/nikitablack.github.io/master/images/teapot_tutorial/shader_res_2.png"><img src="/images/teapot_tutorial/shader_res_2.png" alt="Shader Resources" width="800"></a>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s a little bit messy but if you&#8217;ll follow arrows you&#8217;ll see that it&#8217;s the same as the code. Notice how hull shader constant buffer went away (because we&#8217;re using inlined root constants) and descriptor heap for structured buffers appeared. There&#8217;s still some mistery left, namely the size of the domain constant buffer (you&#8217;ll learn about this later).</p>
</div>
<div class="paragraph">
<p>The last method - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899182(v=vs.85).aspx"><code>ID3D12Device::CreateRootSignature</code></a> - uses some <code>device</code> that we don&#8217;t know yet. This is a software representation of the hardware and we&#8217;ll find how to create one in the next section.</p>
</div>
</div>
<div class="sect4">
<h5 id="_directx_initialization">DirectX Initialization</h5>
<div class="paragraph">
<p>As you remember the base initialization is done in the base class called <code>Graphics</code>. This is how we create a device:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
Microsoft::WRL::ComPtr&lt;ID3D12Device&gt; device;

// Graphics.cpp
void Graphics::createDevice()
{
	if (FAILED(D3D12CreateDevice(adapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&amp;device))))
	{
		throw(runtime_error{ "Error creating device." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simple enough. But what is this <code>adapter</code>? We can use <code>nullptr</code> instead and let the api to choose the default adapter, but let&#8217;s see how we can select among many adapters that exist in our system. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174523(v=vs.85).aspx"><code>IDXGIAdapter</code></a> is similar to <code>ID3D12Device</code> interface - it also a presentation of a gpu. It&#8217;s hard for me to tell why do we need two similar interfaces that basically represent the same thing. Let&#8217;s think that <code>dxgi</code> interface provides different information about a gpu itself (vendor, name etc.), but <code>d3d</code> interface allows us to manipulate it - create different resources, change states.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
Microsoft::WRL::ComPtr&lt;IDXGIAdapter3&gt; adapter;

// Graphics.cpp
void Graphics::getAdapter()
{
	ComPtr&lt;IDXGIAdapter1&gt; adapterTemp;

	for (UINT adapterIndex{ 0 }; factory-&gt;EnumAdapters1(adapterIndex, adapterTemp.ReleaseAndGetAddressOf()) != DXGI_ERROR_NOT_FOUND; ++adapterIndex)
	{
		DXGI_ADAPTER_DESC1 desc;
		ZeroMemory(&amp;desc, sizeof(desc));

		adapterTemp-&gt;GetDesc1(&amp;desc);

		if (desc.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE)
		{
			continue;
		}

		if (SUCCEEDED(adapterTemp.As(&amp;adapter)))
		{
			break;
		}
	}

	if (adapter == nullptr)
	{
		throw(runtime_error{ "Error getting an adapter." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we just grab the first adapter that is not software (starting from <code>Windows 8</code> there&#8217;s always a software adapter presented in the system). But you can use different logic - like checking a vendor. For enumerating we&#8217;re using some <code>factory</code> which is <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174535(v=vs.85).aspx"><code>IDXGIFactory</a></code> interface. So let&#8217;s create it too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
Microsoft::WRL::ComPtr&lt;IDXGIFactory4&gt; factory;

// Graphics.cpp
void Graphics::createFactory()
{
#if defined(_DEBUG)
	ComPtr&lt;ID3D12Debug&gt; debugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;debugController))))
	{
		debugController-&gt;EnableDebugLayer();
	}
#endif

	UINT factoryFlags{ 0 };
#if _DEBUG
	factoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif

	if (FAILED(CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(factory.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating IDXGIFactory." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally no more new dependent interfaces! Thought there&#8217;s one which we not depend on - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn950153(v=vs.85).aspx"><code>ID3D12Debug</code></a>. You should always use it with debug configuration. During an error it writes detailed message to the output.</p>
</div>
<div class="paragraph">
<p>Now we can compile the code we have successfully thought we&#8217;ll not see anything on the screen. That&#8217;s one of the downside of programming with directx - we can&#8217;t have some intermediate results like render only one triangle from the teapot or shade only one pixel. We need to write a lot of code for both cpu and gpu just to find the black screen or artifacts.</p>
</div>
<div class="paragraph">
<p>At this point we have defined shaders and a signature. But the gpu doesn&#8217;t know about our shaders - we only have several text files that are useful for us - not the hardware. As you have guessed we need to load our shaders to the graphics card. But first we need to compile them. Later we&#8217;ll use a new addtition to the api which allows us to send this compiled data (and a lot of other stuff) to the gpu - pipeline state object (or pso for short).</p>
</div>
</div>
<div class="sect4">
<h5 id="_pipeline_state_object">Pipeline State Object</h5>
<div class="paragraph">
<p>As you know the gpu is a state machine - once it&#8217;s setted up it will do the same actions over and over again until we change a state. In directx 12 the entire gpu state (plus or minus some minor things) is represented by <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788705(v=vs.85).aspx"><code>ID3D12PipelineState</code></a> interface. This means that if you want to render the same object in wireframe and solid you have to create <code>2</code> such objects which will differ only by fill mode. State creation is a heavy operation that should be avoided in runtime. Instead all states that you need for your scene should be created as a part of initialization.</p>
</div>
<div class="paragraph">
<p>In our demo we&#8217;ll use <code>2</code> states - one for solid rendering and backface culling and another for wireframe rendering and without culling. Creating a state means filling a lot of structures and setting shaders. We&#8217;re compiling our shaders as a build process in Visual Studio. This means that during application start we should have <code>cso</code> files somewhere which we need to load. The loading is very simple and can be done like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; vertexShaderBlob;
Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; hullShaderBlob;
Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; domainShaderBlob;
Microsoft::WRL::ComPtr&lt;ID3DBlob&gt; pixelShaderBlob;

// TeapotTutorial.cpp
void TeapotTutorial::createShaders()
{
	if (FAILED(D3DReadFileToBlob(L"VertexShader.cso", vertexShaderBlob.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error reading vertex shader." });
	}

	if (FAILED(D3DReadFileToBlob(L"HullShader.cso", hullShaderBlob.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error reading hull shader." });
	}

	if (FAILED(D3DReadFileToBlob(L"DomainShader.cso", domainShaderBlob.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error reading domain shader." });
	}

	if (FAILED(D3DReadFileToBlob(L"PixelShader.cso", pixelShaderBlob.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error reading pixel shader." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now the pipeline state creation (remember - we have <code>2</code> states):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12PipelineState&gt; pipelineStateWireframe;
Microsoft::WRL::ComPtr&lt;ID3D12PipelineState&gt; pipelineStateSolid;
Microsoft::WRL::ComPtr&lt;ID3D12PipelineState&gt; currPipelineState;

// TeapotTutorial.cpp
void TeapotTutorial::createPipelineStateWireframe()
{
	pipelineStateWireframe = createPipelineState(D3D12_FILL_MODE_WIREFRAME, D3D12_CULL_MODE_NONE);
	currPipelineState = pipelineStateWireframe;
}

void TeapotTutorial::createPipelineStateSolid()
{
	pipelineStateSolid = createPipelineState(D3D12_FILL_MODE_SOLID, D3D12_CULL_MODE_NONE);
}

ComPtr&lt;ID3D12PipelineState&gt; TeapotTutorial::createPipelineState(D3D12_FILL_MODE fillMode, D3D12_CULL_MODE cullMode)
{
	// #1
	vector&lt;D3D12_INPUT_ELEMENT_DESC&gt; inputElementDescs
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
	};

	// #2
	D3D12_RASTERIZER_DESC rasterizerDesc;
	ZeroMemory(&amp;rasterizerDesc, sizeof(rasterizerDesc));
	rasterizerDesc.FillMode = fillMode;
	rasterizerDesc.CullMode = cullMode;
	rasterizerDesc.FrontCounterClockwise = FALSE;
	rasterizerDesc.DepthBias = D3D12_DEFAULT_DEPTH_BIAS;
	rasterizerDesc.DepthBiasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
	rasterizerDesc.SlopeScaledDepthBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
	rasterizerDesc.DepthClipEnable = TRUE;
	rasterizerDesc.MultisampleEnable = FALSE;
	rasterizerDesc.AntialiasedLineEnable = FALSE;
	rasterizerDesc.ForcedSampleCount = 0;
	rasterizerDesc.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;

	// #3
	D3D12_BLEND_DESC blendDesc;
	ZeroMemory(&amp;blendDesc, sizeof(blendDesc));
	blendDesc.AlphaToCoverageEnable = FALSE;
	blendDesc.IndependentBlendEnable = FALSE;
	blendDesc.RenderTarget[0] = {
		FALSE,FALSE,
		D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
		D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
		D3D12_LOGIC_OP_NOOP,
		D3D12_COLOR_WRITE_ENABLE_ALL
	};

	// #4
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc;
	ZeroMemory(&amp;depthStencilDesc, sizeof(depthStencilDesc));
	depthStencilDesc.DepthEnable = TRUE;
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
	depthStencilDesc.StencilEnable = FALSE;
	depthStencilDesc.StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
	depthStencilDesc.StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
	const D3D12_DEPTH_STENCILOP_DESC defaultStencilOp = { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
	depthStencilDesc.FrontFace = defaultStencilOp;
	depthStencilDesc.BackFace = defaultStencilOp;

	// #5
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineStateDesc;
	ZeroMemory(&amp;pipelineStateDesc, sizeof(pipelineStateDesc));
	pipelineStateDesc.InputLayout = { inputElementDescs.data(), static_cast&lt;UINT&gt;(inputElementDescs.size()) };
	pipelineStateDesc.pRootSignature = rootSignature.Get();
	pipelineStateDesc.VS = { vertexShaderBlob-&gt;GetBufferPointer(), vertexShaderBlob-&gt;GetBufferSize() };
	pipelineStateDesc.HS = { hullShaderBlob-&gt;GetBufferPointer(), hullShaderBlob-&gt;GetBufferSize() };
	pipelineStateDesc.DS = { domainShaderBlob-&gt;GetBufferPointer(), domainShaderBlob-&gt;GetBufferSize() };
	pipelineStateDesc.PS = { pixelShaderBlob-&gt;GetBufferPointer(), pixelShaderBlob-&gt;GetBufferSize() };
	pipelineStateDesc.RasterizerState = rasterizerDesc;
	pipelineStateDesc.BlendState = blendDesc;
	pipelineStateDesc.DepthStencilState = depthStencilDesc;
	pipelineStateDesc.SampleMask = UINT_MAX;
	pipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH;
	pipelineStateDesc.NumRenderTargets = 1;
	pipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	pipelineStateDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;
	pipelineStateDesc.SampleDesc.Count = 1;

	ComPtr&lt;ID3D12PipelineState&gt; pipelineState;
	if (FAILED(device-&gt;CreateGraphicsPipelineState(&amp;pipelineStateDesc, IID_PPV_ARGS(pipelineState.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating pipeline state." });
	}

	return pipelineState;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wow, that&#8217;s a lot of code. Let&#8217;s step through the code line by line. First we create input layout (<strong><mark>1</strong>). In vertex shader we&#8217;re expecting only one input - the control point position so we have only one entry in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn770377(v=vs.85).aspx"><code>D3D12_INPUT_ELEMENT_DESC</code></a> vector. Next we&#8217;re creating a rasterizer state (<strong>#2</strong>). This structure can be replaced with a helper <code>CD3DX12_RASTERIZER_DESC</code> to make it shorter. Next is blend (<strong></mark></strong>) - it can be replaced with <code>CD3DX12_BLEND_DESC</code>. Next is depth stencil (<strong>#4</strong> and <code>CD3DX12_DEPTH_STENCIL_DESC</code>). And finally pipeline state object itself where we assign all the things we created (<strong>#5</strong>). All these structures are pretty simple and I think it should be clear from the names what each field represent so I won&#8217;t describe it in detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Interesting thing - thought we assigned a root signature to pso this assignmend done only for validation, i.e. the api will check that shader inputs correspond to signature parameters. After pipeline state creation the information about root signature is lost and we need to assign it again before drawing.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Yay, we have shaders, we have signature! But we still don&#8217;t have resources. Let&#8217;s fix that.</p>
</div>
</div>
<div class="sect4">
<h5 id="_creating_resources">Creating Resources</h5>
<div class="paragraph">
<p>Let&#8217;s recall what resources do we need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Vertex Buffer</p>
</li>
<li>
<p>Index Buffer</p>
</li>
<li>
<p>Domain Constant Buffer</p>
</li>
<li>
<p>Transforms Structured Buffer</p>
</li>
<li>
<p>Colors Structured Buffer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before we start to create this buffers let&#8217;s understand how gpu stores resources. Similar to descriptors resources are stored in a memory called resource heap. There&#8217;re several types of heaps, but we&#8217;ll use only two - <code>D3D12_HEAP_TYPE_DEFAULT</code> and <code>D3D12_HEAP_TYPE_UPLOAD</code>. The first one is entirely gpu resident - once you create it you can&#8217;t access it on cpu side - even upload initial data. This heap type highly optimized and is faster than others. The second one is accessible by both gpu and cpu. We need a default heap when we have a static data - vertex and index buffers are good candidates. The upload heap is good when we change data every frame - for example a constant buffer. But if we can&#8217;t write data to default buffer how can we use it? We can use some intermediate upload buffer, write data there from cpu and give a command to the gpu to copy the data from upload to default. I wrote "give a command" - yes, that&#8217;t how we communicate with the gpu - we write predefined commands to some list and send this list to the graphic card where it executes.</p>
</div>
<div class="paragraph">
<p>All buffer instantiations are in constructor of our demo class.</p>
</div>
<div class="paragraph">
<p><strong>Vertex Buffer</strong></p>
</div>
<div class="paragraph">
<p>This is a special buffer that doesn&#8217;t requires a descriptor heap (but still requires a descriptor/view).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; controlPointsBuffer;

// TeapotTutorial.cpp
controlPointsBuffer = teapot_tutorial::createVertexBuffer(device.Get(), TeapotData::points, L"control points");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks simple, but it&#8217;s not. Here we can see a helper function <code>teapot_tutorial::createVertexBuffer()</code> which takes a device (remember, we need it to create almost everything for the application), a data and a buffer name. The last parameter is super helpful during debugging - in visual studio graphics debugger we can easily find our buffer knowing it&#8217;s name. This helper function lives in a helper header called <code>Utils.h</code> (surprise surprise) and this is how it&#8217;s defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Utils.h
template&lt;typename T&gt;
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; createVertexBuffer(ID3D12Device* device, const std::vector&lt;T&gt;&amp; data, std::wstring name = L"")
{
	return details::createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function calls another helper function - <code>createDefaultBuffer()</code>;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Utils.h
template&lt;typename T&gt;
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; createDefaultBuffer(ID3D12Device* device, const std::vector&lt;T&gt;&amp; data, D3D12_RESOURCE_STATES finalState, std::wstring name = L"")
{
	UINT elementSize{ static_cast&lt;UINT&gt;(sizeof(T)) };
	UINT bufferSize{ static_cast&lt;UINT&gt;(data.size() * elementSize) };

    // #1
	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(&amp;heapProps, sizeof(heapProps));
	heapProps.Type = D3D12_HEAP_TYPE_DEFAULT;
	heapProps.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask = 1;
	heapProps.VisibleNodeMask = 1;

	// #2
	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(&amp;resourceDesc, sizeof(resourceDesc));
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Alignment = 0;
	resourceDesc.Width = bufferSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.SampleDesc.Quality = 0;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

	// #3
	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; defaultBuffer;
	HRESULT hr{ device-&gt;CreateCommittedResource(
		&amp;heapProps,
		D3D12_HEAP_FLAG_NONE,
		&amp;resourceDesc,
		D3D12_RESOURCE_STATE_COPY_DEST,
		nullptr,
		IID_PPV_ARGS(defaultBuffer.ReleaseAndGetAddressOf())) };

	if (FAILED(hr))
	{
		throw(runtime_error{ "Error creating a default buffer." });
	}

	defaultBuffer-&gt;SetName(name.c_str());

	heapProps.Type = D3D12_HEAP_TYPE_UPLOAD;

	// #4
	Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; uploadBuffer;
	hr = device-&gt;CreateCommittedResource(
		&amp;heapProps,
		D3D12_HEAP_FLAG_NONE,
		&amp;resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(uploadBuffer.ReleaseAndGetAddressOf()));

	if (FAILED(hr))
	{
		throw(runtime_error{ "Error creating an upload buffer." });
	}

	// #5
	ComPtr&lt;ID3D12CommandAllocator&gt; commandAllocator;
	if (FAILED(device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(commandAllocator.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating a command allocator." });
	}

	// #6
	Microsoft::WRL::ComPtr&lt;ID3D12GraphicsCommandList&gt; commandList;
	if (FAILED(device-&gt;CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(commandList.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating a command list." });
	}

	// #7
	D3D12_COMMAND_QUEUE_DESC queueDesc;
	ZeroMemory(&amp;queueDesc, sizeof(queueDesc));
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	queueDesc.NodeMask = 0;

	Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; commandQueue;
	if (FAILED(device-&gt;CreateCommandQueue(&amp;queueDesc, IID_PPV_ARGS(commandQueue.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating a command queue." });
	}

	// #8
	void* pData;
	if (FAILED(uploadBuffer-&gt;Map(0, NULL, &amp;pData)))
	{
		throw(runtime_error{ "Failed map intermediate resource." });
	}

	memcpy(pData, data.data(), bufferSize);
	uploadBuffer-&gt;Unmap(0, NULL);

	// #9
	commandList-&gt;CopyBufferRegion(defaultBuffer.Get(), 0, uploadBuffer.Get(), 0, bufferSize);

	// #10
	D3D12_RESOURCE_BARRIER barrierDesc;
	ZeroMemory(&amp;barrierDesc, sizeof(barrierDesc));
	barrierDesc.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrierDesc.Transition.pResource = defaultBuffer.Get();
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
	barrierDesc.Transition.StateAfter = finalState;
	barrierDesc.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	commandList-&gt;ResourceBarrier(1, &amp;barrierDesc);

	// #11
	commandList-&gt;Close();
	std::vector&lt;ID3D12CommandList*&gt; ppCommandLists{ commandList.Get() };
	commandQueue-&gt;ExecuteCommandLists(static_cast&lt;UINT&gt;(ppCommandLists.size()), ppCommandLists.data());

	// #12
	UINT64 initialValue{ 0 };
	Microsoft::WRL::ComPtr&lt;ID3D12Fence&gt; fence;
	if (FAILED(device-&gt;CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating a fence." });
	}

	// #13
	HANDLE fenceEventHandle{ CreateEvent(nullptr, FALSE, FALSE, nullptr) };
	if (fenceEventHandle == NULL)
	{
		throw(runtime_error{ "Error creating a fence event." });
	}

	// #14
	if (FAILED(commandQueue-&gt;Signal(fence.Get(), 1)))
	{
		throw(runtime_error{ "Error siganalling buffer uploaded." });
	}

	// #15
	if (FAILED(fence-&gt;SetEventOnCompletion(1, fenceEventHandle)))
	{
		throw(runtime_error{ "Failed set event on completion." });
	}

	// #16
	DWORD wait{ WaitForSingleObject(fenceEventHandle, 10000) };
	if (wait != WAIT_OBJECT_0)
	{
		throw(runtime_error{ "Failed WaitForSingleObject()." });
	}

	return defaultBuffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks scary. But going step by step we&#8217;ll get familar with a lot of directx 12 concepts. In the top we&#8217;re creating a couple of structures that describe that we&#8217;re going to create a default heap (<strong>#1</strong>) and a buffer (<strong>#2</strong>). Notice that we&#8217;re not specifying the purpose of the buffer - we&#8217;re just declaring the size. In other words we&#8217;re asking for a certain amount of memory. Among other things notice that <code>Alignment</code> is <code>0</code>. Remember, on previous diagramm we had <code>2</code> numbers for the resource size - the actual data size and the alignement size. We should specify <code>64KB</code> for the buffer or <code>0</code> (which will set it to <code>64KB</code> under the hood). We can use helper structures <code>CD3DX12_HEAP_PROPERTIES</code> and <code>CD3DX12_RESOURCE_DESC</code> here.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re calling <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899178(v=vs.85).aspx"><code>ID3D12Device::CreateCommittedResource()</code></a> method that actually reserves a memory (<strong>#3</strong>). This method asks the gpu to find a free space. There&#8217;re other methods for resource creation - for example we can use already reserved memory and create placed resource in it - just like a <code>placement new</code> operator in c++ (we&#8217;ll not use this in our demo).</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re creating an intermediate resource (<strong>#4</strong>). The only difference is that now we&#8217;re asking for upload heap so we can write to it from the cpu.</p>
</div>
<div class="paragraph">
<p>Please note the <code>4th</code> parameter of <code>`ID3D12Device::CreateCommittedResource()</code> method. We used <code>D3D12_RESOURCE_STATE_COPY_DEST</code> for the default buffer and <code>D3D12_RESOURCE_STATE_GENERIC_READ</code> for upload. This are initial states of our resources. For the performance reasons gpu memory should be in some state when it&#8217;s accessed. Upload buffer should be created with <code>D3D12_RESOURCE_STATE_GENERIC_READ</code> state. And in order to copy from the source to destination the destination should be in <code>D3D12_RESOURCE_STATE_COPY_DEST</code>.</p>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to make a step back and understand how cpu and gpu communicate with each other. Cpu tells gpu what to do via commands. There&#8217;s a special interface <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903537%28v=vs.85%29.aspx"><code>ID3D12GraphicsCommandList</code></a> which have tons of methods and each method is an order to the gpu. Examples of such orders are <code>ClearDepthStencilView()</code> or <code>DrawInstanced()</code>. Command list is a cpu structure meaning that it knows nothing about gpu. The command list doesn&#8217;t create anything. Instead it uses another special interface - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn770463(v=vs.85).aspx"><code>ID3D12CommandAllocator</code></a> (<strong>#5</strong>). This object manages memory for commands and knows about gpu. This two interfaces work together - first we need to create an allocator and later tell command list to use this allocator for command memory allocation.</p>
</div>
<div class="paragraph">
<p>There&#8217;re several types of command lists - copy, compute, bundle. We&#8217;ll use <code>D3D12_COMMAND_LIST_TYPE_DIRECT</code> - this type can record commands of all mentioned types. As list and allocator tied together - they should have the same type.</p>
</div>
<div class="paragraph">
<p>When we create a list it is in a record state that means it&#8217;s ready to receive commands (<strong>#6</strong>). There&#8217;s also <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903895(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::Reset()</code></a> method which allow us to use command list with different allocator.</p>
</div>
<div class="paragraph">
<p>When we have a list filled with commands we need to tell gpu to do some work. We do this with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788627%28v=vs.85%29.aspx"><code>ID3D12CommandQueue</code></a> interface (<strong>#7</strong>). It should be the same type as our list and allocator.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re mapping the system memory to the upload buffer (<strong>#8</strong>) and creating out first command with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903856(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::CopyBufferRegion()</code></a> (<strong>#9</strong>). It will tell the gpu to copy <code>bufferSize</code> amount of data from upload buffer (which actually points to the system memory) to default buffer.</p>
</div>
<div class="paragraph">
<p>After we finished with a resource update we need to transition default buffer to the state that will allow correct access to it. For different resources this state is different. For example for constant or vertex buffer it should be <code>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</code>, for structured buffer - <code>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</code>. So we creating a command that tells gpu to put a transition barrier to necessary state (<strong>#10</strong>). During this transition gpu will not touch the resource and will wait when transition is done. As you may guess this is an expensive operation. We can use helper structure <code>CD3DX12_RESOURCE_BARRIER</code> here.</p>
</div>
<div class="paragraph">
<p>Finally we&#8217;re telling gpu to execute our commands with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788631(v=vs.85).aspx"><code>ID3D12CommandQueue::ExecuteCommandLists ()</code></a> method. But before we need to close command list or we&#8217;ll get an error.</p>
</div>
<div class="paragraph">
<p>If we&#8217;ll exit <code>createDefaultBuffer()</code> method now we&#8217;ll get an undefined behavior. When we&#8217;re telling the gpu to execute a list it doesn&#8217;t start to do it immediately. Instead the commands are queued and nobody knows when they start or finish. That mean that if we leave now the upload buffer will be destroyed (we&#8217;re not keeping a pointer to it) and when the gpu will be ready to execute a copy command the source will not be valid anymore.</p>
</div>
<div class="paragraph">
<p>Previously we talked about cpu-gpu communication. Now we&#8217;re interested in gpu-cpu talk. We do it with fences. Fence is nothing more than an integer value. After we submitted a command list we can add one more command to the queue that will set the fence to the specified value. All we left to do is to check wherether our fence have a correct value or not and if it not - just wait untill it change. Super simple, isn&#8217;t it? First we&#8217;re creating <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899188%28v=vs.85%29.aspx"><code>ID3D12Fence</code></a> itself (<strong>#12</strong>) and also some <code>fenceEventHandle</code> (<strong>#13</strong>). This handle is not a part of <code>directx</code> but <code>winapi</code>. We&#8217;re assigning value to the fence on the gpu with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899171(v=vs.85).aspx"><code>ID3D12CommandQueue::Signal()</code></a> method (<strong>#14</strong>). The first parameter is a fence object and the second is a desired value we want out fence be after the command list executed. Next we&#8217;re setting an event on completion with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899190%28v=vs.85%29.aspx"><code>ID3D12Fence::SetEventOnCompletion()</code></a> method (<strong>#15</strong>). When the fence value will be equal to the first parameter then the event (second parameter) will be raised. In <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx"><code>WaitForSingleObject()</code></a> (<strong>#16</strong>) we&#8217;re waiting when this happens for specified number of seconds (<code>10</code> seconds in our case but can be up to infinite). If at the moment of calling the fence already have a desired value it will return <code>WAIT_OBJECT_0</code> immediately in other case it will wait.</p>
</div>
<div class="paragraph">
<p>Finally we&#8217;re returning created default buffer to the caller.</p>
</div>
<div class="paragraph">
<p>Now we need to create a view for our resource. Remember that resource is just a bunch of data in memory - we need to describe this data so the gpu can use it correctly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
D3D12_VERTEX_BUFFER_VIEW controlPointsBufferView;

// TeapotTutorial.cpp
using PointType = decltype(TeapotData::points)::value_type;

controlPointsBufferView.BufferLocation = controlPointsBuffer-&gt;GetGPUVirtualAddress();
controlPointsBufferView.StrideInBytes = static_cast&lt;UINT&gt;(sizeof(PointType));
controlPointsBufferView.SizeInBytes = static_cast&lt;UINT&gt;(controlPointsBufferView.StrideInBytes * TeapotData::points.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Index Buffer</strong></p>
</div>
<div class="paragraph">
<p>Similar to vertex buffer this buffer doesnât require a descriptor heap.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; controlPointsIndexBuffer;

// TeapotTutorial.cpp
controlPointsIndexBuffer = teapot_tutorial::createIndexBuffer(device.Get(), TeapotData::patches, L"patches");</code></pre>
</div>
</div>
<div class="paragraph">
<p>And</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Utils.h
template&lt;typename T&gt;
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; createIndexBuffer(ID3D12Device* device, const std::vector&lt;T&gt;&amp; data, std::wstring name = L"")
{
	return details::createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_INDEX_BUFFER, name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we changed the final state of our buffer to <code>D3D12_RESOURCE_STATE_INDEX_BUFFER</code>. All other code remains the same as for the vertex buffer.</p>
</div>
<div class="paragraph">
<p>The view is also very simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
D3D12_INDEX_BUFFER_VIEW controlPointsIndexBufferView;

// TeapotTutorial.cpp
controlPointsIndexBufferView.BufferLocation = controlPointsIndexBuffer-&gt;GetGPUVirtualAddress();
controlPointsIndexBufferView.Format = DXGI_FORMAT_R32_UINT;
controlPointsIndexBufferView.SizeInBytes = static_cast&lt;UINT&gt;(TeapotData::patches.size() * sizeof(uint32_t));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Structured buffers</strong></p>
</div>
<div class="paragraph">
<p>Resource creation for this buffers is also the same as for previous buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; transformsBuffer;
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; colorsBuffer;

// TeapotTutorial.cpp
transformsBuffer = teapot_tutorial::createStructuredBuffer(device.Get(), TeapotData::patchesTransforms, L"transforms");
colorsBuffer = teapot_tutorial::createStructuredBuffer(device.Get(), TeapotData::patchesColors, L"colors");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>createStructuredBuffer</code> defined as here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Utils.h
template&lt;typename T&gt;
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; createStructuredBuffer(ID3D12Device* device, const std::vector&lt;T&gt;&amp; data, std::wstring name = L"")
{
	return details::createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This buffer finally needs a descriptor heap which we&#8217;re creating with the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; transformsAndColorsDescHeap;

// TeapotTutorial.cpp
void TeapotTutorial::createTransformsAndColorsDescHeap()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(&amp;heapDesc, sizeof(heapDesc));
	heapDesc.NumDescriptors = 2;
	heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	heapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	heapDesc.NodeMask = 0;

	if (FAILED(device-&gt;CreateDescriptorHeap(&amp;heapDesc, IID_PPV_ARGS(transformsAndColorsDescHeap.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating descriptor heap." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we&#8217;re specifying that we need a heap for <code>2</code> descriptors. Remember - we have <code>2</code> structured buffers - transforms and colors. Next we&#8217;re telling that we want this heap to be accessible from the shader. Examples of non shader visible heaps are render target view or stream output. Also we&#8217;re defining a type. Constant buffer, srv and uav descriptors can leave in the same heap and this is for good - having many heaps and switching between them is not performance friendly.</p>
</div>
<div class="paragraph">
<p>Now when we have a heap we need to fill it with descriptors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.cpp
using TransformType = decltype(TeapotData::patchesTransforms)::value_type;
using ColorType = decltype(TeapotData::patchesColors)::value_type;

teapot_tutorial::createSrv&lt;TransformType&gt;(device.Get(), transformsAndColorsDescHeap.Get(), 0, transformsBuffer.Get(), TeapotData::patchesTransforms.size());
teapot_tutorial::createSrv&lt;ColorType&gt;(device.Get(), transformsAndColorsDescHeap.Get(), 1, colorsBuffer.Get(), TeapotData::patchesColors.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we&#8217;re calling a method from our <code>Utils.h</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Utils.h
template&lt;typename T&gt;
void createSrv(ID3D12Device* device, ID3D12DescriptorHeap* descHeap, int offset, ID3D12Resource* resource, size_t numElements)
{
	// #1
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc;
	ZeroMemory(&amp;srvDesc, sizeof(srvDesc));
	srvDesc.Format = DXGI_FORMAT_UNKNOWN;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.FirstElement = 0;
	srvDesc.Buffer.NumElements = static_cast&lt;UINT&gt;(numElements);
	srvDesc.Buffer.StructureByteStride = static_cast&lt;UINT&gt;(sizeof(T));
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

	// #2
	static UINT descriptorSize{ device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV) };
	D3D12_CPU_DESCRIPTOR_HANDLE d{ descHeap-&gt;GetCPUDescriptorHandleForHeapStart() };
    // #3
	d.ptr += descriptorSize * offset;
    // #4
	device-&gt;CreateShaderResourceView(resource, &amp;srvDesc, d);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re describing a view with the struct <code>D3D12_SHADER_RESOURCE_VIEW_DESC</code> (<strong>#1</strong>). Since we can have arbitrary stride in structured buffer the format should defined as <code>DXGI_FORMAT_UNKNOWN</code>. <code>Shader4ComponentMapping</code> is a bit confusing for me - it looks like we can force some components be <code>0</code> or <code>1</code>. We don&#8217;t need this so we&#8217;re using default mapping, but if you have information how this can be useful please write in comments. All other parameters are pretty strightforward.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re creating descriptor in the heap. Descritors for constant buffer, srv and uav have the same size (but can differ in size among hardware vendors) and we&#8217;re requesting this size with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899186(v=vs.85).aspx"><code>ID3D12Device::GetDescriptorHandleIncrementSize()</code></a> method (<strong>#2</strong>). We&#8217;re searching the place in the heap where we can create a descriptor (<strong>#3</strong>). The very first descriptor we can put in the heap start but for the next descriptor we need to offset position by the size of the descriptor. And finally we&#8217;re asking the device to create specified descriptor in specified place (<strong>#4</strong>).</p>
</div>
<div class="paragraph">
<p><strong>Constant buffers</strong></p>
</div>
<div class="paragraph">
<p>The last resources left are constant buffers. If you refer back to theroot signature section you&#8217;ll recal that we don&#8217;t need resource and descriptor for tesselation factors for the hull shader since we&#8217;re storing constants directly in the signature. So nothing to do here, moving on to the next buffer.</p>
</div>
<div class="paragraph">
<p>Constant buffer for domain shader stores a matrix. Recall that we store descriptor for this resource in the root signature so no need in descriptor heap. But we still need a resource itself. If you&#8217;ll look at the diagram we drew before you&#8217;ll notice that we still don&#8217;t know the size of the buffer. Let&#8217;s figure out why.</p>
</div>
<div class="paragraph">
<p>As you remember the commands are stored in the queue and don&#8217;t execute immediately after submission. Cpu and gpu have different timelines. Now imagine that we submitted a matrix for frame <code>1</code> to constant buffer. Gpu is not executing yet. Now on cpu we&#8217;re executing frame <code>2</code> and we need to update the matrix. If we&#8217;ll write to the same place we did before the matrix from the frame <code>1</code> will be lost for the gpu. Or even worse - imagine that gpu starts reading the matrix at the moment we&#8217;re updating it. How can we fix this? We can do exactly how we did when we created a default buffer. We can put a fence and stall the cpu until gpu finishes reading the matrix. As you understand this is not the way to go - when the cpu work gpu is idle and vice versa even if cpu and gpu can complete their tasks with the same speed. The solution is to have several buffers - in thi cace the cpu can update buffers safely. This is the same reason why we have several back buffers - we&#8217;re displaying one while writing to another.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Several buffers is not a silver buller. There still can be a situation when the cpu is faster than gpu and we need to syncronize anyway.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So how much buffers do we need? Usually <code>2</code> or <code>3</code> is enough. In the demo I made this number adjustible but by default using <code>3</code>. That means that we need to create <code>3</code> constant buffers. Or create one big buffer that can fit <code>3</code> matrices (remember that resource is just a blob of memory). This is how we create our resource:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.h
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; constBuffer;

// TeapotTutorial.cpp
void TeapotTutorial::createConstantBuffer()
{
	UINT elementSizeAligned{ (sizeof(XMFLOAT4X4) + 255) &amp; ~255 };
	UINT64 bufferSize{ elementSizeAligned * bufferCount };

	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(&amp;heapProps, sizeof(heapProps));
	heapProps.Type = D3D12_HEAP_TYPE_UPLOAD;
	heapProps.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask = 1;
	heapProps.VisibleNodeMask = 1;

	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(&amp;resourceDesc, sizeof(resourceDesc));
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Alignment = 0;
	resourceDesc.Width = bufferSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.SampleDesc.Quality = 0;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

	HRESULT hr{ device-&gt;CreateCommittedResource(
		&amp;heapProps,
		D3D12_HEAP_FLAG_NONE,
		&amp;resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(constBuffer.ReleaseAndGetAddressOf())
	) };

	if (FAILED(hr))
	{
		throw(runtime_error{ "Error creating constant buffer." });
	}

	constBuffer-&gt;SetName(L"constants");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since constant buffer will be updated every frame there&#8217;s no need to create it with default type. The read of constant buffer in directx 12 should be aligned by <code>256B</code>. If we have <code>4x4</code> matrix of <code>float</code> which requires <code>16 * 4 = 64B</code> we can&#8217;t place the next matrix immediately after it or we&#8217;ll break the alignment rule and will get an error. So our total size for <code>3</code> buffers will be <code>3 * 256 = 768B</code>. And since constant buffer is just a usual buffer it will be aligned by <code>64KB</code>. Finally we can finish our diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://raw.githubusercontent.com/nikitablack/nikitablack.github.io/master/images/teapot_tutorial/shader_res_3.png"><img src="/images/teapot_tutorial/shader_res_3.png" alt="Shader Resources" width="800"></a>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The weird looking line <code>(sizeof(XMFLOAT4X4) + 255) &amp; ~255</code> calculates the next multiple of <code>256</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One more time, since this is very important - in our case we have <code>1</code> buffer which can hold <code>3</code> matrices. In every frame we can safely update corresponding matrix. Let&#8217;s call this frames <em>buffered frames</em>. But if we have all <code>3</code> frames in flight (i.e. gpu not finished to render any of them yet) we can&#8217;t update out buffer and we have to wait.</p>
</div>
<div class="paragraph">
<p>At this point we have shaders, device and resources but we&#8217;re still not ready to draw. We don&#8217;t have a buffer to draw, a swap chain to present a back buffer and some other things.</p>
</div>
</div>
<div class="sect4">
<h5 id="_directx_initialization_part_2">DirectX Initialization part 2</h5>
<div class="paragraph">
<p>You already know what are command lists, command allocator, fences - we used them when we created our resources. We need the same resources for rendering - after all rendering is just commands to the gpu what to do.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We could create one command list, allocator, fence for entire application and reuse it for rendering, resource creation but I decided to use more functional approach and for simplicity created an isolated function for resource creation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Remember when we discussed matrix constant buffer we decided to use multiple buffers to avoid stalls and you know that we should use several resources for buffered frames (we&#8217;re using <code>3</code> frames by default but this number can be changed). So for rendering we need to use <code>3</code> command allocators, <code>3</code> fences but only one command list. This is because when we&#8217;re resetting a list it can be reused immediately - the memory for commands managed by the allocator. So we can reuse the same list with several allocators.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If we would use multiple threads for commands creation submission, we have to use <code>3 * numTheads</code> allocators and <code>numThreads</code> lists. That&#8217;s because when the list is in use with particular allocator it can&#8217;t be used with another until it closed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is how we&#8217;re creating necessary data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
std::vector&lt;Microsoft::WRL::ComPtr&lt;ID3D12CommandAllocator&gt;&gt; commandAllocators;
Microsoft::WRL::ComPtr&lt;ID3D12GraphicsCommandList&gt; commandList;
std::vector&lt;Microsoft::WRL::ComPtr&lt;ID3D12Fence&gt;&gt; fences;
std::vector&lt;UINT64&gt; fenceValues;
HANDLE fenceEventHandle;

// Graphics.cpp
void Graphics::createCommandAllocators()
{
	for (UINT i{ 0 }; i &lt; bufferCount; i++)
	{
		ComPtr&lt;ID3D12CommandAllocator&gt; commandAllocator;
		if (FAILED(device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(commandAllocator.ReleaseAndGetAddressOf()))))
		{
			throw(runtime_error{ "Error creating command allocator." });
		}

		commandAllocators.push_back(commandAllocator);
	}
}

void Graphics::createCommandList()
{
	if (FAILED(device-&gt;CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocators[0].Get(), nullptr, IID_PPV_ARGS(commandList.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating command list." });
	}

	if (FAILED(commandList-&gt;Close()))
	{
		throw(runtime_error{ "Error closing command list." });
	}
}

void Graphics::createFences()
{
	for (UINT i{ 0 }; i &lt; bufferCount; i++)
	{
		UINT64 initialValue{ 0 };
		ComPtr&lt;ID3D12Fence&gt; fence;
		if (FAILED(device-&gt;CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.ReleaseAndGetAddressOf()))))
		{
			throw(runtime_error{ "Error creating fence." });
		}

		fences.push_back(fence);
		fenceValues.push_back(initialValue);
	}
}

void Graphics::createFenceEventHandle()
{
	fenceEventHandle = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	if (fenceEventHandle == NULL)
	{
		throw(runtime_error{ "Error creating fence event." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All this code should be already familar to you. Here we&#8217;re creating allocators, a list and we&#8217;re closing it because we&#8217;re not going to use it now, fences - one for each buffered frame and one handle. We need multiple fences by the same reason we need multiple allocators. Imagine we submitted commands for frame <code>1</code> and told the queue to set a fence after this frame. We do the same for frames <code>2</code> and <code>3</code>. Now when we&#8217;re ready to reuse allocator <code>1</code> we need to check fence value <code>1</code> - not <code>2</code> or <code>3</code> (they still can be in use) and if the value is what we&#8217;re expecting we can safely reuse the memory. In other case we need to wait.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;ll create command queue and  swap chain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; commandQueue;
Microsoft::WRL::ComPtr&lt;IDXGISwapChain3&gt; swapChain;

// Graphics.cpp
void Graphics::createCommandQueue()
{
	D3D12_COMMAND_QUEUE_DESC queueDesc;
	ZeroMemory(&amp;queueDesc, sizeof(queueDesc));
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	queueDesc.NodeMask = 0;

	HRESULT hr{ device-&gt;CreateCommandQueue(&amp;queueDesc, IID_PPV_ARGS(commandQueue.ReleaseAndGetAddressOf())) };
	if (FAILED(hr))
	{
		throw(runtime_error{ "Error creating command queue." });
	}
}

void Graphics::createSwapChain()
{
	POINT wSize(window-&gt;getSize());

	DXGI_SWAP_CHAIN_DESC1 swapChainDesc;
	ZeroMemory(&amp;swapChainDesc, sizeof(swapChainDesc));
	swapChainDesc.Width = static_cast&lt;UINT&gt;(wSize.x);
	swapChainDesc.Height = static_cast&lt;UINT&gt;(wSize.y);
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	swapChainDesc.Stereo = FALSE;
	swapChainDesc.SampleDesc = { 1, 0 }; // no anti-aliasing
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.BufferCount = bufferCount;
	swapChainDesc.Scaling = DXGI_SCALING_NONE;
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
	swapChainDesc.Flags = 0;

	ComPtr&lt;IDXGISwapChain1&gt; swapChain1;
	if (FAILED(factory-&gt;CreateSwapChainForHwnd(commandQueue.Get(), window-&gt;getHandle(), &amp;swapChainDesc, nullptr, nullptr, swapChain1.ReleaseAndGetAddressOf())))
	{
		throw(runtime_error{ "Error creating IDXGISwapChain1." });
	}

	if (FAILED(swapChain1.As(&amp;swapChain)))
	{
		throw(runtime_error{ "Error creating IDXGISwapChain3." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be familar with command queue. The swap chain concept didn&#8217;t change since directx 11 the only interesting thing is that you need to specify command queue during swap chain creation. Here <code>bufferCount</code> variable is a number of buffered frames.</p>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to create back buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
std::vector&lt;Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt;&gt; swapChainBuffers;
Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; descHeapRtv;

// Graphics.cpp
void Graphics::getSwapChainBuffers()
{
	for (UINT i{ 0 }; i &lt; bufferCount; i++)
	{
		if (FAILED(swapChain-&gt;GetBuffer(i, IID_PPV_ARGS(swapChainBuffers[i].ReleaseAndGetAddressOf()))))
		{
			throw(runtime_error{ "Error getting buffer." });
		}
	}
}

void Graphics::createDescriptoprHeapRtv()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(&amp;heapDesc, sizeof(heapDesc));
	heapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	heapDesc.NumDescriptors = bufferCount;
	heapDesc.NodeMask = 0;
	heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;

	if (FAILED(device-&gt;CreateDescriptorHeap(&amp;heapDesc, IID_PPV_ARGS(descHeapRtv.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating descriptor heap." });
	}

	UINT rtvStep{ device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV) };
	for (UINT i{ 0 }; i &lt; bufferCount; i++)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE d = descHeapRtv-&gt;GetCPUDescriptorHandleForHeapStart();
		d.ptr += i * rtvStep;
		device-&gt;CreateRenderTargetView(swapChainBuffers[i].Get(), nullptr, d);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we specified the number of back buffers in swap chain creation they become created implicitly so we don&#8217;t need to create resources manualy. But we still need to create descriptors for all our back buffers. In <code>Graphics::getSwapChainBuffers()</code> we&#8217;re obtaining pointers to created resources and in <code>Graphics::createDescriptoprHeapRtv()</code> we&#8217;re creating a descriptor heap (recal that descriptors should be stored somewhere) with the type <code>D3D12_DESCRIPTOR_HEAP_TYPE_RTV</code> and big enough to store necessary amount of views. Next we&#8217;re iterating over obtained buffer pointers and for every resource we&#8217;re creating a corresponding view (recal that <code>ID3D12Device::GetDescriptorHandleIncrementSize</code> is a cross vendor way to get descriptor size).</p>
</div>
<div class="paragraph">
<p>For our demo we also need a depth buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.h
Microsoft::WRL::ComPtr&lt;ID3D12Resource&gt; depthStencilBuffer;
Microsoft::WRL::ComPtr&lt;ID3D12DescriptorHeap&gt; descHeapDepthStencil;

// Graphics.cpp
void Graphics::createDepthStencilBuffer()
{
	D3D12_CLEAR_VALUE depthOptimizedClearValue;
	ZeroMemory(&amp;depthOptimizedClearValue, sizeof(depthOptimizedClearValue));
	depthOptimizedClearValue.Format = DXGI_FORMAT_D32_FLOAT;
	depthOptimizedClearValue.DepthStencil.Depth = 1.0f;
	depthOptimizedClearValue.DepthStencil.Stencil = 0;

	POINT wSize(window-&gt;getSize());

	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(&amp;heapProps, sizeof(heapProps));
	heapProps.Type = D3D12_HEAP_TYPE_DEFAULT;
	heapProps.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask = 1;
	heapProps.VisibleNodeMask = 1;

	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(&amp;resourceDesc, sizeof(resourceDesc));
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	resourceDesc.Alignment = 0;
	resourceDesc.Width = wSize.x;
	resourceDesc.Height = wSize.y;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 0;
	resourceDesc.Format = DXGI_FORMAT_D32_FLOAT;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.SampleDesc.Quality = 0;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

	HRESULT hr{ device-&gt;CreateCommittedResource(
		&amp;heapProps,
		D3D12_HEAP_FLAG_NONE,
		&amp;resourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&amp;depthOptimizedClearValue,
		IID_PPV_ARGS(depthStencilBuffer.ReleaseAndGetAddressOf())
	) };

	if (FAILED(hr))
	{
		throw(runtime_error{ "Error creating depth stencil buffer." });
	}
}

void Graphics::createDescriptorHeapDepthStencil()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(&amp;heapDesc, sizeof(heapDesc));
	heapDesc.NumDescriptors = 1;
	heapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;

	if (FAILED(device-&gt;CreateDescriptorHeap(&amp;heapDesc, IID_PPV_ARGS(descHeapDepthStencil.ReleaseAndGetAddressOf()))))
	{
		throw(runtime_error{ "Error creating depth stencil descriptor heap." });
	}

	D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	ZeroMemory(&amp;depthStencilViewDesc, sizeof(depthStencilViewDesc));
	depthStencilViewDesc.Format = DXGI_FORMAT_D32_FLOAT;
	depthStencilViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Flags = D3D12_DSV_FLAG_NONE;

	device-&gt;CreateDepthStencilView(depthStencilBuffer.Get(), &amp;depthStencilViewDesc, descHeapDepthStencil-&gt;GetCPUDescriptorHandleForHeapStart());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing special here - we&#8217;re creating a resource heap with default type (depth buffer used by gpu without cpu access) and a texture resource. Field names are self explanatory - dimension, size, etc. In flags we&#8217;re specifying that we want to use this texture as depth stencil. And as we did million times already we`re creating a descriptor heap and a descriptor inside it.</p>
</div>
<div class="paragraph">
<p>Wow. Finally. We&#8217;re ready to draw!</p>
</div>
</div>
<div class="sect4">
<h5 id="_rendering">Rendering</h5>
<div class="paragraph">
<p>We have everything for our demo - all resources and infrastructure. Now we&#8217;ll call <code>TeapotTutorial::render()</code> method every frame where we&#8217;ll tell gpu to use resources and run shaders.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// TeapotTutorial.cpp
void TeapotTutorial::render()
{
	// #1
	UINT frameIndex{ swapChain-&gt;GetCurrentBackBufferIndex() };

	// #2
	ComPtr&lt;ID3D12CommandAllocator&gt; commandAllocator{ commandAllocators[frameIndex] };

	if (FAILED(commandAllocator-&gt;Reset()))
	{
		throw(runtime_error{ "Error resetting command allocator." });
	}

	if (FAILED(commandList-&gt;Reset(commandAllocator.Get(), nullptr)))
	{
		throw(runtime_error{ "Error resetting command list." });
	}

	// #3
	commandList-&gt;SetPipelineState(currPipelineState.Get());
	commandList-&gt;SetGraphicsRootSignature(rootSignature.Get());
	commandList-&gt;RSSetViewports(1, &amp;viewport);
	commandList-&gt;RSSetScissorRects(1, &amp;scissorRect);

	// #4
	ID3D12Resource* currBuffer{ swapChainBuffers[frameIndex].Get() };

	// #5
	D3D12_RESOURCE_BARRIER barrierDesc;
	ZeroMemory(&amp;barrierDesc, sizeof(barrierDesc));
	barrierDesc.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Transition.pResource = currBuffer;
	barrierDesc.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierDesc.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	commandList-&gt;ResourceBarrier(1, &amp;barrierDesc);

	// #6
	static UINT descriptorSize{ device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV) };
	D3D12_CPU_DESCRIPTOR_HANDLE descHandleRtv(descHeapRtv-&gt;GetCPUDescriptorHandleForHeapStart());
	descHandleRtv.ptr += frameIndex * descriptorSize;

	D3D12_CPU_DESCRIPTOR_HANDLE descHandleDepthStencil(descHeapDepthStencil-&gt;GetCPUDescriptorHandleForHeapStart());

	commandList-&gt;OMSetRenderTargets(1, &amp;descHandleRtv, FALSE, &amp;descHandleDepthStencil);

	// #7
	static float clearColor[]{ 0.1f, 0.1f, 0.1f, 1.0f };
	commandList-&gt;ClearRenderTargetView(descHandleRtv, clearColor, 0, nullptr);
	commandList-&gt;ClearDepthStencilView(descHeapDepthStencil-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
	commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST);

	// #8
	vector&lt;D3D12_VERTEX_BUFFER_VIEW&gt; myArray{ controlPointsBufferView };
	commandList-&gt;IASetVertexBuffers(0, static_cast&lt;UINT&gt;(myArray.size()), myArray.data());

	// #9
	vector&lt;int&gt; rootConstants{ tessFactor, tessFactor };
	commandList-&gt;SetGraphicsRoot32BitConstants(1, static_cast&lt;UINT&gt;(rootConstants.size()), rootConstants.data(), 0);

	// #10
	ID3D12DescriptorHeap* ppHeaps[] = { transformsAndColorsDescHeap.Get() };
	commandList-&gt;SetDescriptorHeaps(1, ppHeaps);
	D3D12_GPU_DESCRIPTOR_HANDLE d { transformsAndColorsDescHeap-&gt;GetGPUDescriptorHandleForHeapStart() };
	d.ptr += 0;
	commandList-&gt;SetGraphicsRootDescriptorTable(2, d);

	// #11
	POINT windowSize(window-&gt;getSize());
	float ratio{ static_cast&lt;float&gt;(windowSize.x) / static_cast&lt;float&gt;(windowSize.y) };
	XMMATRIX projMatrixDX{ XMMatrixPerspectiveFovLH(XMConvertToRadians(45), ratio, 1.0f, 100.0f) };

	XMVECTOR camPositionDX(XMVectorSet(0.0f, 0.0f, -10.0f, 0.0f));
	XMVECTOR camLookAtDX(XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f));
	XMVECTOR camUpDX(XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f));
	XMMATRIX viewMatrixDX{ XMMatrixLookAtLH(camPositionDX, camLookAtDX, camUpDX) };

	XMMATRIX viewProjMatrixDX{ viewMatrixDX * projMatrixDX };
	UINT constDataSizeAligned{ (sizeof(XMFLOAT4X4) + 255) &amp; ~255 };

	POINT mousePoint(window-&gt;getMousePosition());
	float pitch{ -XMConvertToRadians((mousePoint.x - (static_cast&lt;float&gt;(windowSize.x) / 2.0f)) / (static_cast&lt;float&gt;(windowSize.x) / 2.0f) * 180.0f) };
	float roll{ XMConvertToRadians((mousePoint.y - (static_cast&lt;float&gt;(windowSize.y) / 2.0f)) / (static_cast&lt;float&gt;(windowSize.y) / 2.0f) * 180.0f) };

	XMMATRIX modelMatrixRotationDX{ XMMatrixRotationRollPitchYaw(roll, pitch, 0.0f) };
	XMMATRIX modelMatrixTranslationDX{ XMMatrixTranslation(0.0f, -1.0f, 0.0f) };
	XMMATRIX modelMatrixDX{ modelMatrixRotationDX * modelMatrixTranslationDX };
	XMFLOAT4X4 mvpMatrix;
	XMStoreFloat4x4(&amp;mvpMatrix, modelMatrixDX * viewProjMatrixDX);

	// #12
	D3D12_RANGE readRange = {0, 0};
	uint8_t* cbvDataBegin;
	constBuffer-&gt;Map(0, &amp;readRange, reinterpret_cast&lt;void**&gt;(&amp;cbvDataBegin));
	memcpy(&amp;cbvDataBegin[frameIndex * constDataSizeAligned], &amp;mvpMatrix, sizeof(mvpMatrix));
	constBuffer-&gt;Unmap(0, nullptr);

	// #13
	commandList-&gt;SetGraphicsRootConstantBufferView(0, constBuffer-&gt;GetGPUVirtualAddress() + frameIndex * constDataSizeAligned);

	// #14
	commandList-&gt;IASetIndexBuffer(&amp;controlPointsIndexBufferView);

	// #15
	uint32_t numIndices{ controlPointsIndexBufferView.SizeInBytes / sizeof(uint32_t) };
	commandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0);

	// #16
	ZeroMemory(&amp;barrierDesc, sizeof(barrierDesc));
	barrierDesc.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Transition.pResource = currBuffer;
	barrierDesc.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	barrierDesc.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	commandList-&gt;ResourceBarrier(1, &amp;barrierDesc);

	// #17
	if (FAILED(commandList-&gt;Close()))
	{
		throw(runtime_error{ "Failed closing command list." });
	}

	// #18
	ID3D12CommandList* cmdList{ commandList.Get() };
	commandQueue-&gt;ExecuteCommandLists(1, &amp;cmdList);

	// #19
	if (FAILED(swapChain-&gt;Present(1, 0)))
	{
		throw(runtime_error{ "Failed present." });
	}

	// #20
	UINT64&amp; fenceValue{ fenceValues[frameIndex] };
	++fenceValue;
	ComPtr&lt;ID3D12Fence&gt; fence{ fences[frameIndex] };
	if (FAILED(commandQueue-&gt;Signal(fence.Get(), fenceValue)))
	{
		throw(runtime_error{ "Failed signal." });
	}

	// #21
	waitFrameComplete(swapChain-&gt;GetCurrentBackBufferIndex());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As usual we&#8217;ll go step by step.</p>
</div>
<div class="paragraph">
<p><code>IDXGISwapChain3</code> have a very handy method <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903675(v=vs.85).aspx">IDXGISwapChain3::GetCurrentBackBufferIndex()</a> (<strong>#1</strong>). It shows the index of the current back buffer. In the beginnig the index is <code>0</code> and after calling <code>IDXGISwapChain::Present()</code> it will change to <code>2</code> (if we have more than <code>1</code> buffer of course). So we don&#8217;t need to track manually the current frame.</p>
</div>
<div class="paragraph">
<p>Using current frame index we can obtain a corresponding allocator (<strong>#2</strong>). We need to reset it before we can start to work with it. Remember that we need to be sure that there&#8217;re no more commands in flight from this allocator so we&#8217;ll not break anything. Also we need to tell our command list that we&#8217;re going to use this allocator with it.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re setting pso, signature, viewport and scissor rect (<strong>#3</strong>). We didn&#8217;t discuss the last two objects. They&#8217;re pretty strightforward and created with other resources in constructor (please refer to <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/TeapotTutorial.cpp">github</a>).</p>
</div>
<div class="paragraph">
<p>Also we need to get a pointer to the current back buffer (<strong>#4</strong>) since we&#8217;ll use it several times.</p>
</div>
<div class="paragraph">
<p>Now when we have a back buffer we need to move it to the correct state. Since we&#8217;re going to render a teapot into it the state should be <code>D3D12_RESOURCE_STATE_RENDER_TARGET</code> (<strong>#5</strong>).</p>
</div>
<div class="paragraph">
<p>Next we need to say gpu that we want to use this back buffer as a render target. But we can&#8217;t do it directly. Instead we need to set the view that describes this buffer. As you know all views are stored in descriptor heap. All we need to do is to calculate the correct offset from the heap start (<strong>#6</strong>). And we&#8217;re doing the same for the depth buffer (we have only one depth buffer so the descriptor and heap have same addreses).</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re clearing render target and depth buffer to some initial values and also specifying the topology we&#8217;re going to use in this draw - <code>D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST</code> (<strong>#7</strong>).</p>
</div>
<div class="paragraph">
<p>Next we need to specify a vertex buffer. Again, we&#8217;re doing it with a view (<strong>#8</strong>).</p>
</div>
<div class="paragraph">
<p>Do you remember how we created our root signature? The second parameter were <code>2</code> root constants for the hull shader. We&#8217;re using single <code>tessFactor</code> constant for both edge and inside factors and we&#8217;re setting this constant with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903910(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants()</code></a> method specifying the position in the root signature (<strong>#9</strong>).</p>
</div>
<div class="paragraph">
<p>Third parameter in the root signature was a descriptor table. Recall that the table points to a continious range of descriptors in descriptor heap. During parameter creation we specified that we&#8217;ll use <code>2</code> descriptors. All we have to do is to pass an address of the first descriptor in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903912(v=vs.85).aspx"><code>ID3D12GraphicsCommandList&#8594;SetGraphicsRootDescriptorTable()</code></a> method (<strong>#10</strong>). But before we need to set a correct descriptor heap or we&#8217;ll get an error.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re doing some math (<strong>#11</strong>) - creating a projection matrix, view matrix, rotating our model depending on mouse position. And updating our upload constant buffer with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788712%28v=vs.85%29.aspx"><code>ID3D12Resource&#8594;Map()</code></a> method (<strong>#12</strong>). As you remember our constant buffer store data for all our buffered frames. In order to write to the correct place we need to use a correct offset from the start of the buffer (don&#8217;t forget about <code>256B</code> alignment).</p>
</div>
<div class="paragraph">
<p>Now when we have updated constant buffer we&#8217;re ready to finish with the root signature. We&#8217;re setting the last parameter - root descriptor as a first parameter not forgetting the correct offset from descriptor heap start (<strong>#13</strong>).</p>
</div>
<div class="paragraph">
<p>Next we&#8217;re setting index buffer via view (<strong>#14</strong>) and drawing (<strong>#15</strong>).</p>
</div>
<div class="paragraph">
<p>If you&#8217;re thinking that after drawing we can relax - I&#8217;ll upset you. We still need some work to do. Remember that before drawing to a back buffer we set it&#8217;s state as <code>D3D12_RESOURCE_STATE_RENDER_TARGET</code>. In order to be presented the buffer have to be in <code>D3D12_RESOURCE_STATE_PRESENT</code> state (<strong>#16</strong>).</p>
</div>
<div class="paragraph">
<p>Now when we&#8217;re done with command list we need to close it (<strong>#17</strong>) and send it to the command queue for execution (<strong>#18</strong>).</p>
</div>
<div class="paragraph">
<p>After calling <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174576(v=vs.85).aspx"><code>IDXGISwapChain&#8594;Present()</code></a> (<strong>#19</strong>) we need to tell the gpu to increment corresponding fence after frame will finish (<strong>#20</strong>). Exactly how we did during default buffer creation. For example if we rendered a frame <code>0</code> we need to update a fence <code>0</code> for this frame and store the updated value (also with index <code>0</code>) on cpu. This way we can anytime check the current value of fence <code>0</code> and say for sure if it&#8217;s done or not. And we&#8217;re doing it in <code>waitFrameComplete()</code> function (<strong>#21</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.cpp
void Graphics::waitFrameComplete(UINT frameIndex)
{
	UINT64 fenceValue{ fenceValues[frameIndex] };
	ComPtr&lt;ID3D12Fence&gt; fence{ fences[frameIndex] };

	if (FAILED(fence-&gt;SetEventOnCompletion(fenceValue, fenceEventHandle)))
	{
		throw(runtime_error{ "Failed set event on completion." });
	}

	DWORD wait{ WaitForSingleObject(fenceEventHandle, 10000) };
	if (wait != WAIT_OBJECT_0)
	{
		throw(runtime_error{ "Failed WaitForSingleObject()." });
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One more time - imagine we just finished a frame with index <code>2</code>. Since we have <code>3</code> buffered frames total the next index will be <code>0</code>. In <code>waitFrameComplete()</code> we&#8217;re checking the status of frame <code>0</code> - if it&#8217;s still in flight we have to stall and wait until fence will be equal to the expected value.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cleanup">Cleanup</h5>
<div class="paragraph">
<p>One thing we didn&#8217;t mention is cleaning. But it&#8217;s pretty simple - since we used smart pointers we don&#8217;t need to delete pointers manually. The only thing we need to take care of is to be sure that during resources desctruction gpu finished with them. We can do it with good old fences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Graphics.cpp
Graphics::~Graphics()
{
	for (UINT i{ 0 }; i &lt; bufferCount; i++)
	{
		waitFrameComplete(i);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here I just iterate over all buffered frames and check that all they are done.</p>
</div>
</div>
<div class="sect4">
<h5 id="_conclusion">Conclusion</h5>
<div class="paragraph">
<p>Wow, that&#8217;s was a really long journey. As you can see there&#8217;s a lot of code for such a simple application but most of this code can be abstracted with reusable structures like ones in <code>d3dx12.h</code>.</p>
</div>
<div class="paragraph">
<p>What we did today is just scratched a surface - directx12 api is very complex and still evolving. But I encourage you to continue investigation - after all it&#8217;s so fun :)</p>
</div>
<div class="paragraph">
<p>The video below shows the result of work we done. And <a href="https://github.com/nikitablack/directx-12/tree/master/TeapotTutorial/TeapotTutorial">here</a> is the full source.</p>
</div>
<div class="videoblock">
<div class="content">
<iframe width="480" height="300" src="//www.youtube.com/embed/m5Lac8TNsc0?rel=0&amp;list=" frameborder="0" allowfullscreen></iframe>
</div>
</div>
</div>
        </div>


        <footer class="post-footer" role="contentinfo">

            <div class="vcard">
                <a href="https://nikitablack.github.io/rss/feed.rss" id="btn_feed" class="btn" title="Feed" target="_blank">
                    <span aria-hidden="true" data-icon=")"></span>
                    <strong>Feed</strong>
                </a>

                <a href="" class="photo">
                    <span style="background-image: url('https://avatars.githubusercontent.com/u/6390092?v=3');">
                        <img src="https://avatars.githubusercontent.com/u/6390092?v=3" alt="nikitablack">
                    </span>
                </a>

                <div class="details">
                    <h4><a href="" class="url n">nikitablack</a></h4>
                    
                    <a href="https://nikitablack.github.io" class="js-remove-domain-schema">https://nikitablack.github.io</a>
                </div>
            </div>

            <div id="user_bio">
                <div class="inner">
                    
                </div>
            </div>

        </footer>




    <section class="post-comments">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
      var disqus_shortname = 'nikitablack'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </section>


    </article>

    <div id="share_modal">
        <div class="wrap">
            <div class="inner">
                <header>
                    Share
                    <a href="" class="close" title="Close">&times;</a>
                </header>

                <div class="roon-share-links">
                    <a href="https://twitter.com/share" class="twitter-share-button" data-dnt="true">Tweet</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                    <div id="fb-elems">
                        <div id="fb-root"></div>
                        <script>(function(d, s, id) {
                        var js, fjs = d.getElementsByTagName(s)[0];
                        if (d.getElementById(id)) return;
                        js = d.createElement(s); js.id = id;
                        js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=463438580397968";
                        fjs.parentNode.insertBefore(js, fjs);
                        }(document, 'script', 'facebook-jssdk'));</script>
                        <div class="fb-like" data-send="false" data-layout="button_count" data-width="110" data-show-faces="false" data-font="arial"></div>
                    </div>

                    <div id="pinit-btn">
                        <a href="//pinterest.com/pin/create/button/?url=https://nikitablack.github.io/2016/07/23/Direct-X-12-by-example.html&amp;description=DirectX%2012%20by%20example-Simply%20about%20complex " data-pin-do="buttonPin" data-pin-config="beside"><img src="//assets.pinterest.com/images/pidgets/pin_it_button.png"></a>
                        <script type="text/javascript" src="//assets.pinterest.com/js/pinit.js"></script>
                    </div>
                </div>
            </div>
        </div>
    </div>




        <a href="https://nikitablack.github.io" id="blog_badge">
            <span style="background-image: url('https://raw.githubusercontent.com/nikitablack/nikitablack.github.io/master/images/logo.jpg');">Simply about complex</span>
        </a>


    <script>

            function get_text(el) {
                ret = "";
                var length = el.childNodes.length;
                for(var i = 0; i < length; i++) {
                    var node = el.childNodes[i];
                    if(node.nodeType != 8) {
                        ret += node.nodeType != 1 ? node.nodeValue : get_text(node);
                    }
                }
                return ret;
            }
            function reading_time () {
                var post_content = document.getElementById('js-post-content');
                if (post_content) {
                    var words = get_text(post_content),
                        count = words.split(/\s+/).length,
                        read_time = Math.ceil((count / 150)),
                        read_time_node = document.createTextNode(read_time + ' min read');
                    document.getElementById('js-reading-time').appendChild(read_time_node);
                }
            }

        function no_schema_links () {
            var links = document.querySelectorAll('.js-remove-domain-schema');
            if (links) {
                for (i = 0; i < links.length; ++i) {
                    var link = links[i],
                        text = link.innerHTML,
                        no_schema = text.replace(/.*?:\/\//g, "");
                    link.innerHTML = no_schema;
                }
            }
        }

        window.onload = function () {
            no_schema_links();

            reading_time();
        }
    </script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();      
      </script>

        <script>
            $(function(){
                var share_modal = $("#share_modal"),
                    update_social_links = true;

                $("#btn_share").click(function(){
                    var that = $(this);
                    share_modal.fadeIn(200);
                    return false;
                });

                share_modal.click(function(e){
                    if (e.target.className == "wrap" || e.target.id == "share_modal") {
                        share_modal.fadeOut(200);
                    }
                    return false;
                });

                share_modal.find("div.inner > header > a.close").click(function(){
                    share_modal.fadeOut(200);
                    return false;
                });
            });
        </script>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-69402602-2', 'auto');
    ga('send', 'pageview');

    </script>

</body>
</html>
